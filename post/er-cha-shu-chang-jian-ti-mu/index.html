<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>二叉树的常见算法 | Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://stevenXu1992.github.io/favicon.ico?v=1590388457958">
<link rel="stylesheet" href="https://stevenXu1992.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1.判断是否为完全二叉树
判断标准：宽度优先遍历时 1）若某节点有右节点无左节点，则不为完全二叉树 2）某节点左右节点不全，后续都必须为叶节点，否则不是完全二叉树(用一个布尔值记录状态)
public static boolean heap..." />
    <meta name="keywords" content="二叉树" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://stevenXu1992.github.io">
        <img src="https://stevenXu1992.github.io/images/avatar.png?v=1590388457958" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://stevenXu1992.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">二叉树的常见算法</h2>
            <div class="post-date">2020-05-12</div>
            
            <div class="post-content" v-pre>
              <h2 id="1判断是否为完全二叉树">1.判断是否为完全二叉树</h2>
<p>判断标准：宽度优先遍历时 1）若某节点有右节点无左节点，则不为完全二叉树 2）某节点左右节点不全，后续都必须为叶节点，否则不是完全二叉树(用一个布尔值记录状态)</p>
<pre><code class="language-java">public static boolean heapTree(Node head){
  if(head == null){
    return true;
  }
  LinkedList&lt;Node&gt;() queue = new LinkedList&lt;&gt;();
  queue.add(head);
  boolean leaf = false;
  Node right = null;
  Node left = null;
  while(!queue.isEmpty()){
    head = queue.poll();
    right = head.right;
    left = head.left;
    if( (right != null &amp;&amp; left == null) //条件1
       || (leaf &amp;&amp; (right != null || left != null))){ //条件2
      return false;
    }
    if(right != null){
      queue.add(right);
    }
    if(left != null){
      queue.add(left);
    }
    if(right == null || left == null){
      leaf = true; //左右子树有一个为空，开启叶节点的记录状态
    }
  }
  return true;
} 
</code></pre>
<h2 id="2查找两个节点的最低公共祖先节点">2.查找两个节点的最低公共祖先节点</h2>
<p>设两个节点为n1,n2， 递归函数中：</p>
<ol>
<li>若头节点为n1或n2,返回自己（为空则返回空 ）</li>
<li>递归黑盒求出左右子树的返回值</li>
<li>若左右子树返回值都不为空，返回自己（已找到公共祖先）</li>
<li>左右子树一个为空一个不为空，返回不为空的一项</li>
</ol>
<pre><code class="language-java">public static Node process(Node head, Node n1, Node n2){
  if(head == null || head == n1 || head == n2){
    return head;
  }
  Node left = process(head.left, n1, n2);
  Node right = process(head.right, n1, n2);
  if(left != null &amp;&amp; right != null){
    return head;
  }
  return left == null ? right : left;
}
</code></pre>
<h2 id="3查找某节点的后继节点">3.查找某节点的后继节点</h2>
<p>后继节点：某节点在中序遍历中的下一个节点</p>
<pre><code class="language-java">public static Node find(Node node){
  if(node == null){
    return node;
  }
  if(node.right != null){ //有右树
    return process(node.right); //则中继为右树上最左的节点
  }else{ 	//	无右树
    Node parent = node.parent;
    //若node = parent.left, 则直接返回parent
    //否则继续向上寻找，直到node = parent.node
    //最后，若一直未找到则返回null(最右节点的中继为null)
    while(parent != null &amp;&amp; node != parent.left){
      node = parent;
      parent = node.parent;
    }
    return parent;
  }
} 

public static Node process(Node node){
  if(node == null){
    return node;
  }
  while(node.left != null){
    node = node.left;
  }
  return node;
}
</code></pre>
<h2 id="4序列化与反序列化">4.序列化与反序列化</h2>
<pre><code class="language-java">// '#'表示null, '_'用于分隔
public static String serial(Node node){
  if(node == null){
    return '#_';
  }
  String res = node.data + '_';
  //按照先序遍历的顺序将树序列化成字符串
  res += serial(node.left);
  res += serial(node.right);
  return res;
}

public static Node recon(String str){
  String[] arr = str.split('_');
  Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
  for(int i = 0; i != arr.length; i++){
    queue.offer(arr[i]);
  }
  return reconProcess(queue);
}

public static Node reconProcess(Queue&lt;String&gt; queue){
  String str = queue.poll();
  if(str.equals('#')){
    return null;
  }
  Node head = new Node(Integer.valueOf(str));
  head.left = reconProcess(queue);
  head.right = reconProcess(queue);
  return head;
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://stevenXu1992.github.io/tag/dxJiV25Oq/" class="tag">
                    二叉树
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://stevenXu1992.github.io/post/er-cha-shu-de-di-gui-kuang-jia/">
                  <h3 class="post-title">
                    二叉树的递归框架
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
