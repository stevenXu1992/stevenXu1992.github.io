<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>字符串算法 | Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://stevenXu1992.github.io/favicon.ico?v=1590388457958">
<link rel="stylesheet" href="https://stevenXu1992.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1. 前缀树
public static class TrieNode{
  public int pass;
  public int end;
  public TrieNode[] nexts;
  
  public TrieNod..." />
    <meta name="keywords" content="字符串" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://stevenXu1992.github.io">
        <img src="https://stevenXu1992.github.io/images/avatar.png?v=1590388457958" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://stevenXu1992.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">字符串算法</h2>
            <div class="post-date">2020-05-24</div>
            
            <div class="post-content" v-pre>
              <h2 id="1-前缀树">1. 前缀树</h2>
<pre><code class="language-java">public static class TrieNode{
  public int pass;
  public int end;
  public TrieNode[] nexts;
  
  public TrieNode(){
    pass = 0;
    end = 0;
    nexts = new TrieNode[26];
  }
}

public static class Trie{
  private TrieNode root;
  public Trie(){
    root = new TrieNode();
  }
  
  //加入单词
  public static void insert(String word){
    if(word == null){
      return;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    node.pass++;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        node.nexts[index] = new TrieNode();
      }
      node = node.nexts[index];
      node.pass++;
    }
    node.end++;
  }
  
  //查询某单词加过几次
  public static int search(String word){
    if(word == null){
      return 0;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        return 0;
      }
      node = node.nexts[index];
    }
    return node.end;
  }
  
  //查询某前缀加过几次
  public static int searchPrefix(String word){
    if(word == null){
      return 0;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        return 0;
      }
      node = node.nexts[index];
    }
    return node.pass;
  }
  
  //删除单词
  public static void delete(String word){
    if(search(word) == 0){
      return;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    node.pass--;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(--node.nexts[index].pass == 0){
        node.nexts[index] == null;
        return;
      }
    }
    node.end--;
  }
  
}
</code></pre>
<h2 id="2-kmp">2. KMP</h2>
<pre><code class="language-java">public static int KMP(String str1, String str2){
  if(str1 == null || str2 == null || 
     str2.length &gt; str1.length || str2.length() &lt; 1){
    return -1;
  }
  char[] char1 = str1.toCharArray();
  char[] char2 = str2.toCharArray();
  int[] next = getNext(char2);
  int i1 = 0;
  int i2 = 0;
  
  while(i1 &lt; char1.length &amp;&amp; i2 &lt; char2.length){
    if(char1[i1] == char2[i2]){
      i1++;
      i2++;
    }else if(i2 == 0){
      i1++;
    }else{
      i2 = next[i2];
    }
  }
  return i2 == char2.length ? i1 - i2 : -1;
}

//获取每个字符之前的最大相同前缀后缀的长度
public static int[] getNext(char[] chars){
  if(chars.length == 1){
    return new int[]{-1};
  }
  
  int[] next = new int[chars.length];
  next[0] = -1;
  next[1] = 0;
  int index = 2;
  int cn = 0;
  
  while(index &lt; next.length){
    if(chars[index - 1] == chars[cn]){
      next[index++] = cn++;
    }else(cn &gt; 0){
      cn = next[cn];
    }else{
      next[index++] = 0;
    }
  }
  return next;
}
</code></pre>
<h2 id="3-manacher">3. Manacher</h2>
<pre><code class="language-java">public static int manacher(String str){
  if(str == null || str.length == 1){
    return 0;
  }
  char[] chars = getManacherString(str);
  int[] help = new int[chars.length];
  int R = -1;	//R为已找到的最大回文区域的右边界
  int C = -1;	//C为最大回文区域的中心点
  int max = Integer.MIN_VALUE;
  for(int i = 0; i != chars.length; i++){
    
    //情况1: i超出已知的最大回文区域右边界，正常向两边寻找回文区域
    //情况2: i在已知的最大回文区域右边界内部
    //	1）i'的回文区域不超过最大回文区域的左边界：与i相同
    //	2）i'的回文区域超过最大回文区域的左边界：与R-i相同
    //	3）i'的回文区域正好在最大回文区域的左边界上：在R-i的基础上正常向两边寻找回文区域
    //2 * C - i 为 i'
    help[i] = R &gt; i ? Math.min(help[2 * C - i], R - i) : 1;
    while(i + help[i] &lt; chars.length &amp;&amp; i - help[i] &gt; -1){
      if(chars[i + help[i]] == chars[i - help[i]]){
        help[i]++;
      }else{
        break;
      }
    }
    //更新R和C
     if(i + help[i] &gt; R){
        R = i + help[i];
        C = i;
      }
      max = Math.max(max, help[i]);
  }
  return max - 1;
}

public static char[] getManacherString(String str){
  char[] chars = str.toCharArray();
  char[] res = new char[str.length * 2 - 1];
  int index = 0;
  for(int i = 0; i &lt; chars.length; i++){
    res[i] = (i &amp; 1) == 0 ? '#' : chars[index++];
  }
  return res;
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://stevenXu1992.github.io/tag/tdy68R30P/" class="tag">
                    字符串
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://stevenXu1992.github.io/post/bing-cha-ji/">
                  <h3 class="post-title">
                    并查集
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
