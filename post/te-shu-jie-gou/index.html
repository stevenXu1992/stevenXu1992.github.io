<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>特殊结构 | Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://stevenXu1992.github.io/favicon.ico?v=1590388457958">
<link rel="stylesheet" href="https://stevenXu1992.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1.滑动窗口
//窗口结构（最大值）
public static class WindowMax{
  private int L;
  private int R;
  private int[] arr;
  //队列中存放数组的下标，..." />
    <meta name="keywords" content="滑动窗口,单调栈" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://stevenXu1992.github.io">
        <img src="https://stevenXu1992.github.io/images/avatar.png?v=1590388457958" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://stevenXu1992.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">特殊结构</h2>
            <div class="post-date">2020-05-25</div>
            
            <div class="post-content" v-pre>
              <h2 id="1滑动窗口">1.滑动窗口</h2>
<pre><code class="language-java">//窗口结构（最大值）
public static class WindowMax{
  private int L;
  private int R;
  private int[] arr;
  //队列中存放数组的下标，peekfirst最大值
  private LinkedList&lt;Integer&gt; queue; 
  
  //初始化窗口
  public WindowMax(int[] arr){
    this.arr = arr;
    L = -1;
    R = 0;
    queue = new LinkedList&lt;&gt;(); 
  }
  
  //窗口右边界移动
  public void shiftRight(){
    if(R == arr.length){
      return;
    }
    while(!queue.isEmpty() &amp;&amp; arr[queue.peekLast()]&lt;=arr[R]){
      queue.pollLast();
    }
    queue.addLast(R);
    R++;
  }
  
  //窗口左边界移动
  public void shiftLeft(){
    if(L &gt; R - 1){
      return;
    }
    L++;
    if(queue.peekFirst() == L){
      queue.pollFirst();
    }
  }
  
  //获取窗口内最大值
  public int getMax(){
    if(!queue.isEmpty()){
      return arr[queue.peekFirst()];
    }
    return null;
  }
}

//请实现一个函数。 输入:整型数组arr，窗口大小为w。 输出:一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值
public static int[] getMaxInWindow(int[] arr, int w){
  if(arr == null || w &lt; 1 || arr.length &lt; w){
    return null;
  }
  LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
  int[] res = new int[arr.length - w + 1];
  int index = 0;
  for(int i = 0; i &lt; arr.length; i++){
    //窗口右边界向右滑动
    while(!queue.isEmpty() &amp;&amp; arr[queue.peekLast()] &lt;=arr[i]){
      queue.pollLast();
    }
  	queue.addLast(i);
    //窗口左边界向右滑动
    if(queue.peekFirst() == i - w){ 
      //i-w：过期的点，刚从窗口中出来的点，判断该点是否是队列的first
      queue.pollFirst();
    }
    //保存最大值信息
    if(i &gt;= w - 1){
      res[index++] = queue.peekFirst();
    }
  }
  return res;
}
</code></pre>
<h2 id="2单调栈">2.单调栈</h2>
<p>在数组中想找到一个数，左边和右边比这个数小、且离这个数最近的位置。如果对每一个数都想求这样的信息，能不能整体代价达到O(N)?</p>
<pre><code class="language-java">public static int[][] monotonousStack1(int[] arr){
  if(arr == null || arr.length &lt; 1){
    return null;
  }
  int[][] res = new int[arr.length][2];
  //单调栈顶为最大值,栈内存储数组的下标
  Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
  for(int i = 0; i &lt; arr.length; i++){
    //若新加元素小于栈顶，则弹出栈顶元素并记录结果
    while(!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]){
      int popIndex = stack.pop();
      int leftIndex = stack.isEmpty() ? -1 : stack.peek();
      res[popIndex][0] = leftIndex;
      res[popIndex][1] = i;
    }
    stack.push(i);
  }
  //加完全部元素并记录了结果后，弹出剩下的元素并记录
  while(!stack.isEmpty()){
    int popIndex = stack.pop();
    int leftIndex = stack.isEmpty() ? -1 : stack.peek();
    res[popIndex][0] = leftIndex;
    res[popIndex][1] = -1;
  }
  return res;
}

//数组中有重复的元素
public static int[][] monotonousStack2(int[] arr){
  Stack&lt;List&lt;Integer&gt;&gt; stack = new Stack&lt;&gt;();
  int[][] res = new int[arr.length][2];
  for(int i = 0; i &lt; arr.length; i++){
    //新加元素小于栈顶
    	while(!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){
        int popIndex = stack.pop();
        int leftIndex = stack.isEmpty() ? 
          -1 : stack.peek().get(stack.peek().size() - 1);
        res[popIndex][0] = leftIndex;
        res[popIndex][1] = i;
      }
    //新加元素等于栈顶
    if(arr[i] == arr[stack.peek().get(0)]{
      stack.peek().add(Integer.valueOf(i));
    }else{
      //新加元素大于栈顶
      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
      list.add(i);
      stack.push(list);
    }
  }
  //加完全部元素并记录了结果后，弹出剩下的元素并记录
  while(!stack.isEmpty()){
    List&lt;Integer&gt; restList = stack.pop();
    int leftIndex = stack.isEmpty() ? 
      -1 : stack.peek().get(stack.peek().size() - 1);
    for(Integer i : restList){
      res[i][0] = leftIndex;
      res[i][1] = -1;
    }
  }
  return res;
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://stevenXu1992.github.io/tag/m5thiK6Jm/" class="tag">
                    滑动窗口
                  </a>
                
                  <a href="https://stevenXu1992.github.io/tag/3zgRYDMrNW/" class="tag">
                    单调栈
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://stevenXu1992.github.io/post/zi-fu-chuan-suan-fa/">
                  <h3 class="post-title">
                    字符串算法
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
