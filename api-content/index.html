{"posts":[{"title":"Leetcode-383 Ransom Note","content":"Givenanarbitraryransomnotestringandanotherstringcontaininglettersfromallthemagazines,writeafunctionthatwillreturntrueiftheransomnotecanbeconstructedfromthemagazines;otherwise,itwillreturnfalse.Eachletterinthemagazinestringcanonlybeusedonceinyourransomnote.Example1:Input:ransomNote=&quot;a&quot;,magazine=&quot;b&quot;Output:falseExample2:Input:ransomNote=&quot;aa&quot;,magazine=&quot;ab&quot;Output:falseExample3:Input:ransomNote=&quot;aa&quot;,magazine=&quot;aab&quot;Output:true//mysubmissionpublicbooleancanConstruct(StringransomNote,Stringmagazine){int[]count=newint[26];char[]cMagazi=magazine.toCharArray();char[]cRansom=ransomNote.toCharArray();for(inti=0;i&lt;cMagazi.length;i++){count[cMagazi[i]-'a']++;}booleanres=true;for(intj=0;j&lt;cRansom.length;j++){if(count[cRansom[j]-'a']&gt;0){count[cRansom[j]-'a']--;}else{res=false;break;}}returnres;}","link":"https://stevenXu1992.github.io/post/leetcode-383-ransom-note/"},{"title":"Leetcode-384 First Unique Character in a String","content":"Givenastring,findthefirstnon-repeatingcharacterinitandreturnit'sindex.Ifitdoesn'texist,return-1.Examples:s=&quot;leetcode&quot;return0.s=&quot;loveleetcode&quot;,return2.//mysubmission//Timecomplexity:O(n)//Spacecomplexity:O(n)publicintfirstUniqChar(Strings){HashMap&lt;Character,Integer&gt;map=newHashMap&lt;&gt;();charc='';for(inti=0;i&lt;s.length();i++){c=s.charAt(i);if(map.containsKey(c)){map.put(c,map.get(c)+1);}else{map.put(c,1);}}intres=-1;for(intj=0;j&lt;s.length();j++){c=s.charAt(j);if(map.get(c)==1){res=j;break;}}returnres;}","link":"https://stevenXu1992.github.io/post/leetcode-384-first-unique-character-in-a-string/"},{"title":"Leetcode-14 Longest Common Prefix","content":"Writeafunctiontofindthelongestcommonprefixstringamongstanarrayofstrings.Ifthereisnocommonprefix,returnanemptystring&quot;&quot;.Example1:Input:[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output:&quot;fl&quot;Example2:Input:[&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output:&quot;&quot;Explanation:Thereisnocommonprefixamongtheinputstrings.//mysubmissionpublicStringlongestCommonPrefix(String[]strs){if(strs==null||strs.length==0||strs[0].length()==0){return&quot;&quot;;}if(strs.length==1){returnstrs[0];}Trietrie=newTrie();Stringprefix=&quot;&quot;;charfirst=strs[0].charAt(0);for(inti=0;i&lt;strs.length;i++){if(strs[i].length()==0||first!=strs[i].charAt(0)){return&quot;&quot;;}prefix=trie.insert(strs[i]);first=strs[i].charAt(0);}returnprefix;}publicclassTrieNode{publicintpass;publicintend;publicTrieNode[]next;publicTrieNode(){pass=0;end=0;next=newTrieNode[26];}}publicclassTrie{privateTrieNoderoot;publicTrie(){root=newTrieNode();}publicStringinsert(Stringword){if(word==null){return&quot;&quot;;}char[]c=word.toCharArray();TrieNodenode=root;node.pass++;intindex=0;intmaxPass=0;StringBuilderprefix=newStringBuilder();for(inti=0;i&lt;c.length;i++){index=c[i]-'a';if(node.next[index]==null){node.next[index]=newTrieNode();}node=node.next[index];node.pass++;if(node.pass&gt;=maxPass&amp;&amp;node.pass!=1){prefix.append(c[i]);maxPass=node.pass;}}node.end++;returnprefix.toString();}}","link":"https://stevenXu1992.github.io/post/leetcode-14-longest-common-prefix/"},{"title":"Leetcode-11 Container With Most Water","content":"Givennnon-negativeintegersa1,a2,...,an,whereeachrepresentsapointatcoordinate(i,ai).nverticallinesaredrawnsuchthatthetwoendpointsoflineiisat(i,ai)and(i,0).Findtwolines,whichtogetherwithx-axisformsacontainer,suchthatthecontainercontainsthemostwater.Note:Youmaynotslantthecontainerandnisatleast2.Theaboveverticallinesarerepresentedbyarray[1,8,6,2,5,4,8,3,7].Inthiscase,themaxareaofwater(bluesection)thecontainercancontainis49.Example:Input:[1,8,6,2,5,4,8,3,7]Output:49//solutionpublicintmaxArea(int[]height){intmax=0;for(inti=0;i&lt;height.length;i++){for(intj=1;j&lt;height.length;j++){if(Math.abs(j-i)*Math.min(height[i],height[j])&gt;max){max=Math.abs(j-i)*Math.min(height[i],height[j]);}}}returnmax;}","link":"https://stevenXu1992.github.io/post/leetcode-11-container-with-most-water/"},{"title":"Leetcode-121 122 Best Time to Buy and Sell Stock","content":"leetcode-121Sayyouhaveanarrayforwhichtheithelementisthepriceofagivenstockondayi.Ifyouwereonlypermittedtocompleteatmostonetransaction(i.e.,buyoneandselloneshareofthestock),designanalgorithmtofindthemaximumprofit.Notethatyoucannotsellastockbeforeyoubuyone.Example1:Input:[7,1,5,3,6,4]Output:5Explanation:Buyonday2(price=1)andsellonday5(price=6),profit=6-1=5.Not7-1=6,assellingpriceneedstobelargerthanbuyingprice.Example2:Input:[7,6,4,3,1]Output:0Explanation:Inthiscase,notransactionisdone,i.e.maxprofit=0.//solutionpublicintmaxProfit(intprices[]){intminprice=Integer.MAX_VALUE;intmaxprofit=0;for(inti=0;i&lt;prices.length;i++){if(prices[i]&lt;minprice)minprice=prices[i];elseif(prices[i]-minprice&gt;maxprofit)maxprofit=prices[i]-minprice;}returnmaxprofit;}leetcode-122Sayyouhaveanarraypricesforwhichtheithelementisthepriceofagivenstockondayi.Designanalgorithmtofindthemaximumprofit.Youmaycompleteasmanytransactionsasyoulike(i.e.,buyoneandselloneshareofthestockmultipletimes).Note:Youmaynotengageinmultipletransactionsatthesametime(i.e.,youmustsellthestockbeforeyoubuyagain).Example1:Input:[7,1,5,3,6,4]Output:7Explanation:Buyonday2(price=1)andsellonday3(price=5),profit=5-1=4.Thenbuyonday4(price=3)andsellonday5(price=6),profit=6-3=3.Example2:Input:[1,2,3,4,5]Output:4Explanation:Buyonday1(price=1)andsellonday5(price=5),profit=5-1=4.Notethatyoucannotbuyonday1,buyonday2andsellthemlater,asyouareengagingmultipletransactionsatthesametime.Youmustsellbeforebuyingagain.//solutionpublicintmaxProfit(int[]prices){inti=0;intvalley=prices[0];intpeak=prices[0];intmaxprofit=0;while(i&lt;prices.length-1){while(i&lt;prices.length-1&amp;&amp;prices[i]&gt;=prices[i+1])i++;valley=prices[i];while(i&lt;prices.length-1&amp;&amp;prices[i]&lt;=prices[i+1])i++;peak=prices[i];maxprofit+=peak-valley;}returnmaxprofit;}","link":"https://stevenXu1992.github.io/post/leetcode-121-122-best-time-to-buy-and-sell-stock/"},{"title":"Leetcode-45 Jump Game II","content":"Givenanarrayofnon-negativeintegers,youareinitiallypositionedatthefirstindexofthearray.Eachelementinthearrayrepresentsyourmaximumjumplengthatthatposition.Yourgoalistoreachthelastindexintheminimumnumberofjumps.Example:Input:[2,3,1,1,4]Output:2Explanation:Theminimumnumberofjumpstoreachthelastindexis2.Jump1stepfromindex0to1,then3stepstothelastindex.Note:Youcanassumethatyoucanalwaysreachthelastindex.//暴力递归(超时未通过)publicintjump(int[]nums){returnprocess(nums,0,0);}publicintprocess(int[]nums,intindex,intstep){if(index==nums.length-1){returnstep;}intmin=Integer.MAX_VALUE;intmaxDis=Math.min(index+nums[index],nums.length-1);for(inti=index+1;i&lt;=maxDis;i++){min=Math.min(process(nums,i,step+1),min);}returnmin;}//严格表结构动态规划publicintjump(int[]nums){returnprocess(nums);}publicintprocess(int[]nums){intN=nums.length;int[]dp=newint[N];Arrays.fill(dp,Integer.MAX_VALUE/2);dp[N-1]=0;for(intindex=N-2;index&gt;=0;index--){intmaxDis=Math.min(index+nums[index],N-1);for(inti=maxDis;i&gt;=index+1;i--){dp[index]=Math.min(dp[index],dp[i]+1);}}returndp[0];}","link":"https://stevenXu1992.github.io/post/leetcode-45-jump-game-ii/"},{"title":"Leetcode-55 Jump Game","content":"Givenanarrayofnon-negativeintegers,youareinitiallypositionedatthefirstindexofthearray.Eachelementinthearrayrepresentsyourmaximumjumplengthatthatposition.Determineifyouareabletoreachthelastindex.Example1:Input:nums=[2,3,1,1,4]Output:trueExplanation:Jump1stepfromindex0to1,then3stepstothelastindex.Example2:Input:nums=[3,2,1,0,4]Output:falseExplanation:Youwillalwaysarriveatindex3nomatterwhat.Itsmaximumjumplengthis0,whichmakesitimpossibletoreachthelastindex.Constraints:1&lt;=nums.length&lt;=3*10^40&lt;=nums[i][j]&lt;=10^5//暴力递归//Timecomplexity:O(2^n)//Spacecomplexity:O(n)publicbooleancanJump(int[]nums){returnprocess(nums,0);}publicbooleanprocess(int[]nums,intindex){if(index==nums.length-1){returntrue;}intmaxDis=Math.min(index+nums[index],nums.length-1);for(inti=index+1;i&lt;=maxDis;i++){if(process(nums,i)){returntrue;}}returnfalse;}//记忆化搜索//Timecomplexity:O(n^2)//Spacecomplexity:O(n)publicbooleancanJump(int[]nums){int[]dp=newint[nums.length+1];intres=process(nums,0,dp);returnres==1?true:false;}publicintprocess(int[]nums,intindex,int[]dp){if(dp[index]!=0){returndp[index];}if(index==nums.length-1){dp[index]=1;returndp[index];}intmaxDis=Math.min(index+nums[index],nums.length-1);for(inti=index+1;i&lt;=maxDis;i++){dp[index]=process(nums,i,dp);if(dp[index]==1){returndp[index];}}dp[index]=-1;returndp[index];}//严格表结构动态规划//Timecomplexity:O(n^2)//Spacecomplexity:O(n)publicbooleancanJump(int[]nums){intres=process(nums);returnres==1?true:false;}publicintprocess(int[]nums){int[]dp=newint[nums.length];dp[nums.length-1]=1;for(intindex=nums.length-2;index&gt;=0;index--){intmaxDis=Math.min(index+nums[index],nums.length-1);for(inti=index+1;i&lt;=maxDis;i++){if(dp[i]==1){dp[index]=1;break;}}}returndp[0];}","link":"https://stevenXu1992.github.io/post/leetcode-55-jump-game/"},{"title":"Leetcode-275 H-Index II","content":"Givenanarrayofcitationssortedinascendingorder(eachcitationisanon-negativeinteger)ofaresearcher,writeafunctiontocomputetheresearcher'sh-index.Accordingtothedefinitionofh-indexonWikipedia:&quot;Ascientisthasindexhifhofhis/herNpapershaveatleasthcitationseach,andtheotherN−hpapershavenomorethanhcitationseach.&quot;Example:Input:citations=[0,1,3,5,6]Output:3Explanation:[0,1,3,5,6]meanstheresearcherhas5papersintotalandeachofthemhadreceived0,1,3,5,6citationsrespectively.Sincetheresearcherhas3paperswithatleast3citationseachandtheremainingtwowithnomorethan3citationseach,herh-indexis3.Note:Ifthereareseveralpossiblevaluesforh,themaximumoneistakenastheh-index.Followup:ThisisafollowupproblemtoH-Index,wherecitationsisnowguaranteedtobesortedinascendingorder.Couldyousolveitinlogarithmictimecomplexity?//solutionpublicinthIndex(int[]citations){if(citations.length==0){return0;}intN=citations.length;intH=0;for(inti=N-1;i&gt;=0;i--){intnum=N-i;if(citations[i]&gt;=num){H=num;}}returnH;}注：定义变量num表示每个数在citations中对应的比自己大的数的个数（引用论文次数大于等于自己被引用的次数的总的篇数），比如0对应的num就是5，因为比0大或等的数的个数为5。因此，citations对应的num为：citations：01356num:54321“代表他（她）的N篇论文中至多有h篇论文，分别被引用了至少h次“，仔细分析这句话”至多有h篇论文“表示的是num[i]对就的数，”分别被引用了至少h次“表示的是citations[i]，则num[i]&lt;=citations[i]才满足条件。此处满足条件的是citations=[3,5,6]，对应的num=[3,2,1]。而我们只需要取num的最大值就可以了。————————————————版权声明：本文为CSDN博主「lear_scu」的原创文章，遵循CC4.0BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_36327328/java/article/details/83117379","link":"https://stevenXu1992.github.io/post/leetcode-275-h-index-ii/"},{"title":"Leetcode-274 H-Index","content":"Givenanarrayofcitations(eachcitationisanon-negativeinteger)ofaresearcher,writeafunctiontocomputetheresearcher'sh-index.Accordingtothedefinitionofh-indexonWikipedia:&quot;Ascientisthasindexhifhofhis/herNpapershaveatleasthcitationseach,andtheotherN−hpapershavenomorethanhcitationseach.&quot;Example:Input:citations=[3,0,6,1,5]Output:3Explanation:[3,0,6,1,5]meanstheresearcherhas5papersintotalandeachofthemhadreceived3,0,6,1,5citationsrespectively.Sincetheresearcherhas3paperswithatleast3citationseachandtheremainingtwowithnomorethan3citationseach,herh-indexis3.Note:Ifthereareseveralpossiblevaluesforh,themaximumoneistakenastheh-index.//solutionpublicinthIndex(int[]citations){intn=citations.length;int[]buckets=newint[n+1];for(intc:citations){if(c&gt;=n){buckets[n]++;}else{buckets[c]++;}}intcount=0;for(inti=n;i&gt;=0;i--){count+=buckets[i];if(count&gt;=i){returni;}}return0;}","link":"https://stevenXu1992.github.io/post/leetcode-274-h-index/"},{"title":"Leetcode-134 Gas Station","content":"ThereareNgasstationsalongacircularroute,wheretheamountofgasatstationiisgas[i].Youhaveacarwithanunlimitedgastankanditcostscost[i]ofgastotravelfromstationitoitsnextstation(i+1).Youbeginthejourneywithanemptytankatoneofthegasstations.Returnthestartinggasstation'sindexifyoucantravelaroundthecircuitonceintheclockwisedirection,otherwisereturn-1.Note:Ifthereexistsasolution,itisguaranteedtobeunique.Bothinputarraysarenon-emptyandhavethesamelength.Eachelementintheinputarraysisanon-negativeinteger.Example1:Input:gas=[1,2,3,4,5]cost=[3,4,5,1,2]Output:3Explanation:Startatstation3(index3)andfillupwith4unitofgas.Yourtank=0+4=4Traveltostation4.Yourtank=4-1+5=8Traveltostation0.Yourtank=8-2+1=7Traveltostation1.Yourtank=7-3+2=6Traveltostation2.Yourtank=6-4+3=5Traveltostation3.Thecostis5.Yourgasisjustenoughtotravelbacktostation3.Therefore,return3asthestartingindex.Example2:Input:gas=[2,3,4]cost=[3,4,3]Output:-1Explanation:Youcan'tstartatstation0or1,asthereisnotenoughgastotraveltothenextstation.Let'sstartatstation2andfillupwith4unitofgas.Yourtank=0+4=4Traveltostation0.Yourtank=4-3+2=3Traveltostation1.Yourtank=3-3+3=3Youcannottravelbacktostation2,asitrequires4unitofgasbutyouonlyhave3.Therefore,youcan'ttravelaroundthecircuitoncenomatterwhereyoustart.//mysubmissionpublicclassGasNode{intgas;intcost;intindex;GasNodenext;publicGasNode(intgas,intcost,intindex){this.gas=gas;this.cost=cost;this.index=index;}}publicintcanCompleteCircuit(int[]gas,int[]cost){//generateGasNodeListGasNodehead=newGasNode(gas[0],cost[0],0);GasNodecur=head;for(intj=1;j&lt;gas.length;j++){cur.next=newGasNode(gas[j],cost[j],j);cur=cur.next;}cur.next=head;//startfromeverystationfor(inti=0;i&lt;gas.length;i++){GasNodenode=head;intrestGas=node.gas;while(restGas&gt;=node.cost){restGas-=node.cost;node=node.next;restGas+=node.gas;if(node==head){returnhead.index;}}head=head.next;}return-1;}","link":"https://stevenXu1992.github.io/post/leetcode-134-gas-station/"},{"title":"Leetcode-299 Bulls and Cows","content":"YouareplayingthefollowingBullsandCowsgamewithyourfriend:Youwritedownanumberandaskyourfriendtoguesswhatthenumberis.Eachtimeyourfriendmakesaguess,youprovideahintthatindicateshowmanydigitsinsaidguessmatchyoursecretnumberexactlyinbothdigitandposition(called&quot;bulls&quot;)andhowmanydigitsmatchthesecretnumberbutlocateinthewrongposition(called&quot;cows&quot;).Yourfriendwillusesuccessiveguessesandhintstoeventuallyderivethesecretnumber.Writeafunctiontoreturnahintaccordingtothesecretnumberandfriend'sguess,useAtoindicatethebullsandBtoindicatethecows.Pleasenotethatbothsecretnumberandfriend'sguessmaycontainduplicatedigits.Example1:Input:secret=&quot;1807&quot;,guess=&quot;7810&quot;Output:&quot;1A3B&quot;Explanation:1bulland3cows.Thebullis8,thecowsare0,1and7.Example2:Input:secret=&quot;1123&quot;,guess=&quot;0111&quot;Output:&quot;1A1B&quot;Explanation:The1st1infriend'sguessisabull,the2ndor3rd1isacow.Note:Youmayassumethatthesecretnumberandyourfriend'sguessonlycontaindigits,andtheirlengthsarealwaysequal.//solutionpublicStringgetHint(Stringsecret,Stringguess){int[]record=newint[10];intA=0;intB=0;//使用record数组记录已出现过的数字（范围0～9）//在同位置的iSecret!=iGuess的情况下，出现过的iSecret使record数组对应位置的数字+1//出现过的iGuess使record数组对应位置的数字-1//因此若发现record[iSecret]&lt;0则表示此数字被发现过但还未使用过，record[iGuess]&gt;0同理。for(inti=0;i&lt;secret.length();i++){intiSecret=Character.getNumericValue(secret.charAt(i));intiGuess=Character.getNumericValue(guess.charAt(i));if(iSecret==iGuess){A++;}else{if(record[iSecret]&lt;0){B++;}if(record[iGuess]&gt;0){B++;}record[iSecret]++;record[iGuess]--;}}Stringans=A+&quot;A&quot;+B+&quot;B&quot;;returnans;}","link":"https://stevenXu1992.github.io/post/leetcode-299-bulls-and-cows/"},{"title":"Leetcode-41 First Missing Positive","content":"Givenanunsortedintegerarray,findthesmallestmissingpositiveinteger.Example1:Input:[1,2,0]Output:3Example2:Input:[3,4,-1,1]Output:2Example3:Input:[7,8,9,11,12]Output:1Note:YouralgorithmshouldruninO(n)timeandusesconstantextraspace.//solutionpublicintfirstMissingPositive(int[]A){inti=0;//遍历数组并将每个数n放到n-1位置A[A[i]-1]!=A[i]while(i&lt;A.length){if(A[i]&gt;=1&amp;&amp;A[i]&lt;=A.length&amp;&amp;A[A[i]-1]!=A[i]){swap(A,i,A[i]-1);}else{i++;}}//放好位置后再次遍历，第一次遇到A[i]!=i+1时就是答案for(inti=0;i&lt;A.length;i++)if(A[i]!=i+1){returni+1;}returnA.length+1;}privatevoidswap(int[]A,inti,intj){inttemp=A[i];A[i]=A[j];A[j]=temp;}","link":"https://stevenXu1992.github.io/post/leetcode-41-first-missing-positive/"},{"title":"Leetcode-189 Rotate Array","content":"Givenanarray,rotatethearraytotherightbyksteps,wherekisnon-negative.Followup:Trytocomeupasmanysolutionsasyoucan,thereareatleast3differentwaystosolvethisproblem.Couldyoudoitin-placewithO(1)extraspace?Example1:Input:nums=[1,2,3,4,5,6,7],k=3Output:[5,6,7,1,2,3,4]Explanation:rotate1stepstotheright:[7,1,2,3,4,5,6]rotate2stepstotheright:[6,7,1,2,3,4,5]rotate3stepstotheright:[5,6,7,1,2,3,4]//mysubmission//Timecomplexity:O(n*k)//Spacecomplexity:O(1)publicvoidrotate(int[]nums,intk){if(nums.length&lt;2){return;}while(k!=0){rotateOnce(nums);k--;}}publicvoidrotateOnce(int[]arr){for(inti=arr.length-1;i&gt;0;i--){inttemp=arr[i-1];arr[i-1]=arr[i];arr[i]=temp;}}//solution//Timecomplexity:O(n)//Spacecomplexity:O(1)publicvoidrotate(int[]nums,intk){k%=nums.length;reverse(nums,0,nums.length-1);reverse(nums,0,k-1);reverse(nums,k,nums.length-1);}publicvoidreverse(int[]nums,intstart,intend){while(start&lt;end){inttemp=nums[start];nums[start]=nums[end];nums[end]=temp;start++;end--;}}","link":"https://stevenXu1992.github.io/post/leetcode-189-rotate-array/"},{"title":"Leetcode-80 Remove Duplicates from Sorted Array II","content":"Givenasortedarraynums,removetheduplicatesin-placesuchthatduplicatesappearedatmosttwiceandreturnthenewlength.Donotallocateextraspaceforanotherarray,youmustdothisbymodifyingtheinputarrayin-placewithO(1)extramemory.Example1:Givennums=[1,1,1,2,2,3],Yourfunctionshouldreturnlength=5,withthefirstfiveelementsofnumsbeing1,1,2,2and3respectively.Itdoesn'tmatterwhatyouleavebeyondthereturnedlength.Example2:Givennums=[0,0,1,1,1,1,2,3,3],Yourfunctionshouldreturnlength=7,withthefirstsevenelementsofnumsbeingmodifiedto0,0,1,1,2,3and3respectively.Itdoesn'tmatterwhatvaluesaresetbeyondthereturnedlength.//solutionpublicintremoveDuplicates(int[]nums){if(nums.length&lt;3){returnnums.length;}intdif=2;for(inti=2;i&lt;nums.length;i++){if(nums[i]!=nums[dif-2]){nums[dif++]=nums[i];}}returndif;}","link":"https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/"},{"title":"Leetcode-26 Remove Duplicates from Sorted Array","content":"Givenasortedarraynums,removetheduplicatesin-placesuchthateachelementappearonlyonceandreturnthenewlength.Donotallocateextraspaceforanotherarray,youmustdothisbymodifyingtheinputarrayin-placewithO(1)extramemory.Example1:Givennums=[1,1,2],Yourfunctionshouldreturnlength=2,withthefirsttwoelementsofnumsbeing1and2respectively.Itdoesn'tmatterwhatyouleavebeyondthereturnedlength.Example2:Givennums=[0,0,1,1,1,2,2,3,3,4],Yourfunctionshouldreturnlength=5,withthefirstfiveelementsofnumsbeingmodifiedto0,1,2,3,and4respectively.Itdoesn'tmatterwhatvaluesaresetbeyondthereturnedlength.//solutionpublicstaticintf(int[]nums){if(nums.length==0){return0;}inti=0;for(intj=1;j&lt;nums.length;j++){if(nums[i]!=nums[j]){i++;nums[i]=nums[j];}}returni+1;}","link":"https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/"},{"title":"Leetcode-27 Remove Element","content":"Givenanarraynumsandavalueval,removeallinstancesofthatvaluein-placeandreturnthenewlength.Donotallocateextraspaceforanotherarray,youmustdothisbymodifyingtheinputarrayin-placewithO(1)extramemory.Theorderofelementscanbechanged.Itdoesn'tmatterwhatyouleavebeyondthenewlength.Example1:Givennums=[3,2,2,3],val=3,Yourfunctionshouldreturnlength=2,withthefirsttwoelementsofnumsbeing2.Itdoesn'tmatterwhatyouleavebeyondthereturnedlength.Example2:Givennums=[0,1,2,2,3,0,4,2],val=2,Yourfunctionshouldreturnlength=5,withthefirstfiveelementsofnumscontaining0,1,3,0,and4.Notethattheorderofthosefiveelementscanbearbitrary.Itdoesn'tmatterwhatvaluesaresetbeyondthereturnedlength.//mysubmissionpublicintremoveElement(int[]nums,intval){if(nums.length==0){return0;}if(nums.length==1){returnnums[0]==val?0:1;}intzone=nums.length-1;intindex=0;while(index&lt;=zone){if(nums[index]==val){swap(nums,index,zone--);}else{index++;}}returnzone+1;}publicstaticvoidswap(int[]arr,inta,intb){inttemp=arr[a];arr[a]=arr[b];arr[b]=temp;}","link":"https://stevenXu1992.github.io/post/leetcode-27-remove-element/"},{"title":"Leetcode-5 Longest Palindromic Substring","content":"Givenastrings,findthelongestpalindromicsubstringins.Youmayassumethatthemaximumlengthofsis1000.Example1:Input:&quot;babad&quot;Output:&quot;bab&quot;Note:&quot;aba&quot;isalsoavalidanswer.Example2:Input:&quot;cbbd&quot;Output:&quot;bb&quot;//mysubmissionpublicStringlongestPalindrome(Strings){if(s.length()&lt;2){returns.length()==1?s:&quot;&quot;;}//生成Manacher最长回文半径数组int[]manacher=manacher(s);char[]chars=getManacherString(s);intmax=Integer.MIN_VALUE;intmaxIndex=0;for(inti=0;i&lt;manacher.length;i++){if(manacher[i]&gt;max){max=manacher[i];maxIndex=i;}}Stringres=&quot;&quot;;max--;for(intj=maxIndex-max;j&lt;=maxIndex+max;j++){res+=chars[j];}//去除特殊符号res=restore(res,'#');returnres;}publicstaticint[]manacher(Strings){char[]chars=getManacherString(s);intR=-1;intC=-1;int[]manacher=newint[chars.length];for(inti=0;i!=chars.length;i++){//先算出不需要重复扩充的半径区域manacher[i]=R&gt;i?Math.min(manacher[2*C-i],R-i):1;//扩充过程while(i-manacher[i]&gt;-1&amp;&amp;i+manacher[i]&lt;chars.length){if(chars[i+manacher[i]]==chars[i-manacher[i]]){manacher[i]++;}else{break;}}//更新最大回文区域的右边界if(i+manacher[i]&gt;R){R=i+manacher[i];C=i;}}returnmanacher;}publicstaticchar[]getManacherString(Strings){char[]chars=s.toCharArray();char[]res=newchar[s.length()*2+1];intindex=0;for(inti=0;i!=res.length;i++){res[i]=(i&amp;1)==0?'#':chars[index++];}returnres;}publicstaticStringrestore(Strings,charr){Stringres=&quot;&quot;;for(inti=0;i&lt;s.length();i++){if(s.charAt(i)!=r){res+=s.charAt(i);}}returnres;}","link":"https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/"},{"title":"Leetcode-4 Median of Two Sorted Arrays","content":"Therearetwosortedarraysnums1andnums2ofsizemandnrespectively.Findthemedianofthetwosortedarrays.TheoverallruntimecomplexityshouldbeO(log(m+n)).Youmayassumenums1andnums2cannotbebothempty.Example1:nums1=[1,3]nums2=[2]Themedianis2.0Example2:nums1=[1,2]nums2=[3,4]Themedianis(2+3)/2=2.5//mysubmissionpublicdoublefindMedianSortedArrays(int[]nums1,int[]nums2){intN1=nums1.length;intN2=nums2.length;if(N1==0){returnN2%2==0?(nums2[N2/2]+nums2[N2/2-1])/2.0:nums2[N2/2];}elseif(N2==0){returnN1%2==0?(nums1[N1/2]+nums1[N1/2-1])/2.0:nums1[N1/2];}Queue&lt;Integer&gt;minHeap=newPriorityQueue&lt;&gt;();Queue&lt;Integer&gt;maxHeap=newPriorityQueue&lt;&gt;((a,b)-&gt;b-a);for(inti=0;i&lt;nums1.length/2;i++){maxHeap.add(nums1[i]);}for(intj=nums1.length-1;j&gt;=nums1.length/2;j--){minHeap.add(nums1[j]);}for(intk=0;k&lt;nums2.length;k++){if(nums2[k]&gt;minHeap.element()){minHeap.add(nums2[k]);}else{maxHeap.add(nums2[k]);}if(maxHeap.size()-minHeap.size()&gt;1){minHeap.add(maxHeap.poll());}elseif(minHeap.size()-maxHeap.size()&gt;1){maxHeap.add(minHeap.poll());}}if(minHeap.size()==maxHeap.size()){return(maxHeap.element()+minHeap.element())/2.0;}else{returnmaxHeap.size()&gt;minHeap.size()?maxHeap.element():minHeap.element();}}//solution//Timecomplexity:O(n+m)//Spacecomplexity:O(1)publicdoublefindMedianSortedArrays(int[]nums1,int[]nums2){intindex1=0;intindex2=0;intmed1=0;intmed2=0;for(inti=0;i&lt;=(nums1.length+nums2.length)/2;i++){med1=med2;if(index1==nums1.length){med2=nums2[index2];index2++;}elseif(index2==nums2.length){med2=nums1[index1];index1++;}elseif(nums1[index1]&lt;nums2[index2]){med2=nums1[index1];index1++;}else{med2=nums2[index2];index2++;}}if((nums1.length+nums2.length)%2==0){return(float)(med1+med2)/2;}returnmed2;}","link":"https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/"},{"title":"Leetcode-3 Longest Substring Without Repeating Characters","content":"Givenastring,findthelengthofthelongestsubstringwithoutrepeatingcharacters.Example1:Input:&quot;abcabcbb&quot;Output:3Explanation:Theansweris&quot;abc&quot;,withthelengthof3.Example2:Input:&quot;bbbbb&quot;Output:1Explanation:Theansweris&quot;b&quot;,withthelengthof1.Example3:Input:&quot;pwwkew&quot;Output:3Explanation:Theansweris&quot;wke&quot;,withthelengthof3.Notethattheanswermustbeasubstring,&quot;pwke&quot;isasubsequenceandnotasubstring.//mysubmission//Timecomplexity:O(n)publicintlengthOfLongestSubstring(Strings){if(s==null||s.length()==0){return0;}char[]chars=s.toCharArray();LinkedList&lt;Integer&gt;queue=newLinkedList&lt;&gt;();HashSet&lt;Character&gt;set=newHashSet&lt;&gt;();intmax=Integer.MIN_VALUE;for(inti=0;i&lt;chars.length;i++){while(!queue.isEmpty()&amp;&amp;set.contains(chars[i])){set.remove(chars[queue.pollFirst()]);}queue.addLast(i);set.add(chars[i]);max=Math.max(max,queue.size());}returnmax;}//solutionpublicintlengthOfLongestSubstring(Strings){intn=s.length();Set&lt;Character&gt;set=newHashSet&lt;&gt;();intans=0,i=0,j=0;while(i&lt;n&amp;&amp;j&lt;n){//trytoextendtherange[i,j]if(!set.contains(s.charAt(j))){set.add(s.charAt(j++));ans=Math.max(ans,j-i);}else{set.remove(s.charAt(i++));}}returnans;}","link":"https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/"},{"title":"Leetcode-2 Add Two Numbers","content":"Youaregiventwonon-emptylinkedlistsrepresentingtwonon-negativeintegers.Thedigitsarestoredinreverseorderandeachoftheirnodescontainasingledigit.Addthetwonumbersandreturnitasalinkedlist.Youmayassumethetwonumbersdonotcontainanyleadingzero,exceptthenumber0itself.Example:Input:(2-&gt;4-&gt;3)+(5-&gt;6-&gt;4)Output:7-&gt;0-&gt;8Explanation:342+465=807.//solution//Timecomplexity:O(Max(m,n))//Spacecomplexity:O(Max(m,n))publicListNodeaddTwoNumbers(ListNodel1,ListNodel2){ListNodedummyHead=newListNode(0);ListNodep=l1;ListNodeq=l2;ListNodecur=dummyHead;intcarry=0;while(p!=null||q!=null){//若两链表不等长，多出来的按0计算intx=p==null?0:p.val;inty=q==null?0:q.val;//carry表示进位//若sum小于10,carry=sum/10=0//若sum大于10，carry=sum/10=1intsum=carry+x+y;carry=sum/10;//若sum小于10,sum%10=sum//若sum大于10，sum%10=sum-10cur.next=newListNode(sum%10);cur=cur.next;if(p!=null){p=p.next;}if(q!=null){q=q.next;}}if(carry&gt;0){cur.next=newListNode(carry);}returndummyHead.next;}","link":"https://stevenXu1992.github.io/post/leetcode-2-add-two-numbers/"},{"title":"Leetcode-1 Two Sum","content":"Givenanarrayofintegers,returnindicesofthetwonumberssuchthattheyadduptoaspecifictarget.Youmayassumethateachinputwouldhave*exactly*onesolution,andyoumaynotusethesameelementtwice.Example:Givennums=[2,7,11,15],target=9,Becausenums[0]+nums[1]=2+7=9,return[0,1].//mysubmission//Timecomplexity:O(n^2)//Spacecomplexity:O(1)publicint[]twoSum(int[]nums,inttarget){if(nums==null||nums.length==0){returnnull;}int[]res=newint[2];for(inti=0;i&lt;nums.length;i++){for(intj=0;j&lt;nums.length;j++){if(nums[i]+nums[j]==target&amp;&amp;i!=j){res[0]=i;res[1]=j;}}}returnres;}//solution//Timecomplexity:O(n)//Spacecomplexity:O(n)publicint[]twoSum(int[]nums,inttarget){if(nums==null||nums.length==0){returnnull;}int[]res=newint[2];HashMap&lt;Integer,Integer&gt;map=newHashMap&lt;&gt;();for(inti=0;i&lt;nums.length;i++){map.put(nums[i],i);}for(intj=0;j&lt;nums.length;j++){intrest=target-nums[j];if(map.containsKey(rest)&amp;&amp;map.get(rest)!=j){res[0]=j;res[1]=map.get(rest);}}returnres;}","link":"https://stevenXu1992.github.io/post/leetcode-1-two-sum/"},{"title":"动态规划","content":"暴力递归--&gt;动态规划步骤：1)找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了2)把可变参数的所有组合映射成一张表，有1个可变参数就是一维表，2个可变参数就是二维3)最终答案要的是表中的哪个位置，在表中标出4)根据递归过程的basecase，把这张表的最简单不需要依赖其他位置的那些位置填好值5)根据递归过程非basecase的部分，也就是分析表中的普遍位置需要怎么计算得到，那么这张表的填写顺序也就确定了6)综上确定计算顺序，填好表，返回最终答案在表中位置的值1.机器人达到指定位置假设有排成一行的N个位置，记为1~N，N一定大于或等于2。开始时机器人在其中的M位置上(M一定是1~N中的一个)，机器人可以往左走或者往右走，如果机器人来到1位置，那么下一步只能往右来到2位置;如果机器人来到N位置，那么下一步只能往左来到N-1位置。规定机器人必须走K步，最终能来到P位置(P也一定是1~N中的一个)的方法有多少种。给定四个参数N、M、K、P，返回方法数。publicstaticintrobot(intN,intS,intE,intK){//N:共N个位置//S:起点//E:终点//K:可以走的步数if(N&lt;2||K&lt;1||S&lt;1||S&gt;N||E&lt;1||E&gt;N){return0;}//暴力递归intres=process1(N,S,E,K);//记忆化搜索int[][]dp=newint[K+1][N+1];for(inti=0;i&lt;K;i++){for(intj=0;j&lt;N;j++){dp[i][j]=-1;}}intres=process2(N,S,E,K,dp);//严格表结构动态规划intres=process(N,S,E,K);}//暴力递归publicstaticintprocess1(intN,intindex,intE,intrest){//index:当前位置//rest:还剩rest步if(rest==0){returnindex==E?1:0;}if(index==1){returnprocess(N,2,E,rest-1);}if(index==N){returnprocess(N,N-1,E,rest-1);}returnprocess(N,index+1,E,rest-1)+process(N,index-1,E,rest-1);}//记忆化搜索publicstaticintprocess2(intN,intindex,intE,intrest,int[][]dp){if(dp[index][rest]!=-1){returndp[index][rest];}if(rest==0){dp[index][rest]=E?1:0;}elseif(index==1){dp[index][rest]=process(N,2,E,rest-1);}elseif(index==N){dp[index][rest]=process(N,N-1,E,rest-1);}else{dp[index][rest]=process(N,index+1,E,rest-1)+process(N,index-1,E,rest-1);}returndp[index][rest];}//严格表结构动态规划publicstaticintprocess3(intN,intindex,intE,intrest){int[][]dp=newint[index+1][rest+1];dp[E][0]=1;for(inti=1;i&lt;index;i++){for(intj=1;j&lt;rest;j++){if(i==1){dp[i][j]=dp[2][j-1];}if(i==N){dp[i][j]=dp[N-1][j-1];}dp[i][j]=dp[i+1][j-1]+dp[i-1][j-1]}}returndp[index][rest];}2.换钱的最少货币数给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求组成aim的最少货币数。publicstaticintminCoin(int[]arr,intaim){if(arr.length==0||arr==null||aim&lt;0){return-1;}//暴力递归intres=process1(arr,0,aim);//记忆化搜索int[][]dp=newint[arr.length+1][aim+1];for(inti=0;i&lt;=arr.length;i++){for(intj=0;j&lt;=aim;j++){dp[i][j]=-2;}}intres=process2(arr,0,aim,dp);//严格表结构动态规划intres=process3(arr,0,aim);}//暴力递归publicstaticintprocess1(int[]arr,intindex,intrest){if(rest&lt;0){return-1;}if(rest==0){return0;}if(index==arr.length){return-1;}intp1=process1(arr,index+1,rest);intp2=process1(arr,index+1,rest-arr[index]);if(p1==-1&amp;&amp;p2==-1){return-1;}if(p1==-1){returnp2+1;}if(p2==-1){returnp1;}returnMath.min(p1,p2+1);}//记忆化搜索publicstaticintprocess2(int[]arr,intindex,intrest,int[][]dp){if(rest&lt;0){return-1;}if(dp[index][rest]!=-2){returndp[index][rest];}if(rest==0){dp[index][rest]=0;}elseif(index==arr.length){dp[index][rest]=-1;}else{intp1=process1(arr,index+1,rest);intp2=process1(arr,index+1,rest-arr[index]);if(p1==-1&amp;&amp;p2==-1){dp[index][rest]=-1;}else{if(p1==-1){dp[index][rest]=p2+1;}elseif(p2==-1){dp[index][rest]=p1;}else{dp[index][rest]=Math.min(p1,p2+1);}}}returndp[index][rest];}//严格表结构动态规划publicstaticintprocess3(int[]arr,intindex,intrest){int[][]dp=newint[arr.length+1][rest+1];for(inti=0;i&lt;=arr.length;i++){dp[i][0]=0;}for(intj=1;j&lt;=rest;j++){dp[arr.length][j]=-1;}for(inti=arr.length-1;i&gt;=0;i--){for(intj=1;j&lt;=rest;j++){intp1=dp[i+1][j];intp2=-1;if(j-arr[i]&gt;=0){p2=dp[i+1][j-arr[j]];}if(p1==-1&amp;&amp;p2==-1){dp[i][j]=-1;}if(p1==-1){dp[i][j]=p2+1;}if(p2==-1){dp[i][j]=p1;}dp[i][j]=Math.min(p1,p2+1);}}returndp[index][rest];}3.取纸牌问题给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。//暴力递归publicstaticintmaxWinSorce1(int[]arr){if(arr==null){return0;}returnMath.max(firstHand(arr,0,arr.length-1),secondHand(arr,0,arr.length-1));}publicstaticintfirstHand(int[]arr,intleft,intright){if(left==right){returnarr[left];}Math.max(arr[left]+secondHand(arr,left+1,right),arr[right]+secondHand(arr,left,right-1));}publicstaticintsecondHand(int[]arr,intleft,intright){if(left==right){return0;}Math.min(firstHand(arr,left+1,right),firstHand(arr,left,right-1));}//动态规划publicstaticintmaxWinScorce2(int[]arr){if(arr==null||arr.length=0){return0;}intN=arr.length;int[][]dpF=newint[N][N];int[][]dpS=newint[N][N];for(intleft=0;left&lt;N;left++){dpF[left][left]=arr[left];for(intright=left-1;right&gt;=0;right--){dpF[left][right]=Math.max(arr[left]+dpS[left+1][right],arr[right]+dpS[left][right-1]);dpS[left][right]=Math.min(dpF[left+1][right],dpF[left][right-1]);}}returnMath.max(dpF[0][N-1],dpS[0][N-1]);}4.象棋中马的跳法请同学们自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置。那么整个棋盘就是横坐标上9条线、纵坐标上10条线的一个区域。给你三个参数，x，y，k，返回如果“马”从(0,0)位置出发，必须走k步，最后落在(x,y)上的方法数有多少种?//暴力递归publicstaticintprocess1(intx,inty,intk){if(x&lt;0||x&gt;8||y&lt;0||y&gt;9){return0;}//剩余步数为零时，所在位置(x,y)距终点的相对距离为(0,0)时找到一种跳法if(k==0){return(x==0&amp;&amp;y==0)?1:0;}intres=process1(x-1,y+2,k-1)+process1(x+1,y+2,k-1)+process1(x+2,y+1,k-1)+process1(x+2,y-1,k-1)+process1(x+1,y-2,k-1)+process1(x-1,y-2,k-1)+process1(x-2,y-1,k-1)+process1(x-2,y+1,k-1);returnres;}//动态规划publicstaticintprocess2(intx,inty,intk){if(x&lt;0||x&gt;8||y&lt;0||y&gt;9){return0;}//x,y,k为立方体的长宽高,k层的数据取决于k-1层，因此从下往上填int[][][]dp=newint[9][10][k+1];dp[0][0][0]=1;for(intheight=1;height&lt;=k;height++){for(intlen=0;len&lt;9;len++){for(intwid=0;wid&lt;10;wid++){dp[len][wid][height]=getValue(dp,len-1,wid+2,height-1)+getValue(dp,len+1,wid+2,height-1)+getValue(dp,len+2,wid+1,height-1)+getValue(dp,len+2,wid-1,height-1)+getValue(dp,len+1,wid-2,height-1)+getValue(dp,len-1,wid-2,height-1)+getValue(dp,len-2,wid-1,height-1)+getValue(dp,len-2,wid+1,height-1);}}}returndp[x][y][k];}publicstaticintgetValue(int[][][]dp,intheight,intlen,intwid){if(len&lt;0||len&gt;8||wid&lt;0||wid&gt;9){return0;}returndp[len][wid][height];}5.Bob的生存概率给定五个参数n,m,i,j,k。表示在一个N*M的区域，Bob处在(i,j)点，每次Bob等概率的向上、下、左、右四个方向移动一步，Bob必须走K步。如果走完之后，Bob还停留在这个区域上，就算Bob存活，否则就算Bob死亡。请求解Bob的生存概率，返回字符串表示分数的方式。//暴力递归publicstaticStringbob(intn,intm,inti,intj,intk){longall=(long)Math.pow(4,k);longlive=process1(n,m,i,j,k);longgc=gcd(all,live);returnString.valueOf((live/gc)+&quot;/&quot;+(all/gc));}//返回可以存活的走法数publicstaticlongprocess1(intN,intM,inti,intj,intrest){if(i&lt;0||i&gt;N||j&lt;0||j&gt;M){return0;}if(rest==0){return1;}longlive=process1(N,M,i+1,j,rest-1)+process1(N,M,i,j+1,rest-1)+process1(N,M,i-1,j,rest-1)+process1(N,M,i,j-1,rest-1);}//动态规划publicstaticlongprocess2(intN,intM,inti,intj,intK){int[][][]dp=newint[N+1][M+1][K+1];for(intlen=0;len&lt;=N;len++){for(intwid=0;wid&lt;=M;wid++){dp[len][wid][0]=1;}}for(intheight=1;height&lt;=K;height++){for(intlen=0;len&lt;=N;len++){for(intwid=0;wid&lt;=M;wid++){dp[len][wid][height]=dp[len+1][wid][height-1]+dp[len-1][wid][height-1]+dp[len][wid+1][height-1]+dp[len][wid-1][height-1];}}}returndp[i][j][K];}publicstaticlonggcd(longm,longn){returnn==0?m:gcd(n,m%n);}","link":"https://stevenXu1992.github.io/post/dong-tai-gui-hua/"},{"title":"Morris遍历","content":"Morris遍历细节假设来到当前节点cur，开始时cur来到头节点位置1)如果cur没有左孩子，cur向右移动(cur=cur.right)2)如果cur有左孩子，找到左子树上最右的节点mostRight:​a.如果mostRight的右指针指向空，让其指向cur，然后cur向左移动(cur=cur.left)​b.如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur=cur.right)3)cur为空时遍历停止1.Morris自然序遍历Morris序：1-&gt;2-&gt;4-&gt;2-&gt;5-&gt;1-&gt;3-&gt;6-&gt;3-&gt;7publicstaticvoidmorrisClassical(Nodehead){if(head==null){return;}Nodecur=head;NodemostR=null;while(cur!=null){mostR=cur.left;//cur有左树，找到左树上最右的节点if(mostR!=null){while(mostR.right!=null&amp;&amp;mostR.right!=cur){mostR=mostR.right;}//此时mostR已到达cur左树上最右的节点处if(mostR.right==null){//若发现mostR右树为空，则是第一次到达该点mostR.right=cur;//先序操作//将mostR.right指向cur后，cur继续往下走执行外部while循环cur=cur.left;continue;}else{//若发现mostR.right指向cur，则是第二次到达该点，还原指针mostR.right=null;//edgeR(cur.left);后序操作}}//else{先序操作}//cur无左树，cur向右移动（通过之前修改的mostR.right指针返回父节点）,继续执行外部的while循环//中序操作cur=cur.right;}//edgeR（head);后序操作}2.先序遍历先序：1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6-&gt;7首次到达时进行操作，见1自然序注释3.中序遍历先序：4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7叶节点直接操作，其他节点第二次达到时操作，见1自然序注释4.后序遍历后序：4-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1发现第二次到达时，逆序操作cur左树的右边界，遍历完成后逆序操作整棵树的右边界，见1自然序注释publicstaticvoidedgeR(Nodehead){Nodetail=reverseEdge(head);Nodecur=tail;while(cur!=null){//遍历操作cur=cur.right;}reverseEdge(tail);}publicstaticNodereverseEdge(Nodefrom){Nodepre=null;Nodenext=next;while(from!=null){next=from.right;from.right=pre;pre=from;from=next;}returnpre;}","link":"https://stevenXu1992.github.io/post/morris-bian-li/"},{"title":"特殊结构","content":"1.滑动窗口//窗口结构（最大值）publicstaticclassWindowMax{privateintL;privateintR;privateint[]arr;//队列中存放数组的下标，peekfirst最大值privateLinkedList&lt;Integer&gt;queue;//初始化窗口publicWindowMax(int[]arr){this.arr=arr;L=-1;R=0;queue=newLinkedList&lt;&gt;();}//窗口右边界移动publicvoidshiftRight(){if(R==arr.length){return;}while(!queue.isEmpty()&amp;&amp;arr[queue.peekLast()]&lt;=arr[R]){queue.pollLast();}queue.addLast(R);R++;}//窗口左边界移动publicvoidshiftLeft(){if(L&gt;R-1){return;}L++;if(queue.peekFirst()==L){queue.pollFirst();}}//获取窗口内最大值publicintgetMax(){if(!queue.isEmpty()){returnarr[queue.peekFirst()];}returnnull;}}//请实现一个函数。输入:整型数组arr，窗口大小为w。输出:一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值publicstaticint[]getMaxInWindow(int[]arr,intw){if(arr==null||w&lt;1||arr.length&lt;w){returnnull;}LinkedList&lt;Integer&gt;queue=newLinkedList&lt;&gt;();int[]res=newint[arr.length-w+1];intindex=0;for(inti=0;i&lt;arr.length;i++){//窗口右边界向右滑动while(!queue.isEmpty()&amp;&amp;arr[queue.peekLast()]&lt;=arr[i]){queue.pollLast();}queue.addLast(i);//窗口左边界向右滑动if(queue.peekFirst()==i-w){//i-w：过期的点，刚从窗口中出来的点，判断该点是否是队列的firstqueue.pollFirst();}//保存最大值信息if(i&gt;=w-1){res[index++]=queue.peekFirst();}}returnres;}2.单调栈在数组中想找到一个数，左边和右边比这个数小、且离这个数最近的位置。如果对每一个数都想求这样的信息，能不能整体代价达到O(N)?publicstaticint[][]monotonousStack1(int[]arr){if(arr==null||arr.length&lt;1){returnnull;}int[][]res=newint[arr.length][2];//单调栈顶为最大值,栈内存储数组的下标Stack&lt;Integer&gt;stack=newStack&lt;&gt;();for(inti=0;i&lt;arr.length;i++){//若新加元素小于栈顶，则弹出栈顶元素并记录结果while(!stack.isEmpty()&amp;&amp;arr[stack.peek()]&gt;arr[i]){intpopIndex=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek();res[popIndex][0]=leftIndex;res[popIndex][1]=i;}stack.push(i);}//加完全部元素并记录了结果后，弹出剩下的元素并记录while(!stack.isEmpty()){intpopIndex=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek();res[popIndex][0]=leftIndex;res[popIndex][1]=-1;}returnres;}//数组中有重复的元素publicstaticint[][]monotonousStack2(int[]arr){Stack&lt;List&lt;Integer&gt;&gt;stack=newStack&lt;&gt;();int[][]res=newint[arr.length][2];for(inti=0;i&lt;arr.length;i++){//新加元素小于栈顶while(!stack.isEmpty()&amp;&amp;arr[i]&lt;arr[stack.peek()]){intpopIndex=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);res[popIndex][0]=leftIndex;res[popIndex][1]=i;}//新加元素等于栈顶if(arr[i]==arr[stack.peek().get(0)]{stack.peek().add(Integer.valueOf(i));}else{//新加元素大于栈顶ArrayList&lt;Integer&gt;list=newArrayList&lt;&gt;();list.add(i);stack.push(list);}}//加完全部元素并记录了结果后，弹出剩下的元素并记录while(!stack.isEmpty()){List&lt;Integer&gt;restList=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);for(Integeri:restList){res[i][0]=leftIndex;res[i][1]=-1;}}returnres;}","link":"https://stevenXu1992.github.io/post/te-shu-jie-gou/"},{"title":"字符串算法","content":"1.前缀树publicstaticclassTrieNode{publicintpass;publicintend;publicTrieNode[]nexts;publicTrieNode(){pass=0;end=0;nexts=newTrieNode[26];}}publicstaticclassTrie{privateTrieNoderoot;publicTrie(){root=newTrieNode();}//加入单词publicstaticvoidinsert(Stringword){if(word==null){return;}char[]chars=word.toCharArray();TrieNodenode=root;node.pass++;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(node.nexts[index]==null){node.nexts[index]=newTrieNode();}node=node.nexts[index];node.pass++;}node.end++;}//查询某单词加过几次publicstaticintsearch(Stringword){if(word==null){return0;}char[]chars=word.toCharArray();TrieNodenode=root;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(node.nexts[index]==null){return0;}node=node.nexts[index];}returnnode.end;}//查询某前缀加过几次publicstaticintsearchPrefix(Stringword){if(word==null){return0;}char[]chars=word.toCharArray();TrieNodenode=root;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(node.nexts[index]==null){return0;}node=node.nexts[index];}returnnode.pass;}//删除单词publicstaticvoiddelete(Stringword){if(search(word)==0){return;}char[]chars=word.toCharArray();TrieNodenode=root;node.pass--;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(--node.nexts[index].pass==0){node.nexts[index]==null;return;}}node.end--;}}2.KMPpublicstaticintKMP(Stringstr1,Stringstr2){if(str1==null||str2==null||str2.length&gt;str1.length||str2.length()&lt;1){return-1;}char[]char1=str1.toCharArray();char[]char2=str2.toCharArray();int[]next=getNext(char2);inti1=0;inti2=0;while(i1&lt;char1.length&amp;&amp;i2&lt;char2.length){if(char1[i1]==char2[i2]){i1++;i2++;}elseif(i2==0){i1++;}else{i2=next[i2];}}returni2==char2.length?i1-i2:-1;}//获取每个字符之前的最大相同前缀后缀的长度publicstaticint[]getNext(char[]chars){if(chars.length==1){returnnewint[]{-1};}int[]next=newint[chars.length];next[0]=-1;next[1]=0;intindex=2;intcn=0;while(index&lt;next.length){if(chars[index-1]==chars[cn]){next[index++]=++cn;}else(cn&gt;0){cn=next[cn];}else{next[index++]=0;}}returnnext;}3.Manacherpublicstaticintmanacher(Stringstr){if(str==null||str.length==1){return0;}char[]chars=getManacherString(str);int[]help=newint[chars.length];intR=-1;//R为已找到的最大回文区域的右边界intC=-1;//C为最大回文区域的中心点intmax=Integer.MIN_VALUE;for(inti=0;i!=chars.length;i++){//情况1:i超出已知的最大回文区域右边界，正常向两边寻找回文区域//情况2:i在已知的最大回文区域右边界内部//1）i'的回文区域不超过最大回文区域的左边界：与i相同//2）i'的回文区域超过最大回文区域的左边界：与R-i相同//3）i'的回文区域正好在最大回文区域的左边界上：在R-i的基础上正常向两边寻找回文区域//2*C-i为i'help[i]=R&gt;i?Math.min(help[2*C-i],R-i):1;while(i+help[i]&lt;chars.length&amp;&amp;i-help[i]&gt;-1){if(chars[i+help[i]]==chars[i-help[i]]){help[i]++;}else{break;}}//更新R和Cif(i+help[i]&gt;R){R=i+help[i];C=i;}max=Math.max(max,help[i]);}returnmax-1;}publicstaticchar[]getManacherString(Stringstr){char[]chars=str.toCharArray();char[]res=newchar[str.length*2-1];intindex=0;for(inti=0;i&lt;chars.length;i++){res[i]=(i&amp;1)==0?'#':chars[index++];}returnres;}","link":"https://stevenXu1992.github.io/post/zi-fu-chuan-suan-fa/"},{"title":"并查集","content":"1.并查集结构publicclassUnionFind{//并查集元素publicstaticclassElement&lt;V&gt;{publicVvalue;publicElement(Vvalue){this.value=value;}}//并查集初始化publicstaticclassUnionSet{HashMap&lt;V,Element&lt;V&gt;&gt;elementMap;HashMap&lt;Element&lt;V&gt;,Element&lt;V&gt;&gt;fatherMap;HashMap&lt;Element&lt;V&gt;,Integer&gt;sizeMap;publicUnionSet&lt;V&gt;(List&lt;V&gt;list){elementMap=newHashMap&lt;&gt;();fatherMap=newHashMap&lt;&gt;();sizeMap=newHashMap&lt;&gt;();for(Vv:list){Element&lt;V&gt;e=newElement&lt;&gt;(v);elementMap.put(v,e);fatherMap.put(e,e);sizeMap.put(e,1);}}}//判断是否属于同一集合publicstaticbooleansame(Vv1,Vv2){if(elementMap.containsKey(v1)&amp;&amp;elementMap.containsKey(v2)){returnfindHead(elementMap.get(v1))==findHead(elementMap.get(v2));}returnfalse;}//集合合并publicstaticvoidunion(Vv1,Vv2){if(elementMap.containsKey(v1)&amp;&amp;elementMap.containsKey(v2)){Element&lt;V&gt;head1=findHead(elementMap.get(v1));Element&lt;V&gt;head2=findHead(elementMap.get(v2));if(head1!=head2){Element&lt;V&gt;big=sizeMap.get(head1)&gt;=sizeMap.get(head2)?head1:head2;Element&lt;V&gt;small=big==head1?head2:head1:fatherMap.put(small,big);sizeMap.put(big,sizeMap.get(big)+sizeMap.get(small));sizeMap.remove(small);}}}//查找头元素privatestaticElement&lt;V&gt;findHead(Element&lt;V&gt;e){Stack&lt;Element&lt;V&gt;&gt;stack=newStack&lt;&gt;();while(e!=fatherMap.get(e)){stack.push(e);e=fatherMap.get(e);}while(!stack.isEmpty()){fatherMap.put(stack.pop(),e);}returne;}}2.Kruskal最小生成树//优先级队列的比较器，权重小的边先出publicstaticclassmyComparatorimplementsComparator&lt;edge&gt;{publicintcompare(Edgeo1,Edgeo2){returno1.weight-o1.weight;}}publicstaticSet&lt;Edge&gt;kruskal(Graphgraph){List&lt;Node&gt;list=(List&lt;Node&gt;)graph.nodes.values();UnionSet&lt;Node&gt;unionSet=newunionSet&lt;&gt;(List);PriorityQueue&lt;Edge&gt;queue=newPriorityQueue&lt;&gt;(newmyComparator());for(Edgee:graph.edges){queue.add(e);}HashSet&lt;Edge&gt;res=newHashSet&lt;&gt;();while(!queue.isEmpty()){Edgee=queue.poll();if(!unionSet.same(e.from,e.to)){res.add(e);unionSet.union(e.from,e.to);}}returnres;}3.岛问题的并行算法设计publicstaticintisland(int[][]matrix){if(matrix==null||matrix[0]==null){return0;}intlength=matrix.length;intwidth=matrix[0].length;intres=0;for(inti=0;i&lt;length;i++){for(intj=0;j&lt;width;j++){if(matrix[i][j]==1){res++;infect(matrix,i,j,length,width);}}}}publicstaticvoidinfect(int[]matrix,inti,intj,intlength,intwidth){if(i&lt;0||i&gt;=length||j&lt;0||j&gt;=width||matrix[i][j]!=1){return;}matrix[i][j]=2;infect(matrix,i+1,j,length,width);infect(matrix,i-1,j,length,width);infect(matrix,i,j+1,length,width);infect(matrix,i,j-1,length,width);}","link":"https://stevenXu1992.github.io/post/bing-cha-ji/"},{"title":"暴力递归","content":"1.汉诺塔publicstaticvoidhannoi(intn){process(n,&quot;from&quot;,&quot;to&quot;,&quot;help&quot;);}publicstaticvoidprocess(intn,Stringfrom,Stringto,Stringhelp){if(n==1){System.out.println(&quot;move&quot;+from+&quot;to&quot;+to);}else{process(n-1,from,help,to);process(1,from,to,help);process(n-1,help,to,from);}}2.字符串子序列publicstaticList&lt;String&gt;subSequence(Stringstr){List&lt;String&gt;res=newArrayList&lt;&gt;();if(str==null){returnres;}if(str.length()==0){res.add(&quot;&quot;);returnres;}char[]chars=str.toCharArray();process(res,chars,&quot;&quot;,0);}publicstaticList&lt;String&gt;process(List&lt;String&gt;list,char[]chars,Stringpath,intindex){if(index==chars.length){list.add(path);}else{process(list,chars,path,index+1);process(list,chars,path+String.valueOf(chars[index]),index+1);}}3.字符串全排列publicstaticList&lt;String&gt;allArray(Stringstr){List&lt;String&gt;res=newArrayList&lt;&gt;();ArrayList&lt;String&gt;set=newArrayList&lt;&gt;();char[]chars=str.toCharArray();for(charc:chars){set.add(c);}process(set,&quot;&quot;,res);returnres;}publicstaticvoidprocess(ArrayList&lt;String&gt;set,Stringpath,List&lt;String&gt;list){if(set.isEmpty()){list.add(path);}HashSet&lt;Character&gt;picked=newHashSet&lt;&gt;();for(inti=0;i&lt;set.size();i++){if(!picked.contains(set.get(i))){picked.add(set.get(i));StringnewPath=path+set.get(i);ArrayList&lt;String&gt;next=newArrayList&lt;&gt;(set);next.remove(i);process(next,newPath,list);}}}4.背包问题publicstaticintbackpack(int[]weights,int[]values,intindex,intweighted,intbagLimit){if(weighted&gt;bagLimit){return0;}if(index&gt;weights.length){return0;}Math.max(backpack(weights,values,index+1,weighted,bagLimit),backpack(weights,values,index+1,weighted+weights[index],bagLimit)+values[index]);}5.纸牌问题publicstaticintmaxWinSorce(int[]arr){if(arr==null){return0;}returnMath.max(firstHand(arr,0,arr.length-1),)secondHand(arr,0,arr.length-1);}publicstaticintfirstHand(int[]arr,intleft,intright){if(left==right){returnarr[left];}Math.max(arr[left]+secondHand(arr,left+1,right),arr[right]+secondHand(arr,left,right-1));}publicstaticintsecondHand(int[]arr,intleft,intright){if(left==right){return0;}Math.min(firstHand(arr,left+1,right),firstHand(arr,left,right-1));}6.N皇后publicstaticintNQueen(intn){if(n&lt;1){return0;}returnprocess(0,newint[n],n);}publicstaticintprocess(intindex,int[]record,intn){if(index==n){return1;}intres=0;for(intj=0;j&lt;n;j++){if(valid(record,index,j)){record[index]=j;res+=process(index+1,record,n);}}returnres;}publicstaticbooleanvalid(int[]record,intindex,intj){for(intk=0;k&lt;index;k++){if(record[k]==j||Math.abs(record[k]-j)==Math.abs(i-k)){returnfalse;}}returntrue;}","link":"https://stevenXu1992.github.io/post/bao-li-di-gui/"},{"title":"图的经典算法","content":"1.模版publicclassGraph{publicHashMap&lt;Integer,Node&gt;nodes;publicHashSet&lt;Edge&gt;edges;publicGraph(){nodes=newHashMap&lt;&gt;();edges=newHashSet&lt;&gt;();}}publicclassNode{publicintvalue;publicintin;publicintout;publicArrayList&lt;Node&gt;nexts;publicArrayList&lt;Edge&gt;edges;publicNode(intdata){this.value=data;in=0;out=0;nexts=newArrayList&lt;&gt;();edges=newArrayList&lt;&gt;();}}publicclassEdge{publicintweight;publicNodefrom;publicNodeto;publicEdge(intweight,Nodefrom,Nodeto){this.weight=weight;this.from=from;this.to=to;}}2.图的遍历2.1宽度优先遍历publicstaticvoidBFS(Nodenode){if(node==null){return;}LinkedList&lt;Node&gt;queue=newLinkedList&lt;&gt;();HashSet&lt;Node&gt;set=newHashSet&lt;&gt;();queue.add(node);set.add(node);while(!queue.isEmpty()){Nodecur=queue.poll();//具体遍历操作for(Noden:cur.nexts){if(!set.contains(n)){queue.add(n);set.add(n);}}}}2.2深度优先遍历publicstaticvoidDFS(Nodenode){if(node==null){return;}Stack&lt;Node&gt;stack=newStack&lt;&gt;();HashSet&lt;Node&gt;set=newHashSet&lt;&gt;();stack.push(node);set.add(node);//具体遍历操作while(!stack.isEmpty()){Nodecur=stack.pop();for(Noden:cur.nexts){if(!set.contains(n)){stack.push(cur);stack.push(n);set.add(n);//具体遍历操作break;}}}}3.拓扑排序publicstaticList&lt;Node&gt;topologySort(Graphgraph){HashMap&lt;Node,Integer&gt;map=newHashMap&lt;&gt;();LinkedList&lt;Node&gt;queue=newLinkedList&lt;&gt;();ArrayList&lt;Node&gt;list=newArrayList&lt;&gt;();for(Noden:graph.nodes.values()){map.put(n,n.in);if(n.in==0){queue.add(n);}}while(!queue.isEmpty()){Nodecur=queue.pop();list.add(cur);for(Noden:cur.nexts){map.put(n,map.get(n)-1);if(map.get(n)==0){queue.add(n);}}}returnlist;}4.Prim算法publicstaticclassEdgeComparatorimplementsComparator&lt;Edge&gt;{publicintcompare(Edgeo1,Edgeo2){//自定义比较器://o1-o2&lt;0:o1--&gt;o2//o2-o1&lt;0:o2--&gt;o1returno1.weight-o2.weight;}}publicstaticSet&lt;Edge&gt;prim(Graphgraph){PriorityQueue&lt;Edge&gt;queue=newPriorityQueue&lt;&gt;();HashSet&lt;Node&gt;set=newHashSet&lt;Node&gt;();HashSet&lt;Edge&gt;res=newHashSet&lt;Edge&gt;();for(Nodenode:graph.nodes.values()){if(!set.contains(node)){set.add(node);for(Edgeedge:node.edges){queue.add(edge);}while(!queue.isEmpty()){Edgeedge=queue.poll();if(!set.contains(edge.to)){res.add(edge);set.add(edge.to);for(Edgee:edge.to.edges){queue.add(e);}}}}}returnres;}5.Dijkstra算法publicstaticHashMap&lt;Node,Integer&gt;dijkstra(Nodehead){//distanceMap:存储出发点至其他各点的距离HashMap&lt;Node,Integer&gt;distanceMap=newHashMap&lt;&gt;();//lockedSet:用于记录已锁定的点HashSet&lt;Node&gt;lockedSet=newHashSet&lt;&gt;();distanceMap.put(head,0);//unlockedMinNode:找出distanceMap中距离最小且未锁定的点NodeminNode=unlockedMinNode(distanceMap,lockedSet);while(minNode!=null){intdis=distanceMap.get(minNode);for(Edgeedge:minNode.edges){if(!distanceMap.containsKey(edge.to)){distanceMap.put(edge.to,dis+edge.weight);}//若distanceMap中已存在，则比较原距离和新发现的边所更新的距离distanceMap.put(edge.to,Math.min(distanceMap.get(edge.to),dis+edge.weight));}lockedSet.add(minNode);minNode=unlockedMinNode(distanceMap,lockedSet);}returndistanceMap;}publicstaticNodeunlockedMinNode(HashMap&lt;Node,Integer&gt;disMap,HashSet&lt;Node&gt;lockedSet){NodeminNode=null;intminDis=Integer.MAX_VALUE;for(Map.Entry&lt;Node,Integer&gt;entry:disMap.entrySet()){Noden=entry.getKey();intdis=entry.getValue();if(!lockedSet.contains(n)&amp;&amp;dis&lt;minDis){minNode=n;minDis=dis;}}returnminNode;}","link":"https://stevenXu1992.github.io/post/tu-de-jing-dian-suan-fa/"},{"title":"链表的常见算法","content":"1.反转链表//单向链表的反转publicstaticclassNode{intvalue;Nodenext;publicNode(intdata){this.value=data;}}publicstaticNodereverse(Nodehead){Nodepre=null;Nodenext=null;while(head!=null){next=head.next;head.next=pre;pre=head;head=next;}returnpre;}//双向链表的反转publicstaticclassDoubleNode{intvalue;DoubleNodenext;DoubleNodelast;publicDouble(intdata){this.value=data;}}publicstaticNodereverse(DoubleNodehead){DoubleNodepre=null;DoubleNodenext=null;while(head!=null){next=head.next;head.next=pre;head.last=next;pre=head;head=next;}returnpre;}2.判断是否为回文结构publicstaticbooleanpalindrome1(Nodehead){Stack&lt;Node&gt;stack=newStack&lt;Node&gt;();Nodecur=head;while(cur!=null){stack.push(cur);cur=cur.next;}while(!stack.isEmpty()){Noden=stack.pop();if(head.value!=n.value){returnfalse;}head=head.next;}returntrue;}publicstaticbooleanpalindrome2(Nodehead){Nodeslow=head.next;Nodefast=head;while(slow.next!=null&amp;&amp;fast.next.next!=null){slow=slow.next;fast=fast.next.next;}Stack&lt;Node&gt;stack=newStack&lt;Node&gt;();while(slow!=null){stack.push(slow);slow=slow.next;}while(!stack.isEmpty()){Noden=stack.pop();if(n.value!=head.value){returnfalse;}head=head.next;}returntrue;}publicstaticbooleanpalindrome3(Nodehead){Nodeslow=head;Nodefast=head;while(slow.next!=null&amp;&amp;fast.next.next!=null){slow=slow.next;fast=fast.next.next;}//此时slow停在中点，复用fast指针反转链表fast=slow.next;slow.next=null;Nodenext=null;while(fast!=null){next=fast.next;fast.next=slow;slow=fast;fast=next;}//反转完成，此时slow在尾部,fast为null，开始判断Nodeend=slow;//记录尾部节点，复原使用booleanres=true;while(head!=null&amp;&amp;slow!=null){if(head.value!=slow.value){res=false;}head=head.next;slow=slow.next;}//复原链表,复用fast指针fast=end.next;end.next=null;while(fast!=null){next=fast.next;fast.next=end;end=fast;fast=next;}returnres;}3.链表的荷兰国旗问题publicstaticNodeflag(Nodehead,intpivot){NodesHead=null;NodesTail=null;NodeeHead=null;NodeeTail=null;NodebHead=null;NodebTail=null;while(head!=null){if(head.value&lt;pivot){if(sHead==null){sHead=head;sTail=head;}else{sTail.next=head;sTail=head;}}elseif(head.value&gt;pivot){if(bHead==null){bHead=head;bTail=head;}else{bTail.next=head;bTail=head;}}else{if(eHead==null){eHead=head;eTail=head;}else{eTail.next=head;eTail=head;}}head=head.next;}if(sTail!=null){sTail.next=eHead;eTail=eTail==null?sTail:eTail;}if(eTail!=null){eTail.next=bHead;}returnsHead!=null?sHead:eHead!=null?eHead:bHead;}4.带随机指针的链表复制publicstaticNodecopy1(Nodehead){HashMap&lt;Node,Node&gt;map=newHashMap&lt;&gt;();Nodecur=head;while(cur!=null){map.put(cur,newNode(cur.value));cur=cur.next;}cur=head;while(cur!=null){map.get(cur).next=map.get(cur.next);map.get(cur).random=map.get(cur.random);cur=cur.next;}returnmap.get(head);}publicstaticNodecopy2(Nodehead){//先按照next指针在原链表中每个节点后面复制对应节点Nodecur=head;Nodenext=null;while(cur!=null){next=cur.next;cur.next=newNode(cur.value);cur.next.next=next;cur=next;}//复制原链表的random指针cur=head;Nodecopy=null;while(cur!=null){next=cur.next.next;copy=cur.next;copy.random=cur.random!=?cur.random.next:null;cur=next;}//将原链表与复制好的链表分离Noderes=head.next;cur=head;while(cur!=null){next=cur.next.next;copy=cur.next;cur.next=next;copy.next=next!=null?next.next:null;cur=next;}returnres;}5.链表相交相关问题判断两个链表是否相交，若相交返回相交节点publicstaticNodeintersection(Nodehead1,Nodehead2){if(head1==null||head2==null){returnnull;}Nodeloop1=getLoop(head1);Nodeloop2=getLoop(head2);//1.若两个链表都无环if(loop1==null&amp;&amp;loop2==null){returnnoLoop(head1,head2);}//2.若一个有环，一个无环，必定不相交//3.若两个链表都有环if(loop1!=null&amp;&amp;loop2!=null){returnbothLoop(head1,loop1,head2,loop2);}returnnull;}//判断一个链表是否有环并返回入环节点publicstaticNodegetLoop(Nodehead){if(head==null||head.next==null||head.next.next==null){returnnull;}Nodeslow=head.next;Nodefast=head.next.next;while(slow!=fast){slow=slow.next;fast=fast.next.next;}fast=head;while(slow!=fast){slow=slow.next;fast=fast.next;}returnfast;}//都无环publicstaticNodenoLoop(Nodehead1,Nodehead2){Nodecur1=head1;Nodecur2=head2;intlength=0;//分别找出两个链表的尾部,length用于求长度的差值while(cur1.next!=null){length++;cur1=cur1.next;}while(cur2.next!=null){length--;cur2=cur2.next;}//只有尾节点相同才会相交if(cur1==cur2){cur1=length&gt;0?head1:head2;//cur1指向更长链表的头部cur2=cur1==head1?head2:head1;length=Math.abs(length);while(length!=0){length--;cur1=cur1.next;}while(cur1!=cur2){cur1=cur1.next;cur2=cur2.next;}returncur1;}else{returnnull;}}//都有环publicstaticNodebothLoop(Nodehead1,Nodeloop1,Nodehead2,Nodeloop2){Nodecur1=null;Nodecur2=null;//若入环节点相同，则类似于无环相交的情况if(loop1==loop2){cur1=head1;cur2=head2;intlength=0;while(cur1!=loop1){length++;cur1=cur1.next;}while(cur2!=loop2){length--;cur2=cur.next;}cur1=length&gt;0?head1:head2;cur2=cur1==head1?head2:head1;length=Math.abs(length);while(length!=0){length--;cur1=cur1.next;}while(cur1!=cur2){cur1=cur1.next;cur2=cur2.next;}returncur1;}else{cur1=loop1.next;while(cur1!=loop1){if(cur1==loop2){returnloop1;}cur1=cur1.next;}returnnull;}}","link":"https://stevenXu1992.github.io/post/lian-biao-chang-jian-ti-mu/"},{"title":"排序算法","content":"1.冒泡排序publicstaticvoidbubbleSort(int[]arr){if(arr.length&lt;2||arr==null){return;}//大数冒泡for(inti=arr.length-1;i&gt;0;i--){for(intj=0;j&lt;i;j++){if(arr[j]&gt;arr[j+1]){swap(arr,j,j+1);}}}//小数冒泡for(inti=0;i&lt;arr.length-1;i++){for(intj=length-1;j&gt;i;j--){if(arr[j]&lt;arr[j-1]){swap(arr,j,j-1);}}}}publicstaticvoidswap(int[]arr,inta,intb){inttemp=arr[a];arr[a]=arr[b];arr[b]=temp;}2.插入排序publicstaticvoidinsertSort(int[]arr){if(arr==null||arr.length&lt;2){return;}for(inti=1;i&lt;arr.length;i++){for(intj=i-1;j&gt;=0&amp;&amp;arr[j]&gt;arr[j+1];j--){swap(arr,j,j+1);}}}3.选择排序publicstaticvoidselectSort(int[]arr){if(arr==null||arr.length&lt;2){return;}for(inti=0;i&lt;arr.length;i++){intminIndex=i;for(intj=i+1;j&lt;arr.length;j++){minIndex=arr[j]&lt;arr[minIndex]?j:minIndex;}swap(arr,minIndex,i);}}4.归并排序publicstaticvoidmergeSort(int[]arr){if(arr==null||arr.length&lt;2){return;}process(arr,0,arr.length-1);}publicstaticvoidprocess(int[]arr,intleft,intright){if(left==right){return;}intmid=(left+right)/2;process(arr,left,mid);process(arr,mid+1,right);merge(arr,left,mid,right);}publicstaticvoidmerge(int[]arr,intleft,intmid,intright){int[]help=newint[right-left+1];intp1=left;intp2=mid+1;inti=0;while(p1&lt;=mid&amp;&amp;p2&lt;=right){help[i++]=arr[p1]&lt;arr[p2]?arr[p1++]:arr[p2++];}while(p1&lt;=mid){help[i++]=arr[p1++];}while(p2&lt;=right){help[i++]=arr[p2++];}for(intj=0;j&lt;help.length;j++){arr[left+j]=help[j];}}5.随机快排publicstaticvoidquickSort(int[]arr){if(arr==null||arr.length&lt;2){return;}process(arr,0,arr.length-1);}publicstaticvoidprocess(int[]arr,intleft,intright){if(left&lt;right){swap(arr,right,left+(int)(Math.random()*(right-left+1)));int[]p=partition(arr,left,right);process(arr,left,p[0]-1);process(arr,p[1]+1,right);}}publicstaticint[]partition(int[]arr,intleft,intright){intlessZone=left-1;intmoreZone=right;while(left&lt;moreZone){if(arr[left]&gt;arr[right]){swap(arr,left,--moreZone);}if(arr[left]&lt;arr[right]){swap(arr,left++,++lessZone);}else{left++;}}swap(arr,right,moreZone);returnnewint[]{lessZone+1,moreZone};}6.堆排序用数组的方式表示完全二叉树，对于任意节点i：左子节点:2i+1,右子节点:2i+2,父节点:（i-1）/2publicstaticvoidheapSort(int[]arr){if(arr==null||arr.length&lt;2){return;}for(inti=0;i&lt;arr.length;i++){heapInsert(arr,i);}intsize=arr.length;swap(arr,0,--size);while(size&gt;0){heapify(arr,0,size);swap(arr,0,--size);}}publicstaticvoidheapInsert(int[]arr,intindex){while(arr[index]&gt;arr[(index-1)/2]){swap(arr,index,(index-1)/2);index=(index-1)/2;}}publicstaticvoidheapify(int[]arr,intindex,intsize){intleft=2*index+1;while(left&lt;size){intmax=left+1&lt;size&amp;&amp;arr[left+1]&gt;arr[left]?left+1:left;max=arr[max]&gt;arr[index]?max:index;if(max==index){break;}swap(arr,index,max);index=max;left=2*index+1;}}7.桶排序基数排序计数排序8.总结时间复杂度空间复杂度是否稳定选择排序O(N^2)O(1)否冒泡排序O(N^2)O(1)是插入排序O(N^2)O(1)是归并排序O(N*logN)O(N)是随机快排O(N*logN)O(logN)否堆排序O(N*logN)O(1)否桶排序O(N)O(M)是","link":"https://stevenXu1992.github.io/post/pai-xu-suan-fa/"},{"title":"二叉树的常见算法","content":"1.判断是否为完全二叉树判断标准：宽度优先遍历时1）若某节点有右节点无左节点，则不为完全二叉树2）某节点左右节点不全，后续都必须为叶节点，否则不是完全二叉树(用一个布尔值记录状态)publicstaticbooleanheapTree(Nodehead){if(head==null){returntrue;}LinkedList&lt;Node&gt;()queue=newLinkedList&lt;&gt;();queue.add(head);booleanleaf=false;Noderight=null;Nodeleft=null;while(!queue.isEmpty()){head=queue.poll();right=head.right;left=head.left;if((right!=null&amp;&amp;left==null)//条件1||(leaf&amp;&amp;(right!=null||left!=null))){//条件2returnfalse;}if(right!=null){queue.add(right);}if(left!=null){queue.add(left);}if(right==null||left==null){leaf=true;//左右子树有一个为空，开启叶节点的记录状态}}returntrue;}2.查找两个节点的最低公共祖先节点设两个节点为n1,n2，递归函数中：若头节点为n1或n2,返回自己（为空则返回空）递归黑盒求出左右子树的返回值若左右子树返回值都不为空，返回自己（已找到公共祖先）左右子树一个为空一个不为空，返回不为空的一项publicstaticNodeprocess(Nodehead,Noden1,Noden2){if(head==null||head==n1||head==n2){returnhead;}Nodeleft=process(head.left,n1,n2);Noderight=process(head.right,n1,n2);if(left!=null&amp;&amp;right!=null){returnhead;}returnleft==null?right:left;}3.查找某节点的后继节点后继节点：某节点在中序遍历中的下一个节点publicstaticNodefind(Nodenode){if(node==null){returnnode;}if(node.right!=null){//有右树returnprocess(node.right);//则中继为右树上最左的节点}else{//无右树Nodeparent=node.parent;//若node=parent.left,则直接返回parent//否则继续向上寻找，直到node=parent.node//最后，若一直未找到则返回null(最右节点的中继为null)while(parent!=null&amp;&amp;node!=parent.left){node=parent;parent=node.parent;}returnparent;}}publicstaticNodeprocess(Nodenode){if(node==null){returnnode;}while(node.left!=null){node=node.left;}returnnode;}4.序列化与反序列化//'#'表示null,'_'用于分隔publicstaticStringserial(Nodenode){if(node==null){return'#_';}Stringres=node.data+'_';//按照先序遍历的顺序将树序列化成字符串res+=serial(node.left);res+=serial(node.right);returnres;}publicstaticNoderecon(Stringstr){String[]arr=str.split('_');Queue&lt;String&gt;queue=newLinkedList&lt;String&gt;();for(inti=0;i!=arr.length;i++){queue.offer(arr[i]);}returnreconProcess(queue);}publicstaticNodereconProcess(Queue&lt;String&gt;queue){Stringstr=queue.poll();if(str.equals('#')){returnnull;}Nodehead=newNode(Integer.valueOf(str));head.left=reconProcess(queue);head.right=reconProcess(queue);returnhead;}","link":"https://stevenXu1992.github.io/post/er-cha-shu-chang-jian-ti-mu/"},{"title":"二叉树的递归框架","content":"1.判断一棵树是否为满二叉树满二叉树条件：总节点个数=2^高度-1定义一个信息类，用于获取需要的信息（此处为节点数和高度）递归函数中先使用黑盒，再补充黑盒中获取信息的操作（此处为假定通过黑盒已获取到了当前节点的左右子树的高度和节点个数，使用该信息得出当前节点处的高度和节点个数）在主函数中判断是否满足条件//定义信息类publicstaticclassInfo{publicintsize;publicintheight;publicInfo(ints,inth){this.size=s;this.height=h;}}//递归函数publicstaticInfoprocess(Nodehead){if(head==null){returnnewInfo(0,0);}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intsize=leftInfo.size+rightInfo.size+1;intheight=Math.max(leftInfo.height,rightInfo.height)+1;returnnewInfo(size,height);}//主函数publicstaticbooleanisFullTree(Nodehead){Infoinfo=process(head);returninfo.size==(1&lt;&lt;height)-1;//左移1位=2^height}2.判断一棵树是否为平衡二叉树平衡二叉树条件：左右子树高度差不超过1且所有子树都平衡信息类：高度，子树是否平衡publicstaticclassInfo{publicintheight;publicbooleanbalance;publicInfo(inth,booleanb){this.height=h;this.balance=b;}}publicstaticInfoprocess(Nodehead){if(head==null){returnnewInfo(0,true);}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intheight=Math.max(leftInfo.height,rightInfo.height)+1;booleanbalance=leftInfo.balance&amp;&amp;rightInfo.balance&amp;&amp;Math.abs(leftInfo.height-rightInfo.height)&lt;2;returnnewInfo(height,balance);}3.求二叉树两节点间的最大距离信息类：高度，最大距离最大距离出现的三种情况：左树上，右树上，横跨头节点publicstaticclassInfo{publicintheight;publicintdistance;publicInfo(inth,intd){this.height=h;this.distance=d;}}publicstaticInfoprocess(Nodehead){if(head=null){returnnewInfo(0,0);}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intheight=Math.max(leftInfo.height,rightInfo.height)+1;intdistance=Math.max(leftInfo.height+rightInfo.height+1,Math.max(leftInfo.distance,rightInfo.distance));returnnewInfo(height,distance);}4.判断一棵树是否为搜索二叉树搜索二叉树的条件：1）左树是搜索二叉树，2）右树是搜索二叉树，3）左树的最大值小于头节点，4）右树的最小值大于头节点信息类：是否为搜索二叉树，最大值，最小值publicstaticclassInfo{publicbooleansearchTree;publicintmax;publicintmin;publicInfo(booleans,intmax,intmin){this.searchTree=s;this.max=max;this.min=min;}}publicstaticInfoprocess(Nodehead){if(head==null){returnnull;}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intmax=head.data;intmin=head.data;if(leftInfo!=null){max=Math.max(max,leftInfo.max);min=Math.min(min,leftInfo.min);}if(rightInfo!=null){max=Math.max(max,rightInfo.max);min=Math.min(min,rightInfo.min);}booleansearchTree=false;//三目的意义：若左树不为空，按1）左树是搜索树2）左树最大值小于节点值进行判断；若左树为空，则直接为true不用判断。右树同理。if((leftInfo!=null?(leftInfo.searchTree&amp;&amp;leftInfo.max&lt;head.data):true)&amp;&amp;(rightInfo!=null?(rightInfo.searchTree&amp;&amp;rightInfo.min&gt;head.data):true)){searchTree=true;}returnnewInfo(searchTree,max,min);}中序遍历方法publicstaticbooleansearchTree(Nodehead){if(head==null){returntrue;}Stack&lt;Node&gt;stack=newStack&lt;&gt;();Nodecur=head;intpre=Integer.MIN_VALUE;while(!stack.isEmpty()||cur!=null){if(cur!=null){stack.push(cur);cur=cur.left;}else{cur=stack.pop();if(cur.data&lt;=pre){returnfalse;}pre=cur.data;cur=cur.right;}}returntrue;}","link":"https://stevenXu1992.github.io/post/er-cha-shu-de-di-gui-kuang-jia/"},{"title":"二叉树的遍历","content":"1.递归遍历publicstaticclassNode{publicintvalue;publicNodeleft;publicNoderight;publicNode(intdata){this.value=data;}}publicstaticvoidf(Nodehead){if(head==null){return;}//先序遍历操作f(head.left);//中序遍历操作f(head.right);//后序遍历操作}二叉树递归遍历的本质：通过树的完整递归序加工而成完整递归序：1-&gt;2-&gt;2-&gt;2-&gt;1-&gt;3-&gt;3-&gt;3-&gt;1先序：第一次来到节点时进行操作1-&gt;2-&gt;3中序：第二次来到节点时进行操作2-&gt;1-&gt;3后序：第三次来到节点时进行操作2-&gt;3-&gt;12.非递归遍历2.1先序遍历遍历顺序：中--&gt;左--&gt;右，1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6-&gt;7建立栈结构，压入头节点从栈中弹出当前节点，并执行遍历操作先压入弹出节点的右子节点，再压左子节点，重复步骤2直到栈为空publicstaticvoidpreUnRecur(Nodehead){if(head!=null){Stack&lt;Node&gt;stack=newStack&lt;&gt;();stack.add(head);while(!stack.isEmpty()){head=stack.pop();//该处执行遍历操作if(head.right!=null){stack.push(head.right);}if(head.left!=null){stack.push(head.left);}}}}2.2中序遍历遍历顺序：左--&gt;中--&gt;右，4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7建立栈结构，压入头节点不断将当前节点的左子节点压栈，直到某节点的左子节点为空，此时从栈中弹出该节点并执行遍历操作若弹出节点的右子节点不为空，重复步骤2；若为空，则继续从栈中弹出下一节点直到栈为空publicvoidinUnRecur(Nodehead){if(head!=null){Stack&lt;Node&gt;stack=newStack&lt;&gt;();Nodecur=head;while(!stack.isEmpty()||cur!=null){if(cur!=null){stack.push(cur);cur=cur.left;}else{cur=stack.pop();//此处执行遍历操作cur=cur.right;}}}}2.3后序遍历遍历顺序：左--&gt;右--&gt;中，4-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1类似于先序遍历，按照先左后右的顺序压栈。额外准备一个栈，将弹出节点压入，直到1号栈为空时，将节点依次从2号栈弹出并执行遍历操作。publicstaticvoidpostUnRecur(Nodehead){if(head!=null){Stack&lt;Node&gt;s1=newStack&lt;&gt;();Stack&lt;Node&gt;s2=newStack&lt;&gt;();s1.push(head);while(!s1.isEmpty()){head=s1.pop();s2.push(head);if(head.left!=null){s1.push(head.left);}if(head.right!=null){s1.push(head.right);}}while(!s2.isEmpty()){head=s2.pop();//此处执行遍历操作}}}3.宽度优先遍历使用哈希表记录每个节点所在层数，使用队列进行宽度优先遍历每个节点都进入队列，其左右子节点层数+1进入哈希表从队列弹出时，比较该节点所在层数是否大于当前层数，若大于（说明已到了下一层），则将当前层宽度清零并更新当前层数；若不大于（说明还在同一层），则当前层宽度+1。每次对一个节点操作完成后都比较并更新最大宽度与当前层宽度的最大值。publicstaticintgetMaxWidth(Nodehead){if(head==null){return0;}intmaxWidth=0;intcurWidth=0;intcurLevel=0;HashMap&lt;Node,Integer&gt;levelMap=newHashMap&lt;&gt;();LinkedList&lt;Node&gt;queue=newLinkedList&lt;&gt;();levelMap.put(head,1);queue.add(head);Nodecur=null;Nodeleft=null;Noderight=null;while(!queue.isEmpty()){cur=queue.poll();left=cur.left;right=cur.right;if(left!=null){levelMap.put(left,levelMap.get(cur)+1);queue.add(left);}if(right!=null){levelMap.put(right,levelMap.get(cur)+1);queue.add(right);}if(levelMap.get(cur)&gt;curLevel){curWidth=0;curLevel=levelMap.get(cur);}else{curWidth++;}maxWidth=Math.max(curWidth,maxWidth);}returnmaxWidth;}","link":"https://stevenXu1992.github.io/post/er-cha-shu-de-bian-li/"},{"title":"Hello Gridea","content":"👏欢迎使用Gridea！✍️Gridea一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意......GithubGridea主页示例网站特性👇📝你可以使用最酷的Markdown语法，进行快速创作🌉你可以给文章配上精美的封面图和在文章任意位置插入图片🏷️你可以对文章进行标签分组📋你可以自定义菜单，甚至可以创建外部链接菜单💻你可以在Windows，MacOS或Linux设备上使用此客户端🌎你可以使用𝖦𝗂𝗍𝗁𝗎𝖻𝖯𝖺𝗀𝖾𝗌或CodingPages向世界展示，未来将支持更多平台💬你可以进行简单的配置，接入Gitalk或DisqusJS评论系统🇬🇧你可以使用中文简体或英语🌁你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力🖥你可以自定义源文件夹，利用OneDrive、百度网盘、iCloud、Dropbox等进行多设备同步🌱当然Gridea还很年轻，有很多不足，但请相信，它会不停向前🏃未来，它一定会成为你离不开的伙伴尽情发挥你的才华吧！😘Enjoy~","link":"https://stevenXu1992.github.io/post/hello-gridea/"}]}