{"posts":[{"title":"与Nina的第192天 - snowy night","content":"SnowyNightAmountainhikeAlakesad​Standingonthebalconywewatchedfireworks​ThelightsofhotelarenolongerdazzlingatnightThewindscryThesnowsflyTheyblowingawaythesnowflakesunderstreetlightsFlyingoverthetreetopslikeflowerspassingbyYouareinnorthIaminsouthWhyshouldthenightbesodarkandlong?Sittingupandcounthowmanycoldstarsinthesky​​--2022.3.13","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-192-tian-snowy-night/"},{"title":"与Nina的第189天 - 惊喜","content":"本来没想着庆祝生日，也没有这个习惯，这一点我们还真是一样呢。​如果可以的话，这一天真的想和Nina在一起，不用特殊的庆祝，不需要做特别的事情，只是静静地在一起，说一说无聊的废话，摸摸你的脸颊，抚摸你的长发，暖暖地抱一抱你，我就会感觉很幸福。​虽然这样想着，可是我们相隔千里，所以我今天早早地结束了工作，想在生日这天，可以好好地，不受打扰地跟你打电话聊聊天。唉，可惜运气也不好，从今天你就要开始新工作的培训了...也没有关系，你在想着我，而我在想着你，也就足够了吧。​没想到，上午收快递的时候，真的被惊喜到了！​这个惊喜你肯定也计划了很久吧？​真的被感动到了，在这不平静的日子里，你身处莫斯科，每天都会面对更多的压力，但就是在这种情况下，你仍然想着我的生日，还筹划着给我惊喜，让我感受到了来自你真真切切的温暖。​谢谢你，Nina，今天是我最开心的一天。​还记得我在你生日时写的那首诗吗？​风吹起了一本书的书页，翻到了那写着我们故事的那一页，故事里的少年燃烧似火，公主温柔似水。风不只吹起了纸张，也吹起了我们之间的爱与喜欢，书页之中似乎有着浓浓的爱意随风迎面扑来，而故事的扉页上写着：​Longdistanceforourlongstories...​--2022.3.10","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-189-tian-liang-xi/"},{"title":"与Nina的第183天 - 我想你了","content":"---Kissyou))---loveyou^^---YeahIkissyou))---YeahIstillloveyou^^​--2022.3.4","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-183-tian-wo-xiang-ni-liao/"},{"title":"与Nina的第154天 - 我爱你","content":"终于说出了那三个字，在你走之前​--2022.2.3","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-154-tian-wo-ai-ni/"},{"title":"与Nina的第152天 - 公园","content":"难得的冬日暖阳，公园里人迹罕至，只有你，我，Jessi。​就算冬日的晴天，也不及你的温柔，你和Jessi一起奔跑的样子，让世间美好的一切，都体现在你身上了。​喜欢你歪着头喝热巧克力的样子，让人想起去年10月份我们在同一个公园散步时的情景，时间过得真快啊，短短的几个月发生了这么多事情，我们还是甜蜜的走在一起。​--2022.2.1","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-152-tian-gong-yuan/"},{"title":"与Nina的第148天 - 胸透","content":"终于陪Nina做完了胸透，一切正常，担心了好久的问题终于解决了！！​从来没吃这么好吃的Khikali！！！​开心！！！！​o！！！​--2022.1.28","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-148-tian-xiong-tou/"},{"title":"与Nina的第144天 - 心疼","content":"希望Nina快点好起来，千万别又得新冠了。。。​你裹着大衣下楼梯的样子，让人心疼。。​请把Nina的疼痛都给我吧，让我去代替她承受这些。。​--2022.1.24","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-144-tian-xin-teng/"},{"title":"与Nina的第129天 - 纹身","content":"今天终于陪你做了你一直念叨的纹身，下车的时候，看到了你头发里的几缕白发，突然一股酸楚涌上心头，亲爱的，请你不要担心那么多事情，我会永远陪着你，扛起所有的事情，我知道你的自尊不允许我这么做，我也只能写在这里，Nina，我真的好爱好爱你，不想你受一点委屈，看到你的白发我的心都快要碎了，请不要把所有东西都放在自己的肩上，这个世界上至少还有我永远陪你分担，陪你一直走下去。。。​--2022.1.9","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-129-tian-wen-shen/"},{"title":"与Nina的第128天 - Be Strong","content":"似乎正如你所说，我们之间很多重要的事情都发生在Raddison，那些重要的记忆总是发生在吃完寿司之后。​今晚感到了前所未有的释然，我会永远记住你的那句ifyoucouldnotbestrongenough,howcouldiknowthaticanrelyonyou。​从开始到现在，我小心翼翼了太长时间，喜欢你早已成为了一种习惯，想要保护你，照顾你的感觉又是那么的自然，总是想对你好，同时又害怕给你压力，你说过你会经常一点小事就想很多，那要怎么才能找到那个平衡点，既要对你好，又不让你感到压力，也许就是把对你的爱一直藏起来，不让你知道吧？​--2022.1.8","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-128-tian-be-strong/"},{"title":"与Nina的第126天 - 疯狂","content":"幸福来得如此突然，早上给你建议了紫色的衣服，之后就没音儿了。正在房子里躺着没事干时，你突然发来5个表情，之后响起的敲门声好像预示着什么事情要发生。​哈利波特纪录片的内容已经想不起来了，只记得这疯狂的一晚，疯狂的我们。​--2022.1.6","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-126-tian-feng-kuang/"},{"title":"与Nina的第120天 - 跨年","content":"2022年的新年有些特别，未曾想到竟然可以和自己心爱的女孩一起跨年，看着外面的烟花绚丽的绽放，拥抱在阳台上的我们一切都显得那么自然。​--2021.12.31","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-120-tian-kua-nian/"},{"title":"与Nina的第111天 - 太阳雪","content":"早上起来，外面下起了太阳雪，美不胜收。从小到达，走过很多地方，见过很多美景，如果一定要有一个排名的话：top5:青岛的海top4:Kazbegi的山top3:Vazsubani的夜景top2:故乡的太阳雪top1:Nina的笑容​--2021.12.22","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-111-tian-tai-yang-xue/"},{"title":"与Nina的第100天 - 一百天纪念","content":"没想到会收到这份礼物，本来以为你不看重这些纪念日。谢谢你，亲爱的Me&amp;You，First100，200，365，500，800，。。。。。。。。。​--2021.12.11","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-100-tian-yi-bai-tian-ji-nian/"},{"title":"与Nina的第80天 - 开心！","content":"今天Nina又重新跟我说话啦！！好开心！！！世界终于又有了色彩！！一定好好对你，再也不让你失望！！！​--2021.11.21","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-80-tian-kai-xin/"},{"title":"与Nina的第78天 - 对不起","content":"一星期不到，又惹你生气了。。。我真是个傻逼真的只是想让你多陪陪我，又不知道该如何说，害怕给你太多的压力，喝酒之后控制不住自己的思绪，说了赌气的话，可能你真的对我失望透顶了吧。。这几天一直感觉活得像僵尸一样，例行公事般地吃饭，上班，胸口的悲伤一直卡在这里出不去，想哭又觉得丢人。。。真的很对不起，我最亲爱的Nina，请你原谅我好吗​--2021.11.19","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-78-tian-dui-bu-qi/"},{"title":"与你一起的第73天 - 教堂","content":"好羡慕教堂里的那对情侣，如果有一天我也能拉着你的手站在那里，说出我爱你的话语，那该有多幸福啊。。。呵，终究只是个无法实现的梦想。做了一整晚的梦，梦里都是你，大多是悲伤的无能无力的梦。早上起来，担心你的胃不舒服是否好些了，又不知该怎么开口，你是不是还在生我的气？想起小时候胃疼的时候，妈妈都会拿个热水袋给我暖暖，一会就会好很多。嗯，要给你买一个！跑了很多地方，终于买到了！可是不知道为什么，你听到我给你买热水袋的时候，变得温怒了起来，我感觉好沮丧，我又哪里做错了。在街上面对你的时候，不知道该说什么，也不知道该做些什么，真的只是想对你好一些，希望你能健健康康，快快乐乐地，可我又不知道该怎么去做，好难受。进到教堂里，看到正在进行的婚礼，忽然心里酸酸的，你从来不让我说我爱你，不让我把事情弄得更远，可你知道吗？我真的很爱很爱你。。。​--2021.11.14","link":"https://stevenXu1992.github.io/post/yu-ni-yi-qi-de-di-73-tian-jiao-tang/"},{"title":"与你一起的第72天 - 冲动","content":"今天惹你生气了。前一天还说要对你好，结果第二天就在商场发了脾气，我傻逼了。想起来你一路上给我说你看了我推荐的电影，想起来你在商场帮我选衣服时走来走去时的样子，想起来你帮我折起裤腿的温柔，我竟然冲动到对你发脾气，我真想扇自己一巴掌。。。我最害怕的事情？也许就是从你眼中看到失望吧。一直最讨厌粗鲁和乱发脾气的人，那一瞬间在你眼中我也变成这样的人了吧，这时语言的解释是如此地苍白无力唉。。。说也说不清了，我真的不是那种人。。。慢慢来吧，好好对你，用行动证明吧难受死了。。。​--2021.11.13","link":"https://stevenXu1992.github.io/post/yu-ni-yi-qi-de-di-72-tian-chong-dong/"},{"title":"与Nina的第68天 - 耐人寻味","content":"突然好想你，你现在在干什么，不想打扰你又很担心你。不知道为什么你在电话里的声音有些悲伤，是不是有谁惹你不开心了，还是你又在担心着什么，你总是什么也不给我说，老是自己一个人不开心，我该怎么做。。。​--2021.11.9","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-68-tian-nai-ren-xun-wei/"},{"title":"与Nina的第67天 - 谎言","content":"今天撒了个小谎，骗了nina，心里很不好受。以后永远不再对Nina撒谎。​--2021.11.8","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-67-tian-huang-yan/"},{"title":"与Nina的第66天 - 花冠","content":"只言春色能娇物不道秋霜解媚人​喜欢秋天的味道，冷冷的风中透着一丝温暖的阳光，你捋了捋头发，侧着头看我的样子让我感觉像喝了一整瓶的chacha。​有些遗憾，没找到日本景观区。​想起以前中国的电视台记者，总是喜欢在过年的时候采访路人，问大家什么是幸福，大家都是哭笑不得地不知道怎么回答。以前我也不知道什么是幸福，直到今天，我会回答：幸福就是我在地上捡着枫叶，交给我喜欢的姑娘，她倚靠在树下低头细细编织着花冠。当她戴上花冠时，一道夕阳照到她的脸上，照到那顶杂乱的花冠上，彼时她脸上的那份开心的笑容就是幸福。​​--2021.11.7","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-66-tian-hua-guan/"},{"title":"与Nina的第44天 - 阿姆斯特丹","content":"走在阿姆斯特丹的机场里，看着来来往往的游客，又想起了你。​什么时候我们也能一起收拾行囊，去一个陌生的国家旅行，没有工作，没有烦恼，没有bullshit，只有你和我在一起，牵着手，去旅行。。。​买香水时候碰到了一个中国导购，正在犹豫该买50ml还是100ml，想问问一般都能用多久，她竟然一脸傲慢的回答：我不知道你女友是什么情况，反正我有很多香水，我也不知道能用多久。WTF？！真的很火大，这种庸脂俗粉也敢对我的Nina说三道四！​照顾这几个小孩真的累死了，希望一切顺利，早点回去找Nina～​买了一捧郁金香，希望Nina能喜欢(^^)​--2021.10.17","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-44-tian-a-mu-si-te-dan/"},{"title":"与Nina的第40天 - 生日 ","content":"书页被吹起的时候书知道风又耐不住性子了他挑了一个新故事里面有少年和公主少年燃烧似火公主活泼而温柔这个秋天风里带着墨香感谢与你的相遇我最亲爱的Nina祝你生日快乐_​​--2021.10.12","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-40-tian-sheng-ri/"},{"title":"与Nina的第38天 - 第一次 ","content":"纤云弄巧，飞星传恨，银汉迢迢暗度金风玉露一相逢，便胜却人间无数​​我听过最性感的话语，就是有人悄悄地问：whereiscondom？​​--2021.10.10","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-38-tian-di-yi-ci/"},{"title":"与Nina的第32天 - Rustaveli的雨夜 ","content":"东风夜放花千树，更吹落、星如雨宝马雕车香满路凤箫声动，玉壶光转，一夜鱼龙舞​今天的雨比往常更大了一些，Rustaveli深巷里的车中，雨滴打湿了车窗，一层层的雾气把车内和车外分隔成了两个世界，是谁的热情似火，又是谁的激情万丈？​一场雨落，一场邂逅，如天空中的秋雨落在我想你的柔情里，溢满了与你的惊喜与幸福。我愿意将我的心放在帘外的雨中，化作缕缕的牵挂与点点的相思泪，落入你温柔的眸中，伴你走过秋凉的雨季，共你在流年的辗转中迁伴。​--2021.10.4","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-32-tian-rustaveli-de-yu-ye/"},{"title":"与Nina的第24天 - Lisi湖畔 ","content":"抽刀断水，水更流举杯消愁，愁更愁​周日的Lisi湖畔鲜有行人，秋日温暖的阳光照在我们身上，好像夏天的尾巴扫过湖面，一片片黄绿相间的芦苇包围下，我们坐在岸边的石头座椅上，像两只小猫小狗，慵懒地晒着太阳。​如果今天的故事到这里就结束，是不是更美好一些？​喝完chacha后，你开车送我回去，走的时候凶了你，还把你给妈妈带的点心忘到了车上。。。​对不起，我亲爱的Nina。。。​​--2021.9.25","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-24-tian-lisi-hu-pan/"},{"title":"与Nina的第20天 - Kazbegi与Tbilisi ","content":"花自飘零水自流一种相思两处闲愁​出发去Kazbegi前，我们在酒店的停车场短暂地相拥，我紧紧的吻着你的双唇，好似我们要分隔千里之外。你上车的时候，我傻傻的告诉你，你人还没有走，可我已经开始想你了。​Kazbegi一直在下雨，站在Paramount酒店窗前的你，现在在想些什么？​第二天晚上，你突然发来信息，诉说着Kazbegi与Tbilisi两座城市间的雨滴会缩短我们之间的距离，让你感觉到我们在一起；而那些从山顶降落的雾霭是充满记忆与思念的美好的梦境，我看不到你，但你身在其中。​是啊，明明没有很远的距离，为什么我会愈发地想你，思念本身就是一种最大的幸福，特别是我在想着你的时候，你也在想着我。。。​--2021.9.22","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-20-tian-kazbegi-yu-tbilisi/"},{"title":"与Nina的第17天 - 夜桥","content":"你在桥上看风景，看风景的我在旁边看你。​一直想去看看Nina的大学是什么样子，想象10年前你在这里读书，漫步在校园的样子，然后幻想如果时间可以倒流，如果我可以出现在这里，和你上同一所大学，又会发生怎样的故事。​夜晚下的桥有一种静谧的美丽，我们拉着手穿过桥沿，月亮不时被流云挡在了身后，霁月难逢，彩云易散，但愿这种美丽幽静的夜晚可以再多来一些。​IMG_2149.HEIC​--2021.9.19","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-17-tian-ye-qiao/"},{"title":"与Nina的第5天 - Mtatsminda的夜晚","content":"众里寻她千百度蓦然回首那人却在灯火阑珊处​Mtatsminda的盘山路蜿蜿蜒蜒，初秋的晚风在车窗边呼啸而过，你左手端着方向盘，右手握着我的手，一路上诉说着各种有趣的故事。​山顶的石台边上，整个第比利斯的壮阔夜景全部尽收眼底，我们在一片星光中寻找着华凌的灯光。​你趴在石台上眺望城市的侧脸很美。​在公园散步时，你说昨晚做了很可怕的梦，我使劲搂住了你的肩膀，想要为了你跟世界上所有的恶魔战斗到底。​我听过最美的故事，就是少年为了从恶魔手中救下自己最爱的公主，一腔热血可以划破长夜，即使燃烧到一无所有也不妥协。​摩天轮下，我们坐在路边的长椅上，你靠在我的怀里，让九月的夜晚美不胜收。​--2021.9.7","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-5-tian-mtatsminda-de-ye-wan/"},{"title":"与Nina的第2天 - 日落","content":"最美的不是日落时的漫天彩霞，而是与你一同看过的平凡的风景。​想起几天前，你发来开车时拍下的日落视频，可是我却无暇看风景，只顾着担心起你的安全。​不知道从什么时候开始，关心你已经变成一种习惯，上班的你是否也为工作感到烦恼，吃饭的你是否会想起我们一起吃过的美食，开车时的你又在想些什么。​跟你分开的每一分钟都让人煎熬，在一起的时间又太过短暂，总是希望我那断断续续的思绪可以随着第比利斯的夏风飘到你的身边，想起你时的那种绵绵袭来的温柔仿佛可以让时间倒流到每一个和你在一起的瞬间。​--2021.9.4","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-2-tian-ri-luo/"},{"title":"与Nina的第1天 - 槲寄生下的吻","content":"从来没有见过槲寄生只能从依稀记得读过的书中勾勒出它的样子想必是一种能让人莫名其妙产生情愫的神奇植物吧。​昨天用幼稚的格鲁吉亚手写体写下了：我想你了，晚安，你笑着回复说我的字体很漂亮。我不知天高地厚地想要用你的语言写下漂亮的诗篇送给你，可是再漂亮的字，再优雅的诗，也不及你回眸一笑的美丽芳华。​用中文说晚安时，你记成了我喜欢你的意思，满怀忧愁地告诉我不要说一些连自己都不确定的话。对你来说，喜欢一个人是很特殊的一件事吧，我也一样。看到你感到压力的样子总是让我很心疼，想要让你知道我有多么的喜欢你，但是又害怕会带给你压力，让你紧张，也许感情本来就是一件没有办法用语言说清楚的事情吧。​星期五的天空，晴空万里，云彩似乎也知道今天似乎会有不同寻常的事情要发生。开车去市里的路上，我说喜欢下雨，喜欢飘雪，喜欢刮风，你说我知道你喜欢女人。可你是否知道那个女人就是你？​你喂我吃寿司的动作很甜蜜。​送走了你朋友，我们在回来的路上一度互相沉默了，似乎只是平凡的一天，平凡的一顿晚餐，就连月亮也不知道要如何开口。当车停在昏黄的路灯下，我握着你的手，紧张地想着想要如何给你诉说我对你的喜欢，却担心给你压力，扰乱你的情绪，迟迟不敢开口，只能将你紧紧抱在怀里，希望能通过我的心跳传达给你所有的言语。这时，突然，你说：​“我们就保持现在这样吧”​然后，在想象中的槲寄生下，我们深深地吻在了一起。​路灯似乎变得昏暗，月亮悄悄地注视着我们，街上过往的车辆也像是被人按了暂停键，整个世界只剩下你散发着幽香的嘴唇和温柔的拥抱让我在这个遥远的国度感受到了从未有过的温暖。​你在哪里，槲寄生就在哪里，想象中的植物，比真实更真实。​--2021.9.3","link":"https://stevenXu1992.github.io/post/yu-nina-de-di-1-tian-hu-ji-sheng-xia-de-wen/"},{"title":"有序表","content":"1.带有自平衡性的搜索二叉树1.1搜索二叉树的基本模版publicclassAbstractBinarySearchTree{publicNoderoot;protectedintsize;publicstaticclassNode{publicIntegervalue;publicNodeparent;publicNodeleft;publicNoderight;publicNode(Integervalue,Nodeparent,Nodeleft,Noderight){super();this.value=value;this.parent=parent;this.left=left;this.right=right;}publicbooleanisLeaf(){returnleft==null&amp;&amp;right==null;}}//创建新的节点实例protectedNodecreateNode(intvalue,Nodeparent,Nodeleft,Noderight){returnnewNode(value,parent,left,right);}//搜索元素，没找到返回nullpublicNodesearch(intelement){Nodenode=root;while(node!=null&amp;&amp;node.value!=null&amp;&amp;node.value!=element){if(element&lt;node.value)node=node.left;elsenode=node.right;}returnnode;}//添加元素publicNodeinsert(intelement){//如没有根节点，则新建一个树if(root==null){root=createNode(element,null,null,null);size++;returnroot;}//parentNode：新建节点的父节点，tempNode：用于定位新建节点的位置NodeparentNode=null;NodetempNode=root;while(tempNode!=null&amp;&amp;tempNode.value!=null){parentNode=tempNode;if(element&lt;tempNode)tempNode=tempNode.left;elsetempNode=tempNode.right;}//若父节点为叶节点，再判断新建节点放左树还是右树NodenewNode=creatNode(element,parentNode,null,null);if(parent.value&gt;newNode.value)parentNode.left=newNode;elseparentNode.right=newNode;size++;returnnewNode;}//根据节点删除//1.节点无子树-直接删//2.节点有一个子树-该子树直接嫁接上来//3.有两个子树-将右树上的最小值或左树上的最大值successor嫁接上来，而原本successor的子树向上补即可protectedNodedelete(Nodetarget){if(target!=null){NodenodeToReturn=null;if(target!=null){if(target.left==null){nodeToReturn=transplant(target,target.right);}elseif(target.right==null){nodeToReturn=transplant(target,target.left);}else{Nodesuccessor=getMinimum(target.right);if(successor.parent!=target){transplant(successor,successor.right);successor.right=target.right;successor.right.parent=successor;}transplant(target,successor);successor.left=target.left;successor.left.parent=successor;nodeToReturn=successor;}size--;}returnnodeToReturn;}returnnull;//根据元素删除publicNodedelete(intelement){NodedeleteNode=search(element);if(deleteNode!=null)returndelete(deleteNode);elsereturnnull;}//嫁接节点，用节点newNode替换节点replaceNodeprivateNodetransplant(NodereplaceNode,NodenewNode){if(replaceNode.parent==null){this.root=newNode;}elseif(replaceNode==replaceNode.parent.left){replaceNode.parent.left=newNode;}else{replaceNode.parent.right=newNode;}if(newNode!=null){newNode.parent=replaceNode.parent;}returnnewNode;}//获取带有最小值的节点protectedNodegetMinimum(Nodenode){while(node.left!=null){node=node.left;}returnnode;}//获取带有最大值的节点protectedNodegetMaximum(Nodenode){while(node.right!=null){node=node.right;}returnnode;}//是否含有某元素publicbooleancontains(intelement){returnsearch(element)!=null;}//返回后继节点protectedNodegetSuccessor(Nodenode){if(node.right!=null){returngetMinimum(node.right);}else{Nodecurrent=node;Nodeparent=node.parent;while(parent!=null&amp;&amp;current==parent.right){current=parent;parent=parent.parent;}returnparent;}}}1.2带有自平衡功能的搜索二叉树（左旋，右旋）publicabstractclassAbstractSelfBalancingBinarySearchTreeextendsAbstractBinarySearchTree{//左旋：node旋到node.left的位置,node.right到node的位置//node.right.left到node.left.right的位置//node.left和node.right.right不变protectedNoderotateLeft(Nodenode){Nodetemp=node.right;temp.parent=node.parent;node.right=temp.left;if(node.right!=null)node.right.parent=node;temp.left=node;node.parent=temp;//node下方接好后，接上方的节点if(temp.parent!=null){if(node==temp.parent.left)temp.parent.left=temp;elsetemp.parent.right=temp;}elseroot=temp;returntemp;}//右旋同理protectedNoderotateRight(Nodenode){Nodetemp=node.left;temp.parent=node.parent;node.left=temp.right;if(node.left!=null)node.left.parent=node;temp.right=node;node.parent=temp;if(temp.parent!=null){if(node==temp.parent.left)temp.parent.left=temp;elsetemp.parent.right=temp;}elseroot=temp;returntemp;}}2.AVL树/**Incomputerscience,anAVLtreeisaself-balancingbinarysearchtree,anditwasthefirstsuchdatastructuretobeinvented.InanAVLtree,theheightsofthetwochildsubtreesofanynodedifferbyatmostone.Lookup,insertion,anddeletionalltakeO(logn)timeinboththeaverageandworstcases,wherenisthenumberofnodesinthetreepriortotheoperation.Insertionsanddeletionsmayrequirethetreetoberebalancedbyoneormore**/publicclassAVLTreeextendsAbstractSelfBalancingBinarySearchTree{protectedstaticclassAVLNodeextendsNode{publicintheight;publicAVLNode(intvalue,Nodeparent,Nodeleft,Noderight){super(value,parent,left,right);}}//自平衡调整//每次添加或删除节点后，向上检查每个头节点的平衡性privatevoidrebalance(AVLNodenode){while(node!=null){Nodeparent=node.parent;intleftHeight=(node.left==null)?-1:((AVLNode)node.left).height;intrightHeight=(node.right==null)?-1:((AVLNode)node.right).height;intnodeBalance=rightHeight-leftHeight;//-2meansleftsubtreeoutgrow,2meansrightsubtree)if(nodeBalance==2){if(node.right.right!=null){//RR左旋node=(AVLNode)avlRotateLeft(node);break;}else{//RL先右旋再左旋node=(AVLNode)doubleRotateRightLeft(node);break;}}elseif(nodeBalance==-2){if(node.left.left!=null){//LL右旋node=(AVLNode)avlRotateRight(node);break;}else{//LR先左旋再右旋node=(AVLNode)doubleRotateLeftRight(node);break;}}else{updateHeight(node);}node=(AVLNode)parent;}}}3.SB树//sizebalancetree//size(node.left)&gt;//Math.max(size(node.right.left),size(node.right.right))publicstaticclassSBTNode&lt;KextendsComparable&lt;K&gt;,V&gt;{publicKkey;publicVvalue;publicSBTNode&lt;K,V&gt;l;publicSBTNode&lt;K,V&gt;r;publicintsize;publicSBTNode(Kkey,Vvalue){this.key=key;this.value=value;size=1;}}publicstaticclassSizeBalancedTreeMap&lt;KextendsComparable&lt;K&gt;,V&gt;{//sb树的自平衡调整，旋转后递归调整所有子树变化了的节点privateSBTNode&lt;K,V&gt;matain(SBTNode&lt;K,V&gt;cur){if(cur==null){returnnull;}if(cur.l!=null&amp;&amp;cur.l.l!=null&amp;&amp;cur.r!=null&amp;&amp;cur.l.l.size&gt;cur.r.size){//LLcur=rightRotate(cur);cur.r=matain(cur.r);cur=matain(cur);}elseif(cur.l!=null&amp;&amp;cur.l.r!=null&amp;&amp;cur.r!=null&amp;&amp;cur.l.r.size&gt;cur.r.size){//LRcur.l=leftRotate(cur.l);cur=rightRotate(cur);cur.l=matain(cur.l);cur.r=matain(cur.r);cur=matain(cur);}elseif(cur.r!=null&amp;&amp;cur.r.r!=null&amp;&amp;cur.l!=null&amp;&amp;cur.r.r.size&gt;cur.l.size){//RRcur=leftRotate(cur);cur.l=matain(cur.l);cur=matain(cur);}elseif(cur.r!=null&amp;&amp;cur.r.l!=null&amp;&amp;cur.l!=null&amp;&amp;cur.r.l.size&gt;cur.l.size){//RLcur.r=rightRotate(cur.r);cur=leftRotate(cur);cur.l=matain(cur.l);cur.r=matain(cur.r);cur=matain(cur);}returncur;}}4.红黑树红黑树保证平衡性的条件：每个节点的枚举元素必须是红或黑头节点和叶节点为黑（叶节点指树底层的null节点）红节点不相邻任何一个头部节点，到叶节点的路径上，黑节点数量一样5.跳表跳表通过概率的方式为每个元素设定一个高度，每次查找或删除从最高层开始进行，达到加速的目的publicstaticclassSkipListMap&lt;KextendsComparable&lt;K&gt;,V&gt;{publicvoidput(Kkey,Vvalue){if(key==null){return;}SkipListNode&lt;K,V&gt;less=mostRightLessNodeInTree(key);SkipListNode&lt;K,V&gt;find=less.nextNodes.get(0);if(find!=null&amp;&amp;find.isKeyEqual(key)){find.val=value;}else{size++;intnewNodeLevel=0;while(Math.random()&lt;PROBABILITY){newNodeLevel++;}while(newNodeLevel&gt;maxLevel){head.nextNodes.add(null);maxLevel++;}SkipListNode&lt;K,V&gt;newNode=newSkipListNode&lt;K,V&gt;(key,value);for(inti=0;i&lt;=newNodeLevel;i++){newNode.nextNodes.add(null);}intlevel=maxLevel;SkipListNode&lt;K,V&gt;pre=head;while(level&gt;=0){pre=mostRightLessNodeInLevel(key,pre,level);if(level&lt;=newNodeLevel){newNode.nextNodes.set(level,pre.nextNodes.get(level));pre.nextNodes.set(level,newNode);}level--;}}}}","link":"https://stevenXu1992.github.io/post/you-xu-biao/"},{"title":"动态规划","content":"暴力递归--&gt;动态规划步骤：1)找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了2)把可变参数的所有组合映射成一张表，有1个可变参数就是一维表，2个可变参数就是二维3)最终答案要的是表中的哪个位置，在表中标出4)根据递归过程的basecase，把这张表的最简单不需要依赖其他位置的那些位置填好值5)根据递归过程非basecase的部分，也就是分析表中的普遍位置需要怎么计算得到，那么这张表的填写顺序也就确定了6)综上确定计算顺序，填好表，返回最终答案在表中位置的值1.机器人达到指定位置假设有排成一行的N个位置，记为1~N，N一定大于或等于2。开始时机器人在其中的M位置上(M一定是1~N中的一个)，机器人可以往左走或者往右走，如果机器人来到1位置，那么下一步只能往右来到2位置;如果机器人来到N位置，那么下一步只能往左来到N-1位置。规定机器人必须走K步，最终能来到P位置(P也一定是1~N中的一个)的方法有多少种。给定四个参数N、M、K、P，返回方法数。publicstaticintrobot(intN,intS,intE,intK){//N:共N个位置//S:起点//E:终点//K:可以走的步数if(N&lt;2||K&lt;1||S&lt;1||S&gt;N||E&lt;1||E&gt;N){return0;}//暴力递归intres=process1(N,S,E,K);//记忆化搜索int[][]dp=newint[K+1][N+1];for(inti=0;i&lt;K;i++){for(intj=0;j&lt;N;j++){dp[i][j]=-1;}}intres=process2(N,S,E,K,dp);//严格表结构动态规划intres=process(N,S,E,K);}//暴力递归publicstaticintprocess1(intN,intindex,intE,intrest){//index:当前位置//rest:还剩rest步if(rest==0){returnindex==E?1:0;}if(index==1){returnprocess(N,2,E,rest-1);}if(index==N){returnprocess(N,N-1,E,rest-1);}returnprocess(N,index+1,E,rest-1)+process(N,index-1,E,rest-1);}//记忆化搜索publicstaticintprocess2(intN,intindex,intE,intrest,int[][]dp){if(dp[index][rest]!=-1){returndp[index][rest];}if(rest==0){dp[index][rest]=E?1:0;}elseif(index==1){dp[index][rest]=process(N,2,E,rest-1);}elseif(index==N){dp[index][rest]=process(N,N-1,E,rest-1);}else{dp[index][rest]=process(N,index+1,E,rest-1)+process(N,index-1,E,rest-1);}returndp[index][rest];}//严格表结构动态规划publicstaticintprocess3(intN,intindex,intE,intrest){int[][]dp=newint[index+1][rest+1];dp[E][0]=1;for(inti=1;i&lt;index;i++){for(intj=1;j&lt;rest;j++){if(i==1){dp[i][j]=dp[2][j-1];}if(i==N){dp[i][j]=dp[N-1][j-1];}dp[i][j]=dp[i+1][j-1]+dp[i-1][j-1]}}returndp[index][rest];}2.换钱的最少货币数给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求组成aim的最少货币数。publicstaticintminCoin(int[]arr,intaim){if(arr.length==0||arr==null||aim&lt;0){return-1;}//暴力递归intres=process1(arr,0,aim);//记忆化搜索int[][]dp=newint[arr.length+1][aim+1];for(inti=0;i&lt;=arr.length;i++){for(intj=0;j&lt;=aim;j++){dp[i][j]=-2;}}intres=process2(arr,0,aim,dp);//严格表结构动态规划intres=process3(arr,0,aim);}//暴力递归publicstaticintprocess1(int[]arr,intindex,intrest){if(rest&lt;0){return-1;}if(rest==0){return0;}if(index==arr.length){return-1;}intp1=process1(arr,index+1,rest);intp2=process1(arr,index+1,rest-arr[index]);if(p1==-1&amp;&amp;p2==-1){return-1;}if(p1==-1){returnp2+1;}if(p2==-1){returnp1;}returnMath.min(p1,p2+1);}//记忆化搜索publicstaticintprocess2(int[]arr,intindex,intrest,int[][]dp){if(rest&lt;0){return-1;}if(dp[index][rest]!=-2){returndp[index][rest];}if(rest==0){dp[index][rest]=0;}elseif(index==arr.length){dp[index][rest]=-1;}else{intp1=process1(arr,index+1,rest);intp2=process1(arr,index+1,rest-arr[index]);if(p1==-1&amp;&amp;p2==-1){dp[index][rest]=-1;}else{if(p1==-1){dp[index][rest]=p2+1;}elseif(p2==-1){dp[index][rest]=p1;}else{dp[index][rest]=Math.min(p1,p2+1);}}}returndp[index][rest];}//严格表结构动态规划publicstaticintprocess3(int[]arr,intindex,intrest){int[][]dp=newint[arr.length+1][rest+1];for(inti=0;i&lt;=arr.length;i++){dp[i][0]=0;}for(intj=1;j&lt;=rest;j++){dp[arr.length][j]=-1;}for(inti=arr.length-1;i&gt;=0;i--){for(intj=1;j&lt;=rest;j++){intp1=dp[i+1][j];intp2=-1;if(j-arr[i]&gt;=0){p2=dp[i+1][j-arr[j]];}if(p1==-1&amp;&amp;p2==-1){dp[i][j]=-1;}if(p1==-1){dp[i][j]=p2+1;}if(p2==-1){dp[i][j]=p1;}dp[i][j]=Math.min(p1,p2+1);}}returndp[index][rest];}3.取纸牌问题给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。//暴力递归publicstaticintmaxWinSorce1(int[]arr){if(arr==null){return0;}returnMath.max(firstHand(arr,0,arr.length-1),secondHand(arr,0,arr.length-1));}publicstaticintfirstHand(int[]arr,intleft,intright){if(left==right){returnarr[left];}Math.max(arr[left]+secondHand(arr,left+1,right),arr[right]+secondHand(arr,left,right-1));}publicstaticintsecondHand(int[]arr,intleft,intright){if(left==right){return0;}Math.min(firstHand(arr,left+1,right),firstHand(arr,left,right-1));}//动态规划publicstaticintmaxWinScorce2(int[]arr){if(arr==null||arr.length=0){return0;}intN=arr.length;int[][]dpF=newint[N][N];int[][]dpS=newint[N][N];for(intleft=0;left&lt;N;left++){dpF[left][left]=arr[left];for(intright=left-1;right&gt;=0;right--){dpF[left][right]=Math.max(arr[left]+dpS[left+1][right],arr[right]+dpS[left][right-1]);dpS[left][right]=Math.min(dpF[left+1][right],dpF[left][right-1]);}}returnMath.max(dpF[0][N-1],dpS[0][N-1]);}4.象棋中马的跳法请同学们自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置。那么整个棋盘就是横坐标上9条线、纵坐标上10条线的一个区域。给你三个参数，x，y，k，返回如果“马”从(0,0)位置出发，必须走k步，最后落在(x,y)上的方法数有多少种?//暴力递归publicstaticintprocess1(intx,inty,intk){if(x&lt;0||x&gt;8||y&lt;0||y&gt;9){return0;}//剩余步数为零时，所在位置(x,y)距终点的相对距离为(0,0)时找到一种跳法if(k==0){return(x==0&amp;&amp;y==0)?1:0;}intres=process1(x-1,y+2,k-1)+process1(x+1,y+2,k-1)+process1(x+2,y+1,k-1)+process1(x+2,y-1,k-1)+process1(x+1,y-2,k-1)+process1(x-1,y-2,k-1)+process1(x-2,y-1,k-1)+process1(x-2,y+1,k-1);returnres;}//动态规划publicstaticintprocess2(intx,inty,intk){if(x&lt;0||x&gt;8||y&lt;0||y&gt;9){return0;}//x,y,k为立方体的长宽高,k层的数据取决于k-1层，因此从下往上填int[][][]dp=newint[9][10][k+1];dp[0][0][0]=1;for(intheight=1;height&lt;=k;height++){for(intlen=0;len&lt;9;len++){for(intwid=0;wid&lt;10;wid++){dp[len][wid][height]=getValue(dp,len-1,wid+2,height-1)+getValue(dp,len+1,wid+2,height-1)+getValue(dp,len+2,wid+1,height-1)+getValue(dp,len+2,wid-1,height-1)+getValue(dp,len+1,wid-2,height-1)+getValue(dp,len-1,wid-2,height-1)+getValue(dp,len-2,wid-1,height-1)+getValue(dp,len-2,wid+1,height-1);}}}returndp[x][y][k];}publicstaticintgetValue(int[][][]dp,intheight,intlen,intwid){if(len&lt;0||len&gt;8||wid&lt;0||wid&gt;9){return0;}returndp[len][wid][height];}5.Bob的生存概率给定五个参数n,m,i,j,k。表示在一个N*M的区域，Bob处在(i,j)点，每次Bob等概率的向上、下、左、右四个方向移动一步，Bob必须走K步。如果走完之后，Bob还停留在这个区域上，就算Bob存活，否则就算Bob死亡。请求解Bob的生存概率，返回字符串表示分数的方式。//暴力递归publicstaticStringbob(intn,intm,inti,intj,intk){longall=(long)Math.pow(4,k);longlive=process1(n,m,i,j,k);longgc=gcd(all,live);returnString.valueOf((live/gc)+&quot;/&quot;+(all/gc));}//返回可以存活的走法数publicstaticlongprocess1(intN,intM,inti,intj,intrest){if(i&lt;0||i&gt;N||j&lt;0||j&gt;M){return0;}if(rest==0){return1;}longlive=process1(N,M,i+1,j,rest-1)+process1(N,M,i,j+1,rest-1)+process1(N,M,i-1,j,rest-1)+process1(N,M,i,j-1,rest-1);}//动态规划publicstaticlongprocess2(intN,intM,inti,intj,intK){int[][][]dp=newint[N+1][M+1][K+1];for(intlen=0;len&lt;=N;len++){for(intwid=0;wid&lt;=M;wid++){dp[len][wid][0]=1;}}for(intheight=1;height&lt;=K;height++){for(intlen=0;len&lt;=N;len++){for(intwid=0;wid&lt;=M;wid++){dp[len][wid][height]=dp[len+1][wid][height-1]+dp[len-1][wid][height-1]+dp[len][wid+1][height-1]+dp[len][wid-1][height-1];}}}returndp[i][j][K];}publicstaticlonggcd(longm,longn){returnn==0?m:gcd(n,m%n);}","link":"https://stevenXu1992.github.io/post/dong-tai-gui-hua/"},{"title":"Morris遍历","content":"Morris遍历细节假设来到当前节点cur，开始时cur来到头节点位置1)如果cur没有左孩子，cur向右移动(cur=cur.right)2)如果cur有左孩子，找到左子树上最右的节点mostRight:​a.如果mostRight的右指针指向空，让其指向cur，然后cur向左移动(cur=cur.left)​b.如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur=cur.right)3)cur为空时遍历停止1.Morris自然序遍历Morris序：1-&gt;2-&gt;4-&gt;2-&gt;5-&gt;1-&gt;3-&gt;6-&gt;3-&gt;7publicstaticvoidmorrisClassical(Nodehead){if(head==null){return;}Nodecur=head;NodemostR=null;while(cur!=null){mostR=cur.left;//cur有左树，找到左树上最右的节点if(mostR!=null){while(mostR.right!=null&amp;&amp;mostR.right!=cur){mostR=mostR.right;}//此时mostR已到达cur左树上最右的节点处if(mostR.right==null){//若发现mostR右树为空，则是第一次到达该点mostR.right=cur;//先序操作//将mostR.right指向cur后，cur继续往下走执行外部while循环cur=cur.left;continue;}else{//若发现mostR.right指向cur，则是第二次到达该点，还原指针mostR.right=null;//edgeR(cur.left);后序操作}}//else{先序操作}//cur无左树，cur向右移动（通过之前修改的mostR.right指针返回父节点）,继续执行外部的while循环//中序操作cur=cur.right;}//edgeR（head);后序操作}2.先序遍历先序：1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6-&gt;7首次到达时进行操作，见1自然序注释3.中序遍历先序：4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7叶节点直接操作，其他节点第二次达到时操作，见1自然序注释4.后序遍历后序：4-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1发现第二次到达时，逆序操作cur左树的右边界，遍历完成后逆序操作整棵树的右边界，见1自然序注释publicstaticvoidedgeR(Nodehead){Nodetail=reverseEdge(head);Nodecur=tail;while(cur!=null){//遍历操作cur=cur.right;}reverseEdge(tail);}publicstaticNodereverseEdge(Nodefrom){Nodepre=null;Nodenext=next;while(from!=null){next=from.right;from.right=pre;pre=from;from=next;}returnpre;}","link":"https://stevenXu1992.github.io/post/morris-bian-li/"},{"title":"特殊结构","content":"1.滑动窗口//窗口结构（最大值）publicstaticclassWindowMax{privateintL;privateintR;privateint[]arr;//队列中存放数组的下标，peekfirst最大值privateLinkedList&lt;Integer&gt;queue;//初始化窗口publicWindowMax(int[]arr){this.arr=arr;L=-1;R=0;queue=newLinkedList&lt;&gt;();}//窗口右边界移动publicvoidshiftRight(){if(R==arr.length){return;}while(!queue.isEmpty()&amp;&amp;arr[queue.peekLast()]&lt;=arr[R]){queue.pollLast();}queue.addLast(R);R++;}//窗口左边界移动publicvoidshiftLeft(){if(L&gt;R-1){return;}L++;if(queue.peekFirst()==L){queue.pollFirst();}}//获取窗口内最大值publicintgetMax(){if(!queue.isEmpty()){returnarr[queue.peekFirst()];}returnnull;}}//请实现一个函数。输入:整型数组arr，窗口大小为w。输出:一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值publicstaticint[]getMaxInWindow(int[]arr,intw){if(arr==null||w&lt;1||arr.length&lt;w){returnnull;}LinkedList&lt;Integer&gt;queue=newLinkedList&lt;&gt;();int[]res=newint[arr.length-w+1];intindex=0;for(inti=0;i&lt;arr.length;i++){//窗口右边界向右滑动while(!queue.isEmpty()&amp;&amp;arr[queue.peekLast()]&lt;=arr[i]){queue.pollLast();}queue.addLast(i);//窗口左边界向右滑动if(queue.peekFirst()==i-w){//i-w：过期的点，刚从窗口中出来的点，判断该点是否是队列的firstqueue.pollFirst();}//保存最大值信息if(i&gt;=w-1){res[index++]=queue.peekFirst();}}returnres;}2.单调栈在数组中想找到一个数，左边和右边比这个数小、且离这个数最近的位置。如果对每一个数都想求这样的信息，能不能整体代价达到O(N)?publicstaticint[][]monotonousStack1(int[]arr){if(arr==null||arr.length&lt;1){returnnull;}int[][]res=newint[arr.length][2];//单调栈顶为最大值,栈内存储数组的下标Stack&lt;Integer&gt;stack=newStack&lt;&gt;();for(inti=0;i&lt;arr.length;i++){//若新加元素小于栈顶，则弹出栈顶元素并记录结果while(!stack.isEmpty()&amp;&amp;arr[stack.peek()]&gt;arr[i]){intpopIndex=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek();res[popIndex][0]=leftIndex;res[popIndex][1]=i;}stack.push(i);}//加完全部元素并记录了结果后，弹出剩下的元素并记录while(!stack.isEmpty()){intpopIndex=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek();res[popIndex][0]=leftIndex;res[popIndex][1]=-1;}returnres;}//数组中有重复的元素publicstaticint[][]monotonousStack2(int[]arr){Stack&lt;List&lt;Integer&gt;&gt;stack=newStack&lt;&gt;();int[][]res=newint[arr.length][2];for(inti=0;i&lt;arr.length;i++){//新加元素小于栈顶while(!stack.isEmpty()&amp;&amp;arr[i]&lt;arr[stack.peek()]){intpopIndex=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);res[popIndex][0]=leftIndex;res[popIndex][1]=i;}//新加元素等于栈顶if(arr[i]==arr[stack.peek().get(0)]{stack.peek().add(Integer.valueOf(i));}else{//新加元素大于栈顶ArrayList&lt;Integer&gt;list=newArrayList&lt;&gt;();list.add(i);stack.push(list);}}//加完全部元素并记录了结果后，弹出剩下的元素并记录while(!stack.isEmpty()){List&lt;Integer&gt;restList=stack.pop();intleftIndex=stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);for(Integeri:restList){res[i][0]=leftIndex;res[i][1]=-1;}}returnres;}","link":"https://stevenXu1992.github.io/post/te-shu-jie-gou/"},{"title":"字符串算法","content":"1.前缀树publicstaticclassTrieNode{publicintpass;publicintend;publicTrieNode[]nexts;publicTrieNode(){pass=0;end=0;nexts=newTrieNode[26];}}publicstaticclassTrie{privateTrieNoderoot;publicTrie(){root=newTrieNode();}//加入单词publicstaticvoidinsert(Stringword){if(word==null){return;}char[]chars=word.toCharArray();TrieNodenode=root;node.pass++;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(node.nexts[index]==null){node.nexts[index]=newTrieNode();}node=node.nexts[index];node.pass++;}node.end++;}//查询某单词加过几次publicstaticintsearch(Stringword){if(word==null){return0;}char[]chars=word.toCharArray();TrieNodenode=root;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(node.nexts[index]==null){return0;}node=node.nexts[index];}returnnode.end;}//查询某前缀加过几次publicstaticintsearchPrefix(Stringword){if(word==null){return0;}char[]chars=word.toCharArray();TrieNodenode=root;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(node.nexts[index]==null){return0;}node=node.nexts[index];}returnnode.pass;}//删除单词publicstaticvoiddelete(Stringword){if(search(word)==0){return;}char[]chars=word.toCharArray();TrieNodenode=root;node.pass--;intindex=0;for(inti=0;i&lt;chars.length;i++){index=chars[i]-'a';if(--node.nexts[index].pass==0){node.nexts[index]==null;return;}}node.end--;}}2.KMPpublicstaticintKMP(Stringstr1,Stringstr2){if(str1==null||str2==null||str2.length&gt;str1.length||str2.length()&lt;1){return-1;}char[]char1=str1.toCharArray();char[]char2=str2.toCharArray();int[]next=getNext(char2);inti1=0;inti2=0;while(i1&lt;char1.length&amp;&amp;i2&lt;char2.length){if(char1[i1]==char2[i2]){i1++;i2++;}elseif(i2==0){i1++;}else{i2=next[i2];}}returni2==char2.length?i1-i2:-1;}//获取每个字符之前的最大相同前缀后缀的长度publicstaticint[]getNext(char[]chars){if(chars.length==1){returnnewint[]{-1};}int[]next=newint[chars.length];next[0]=-1;next[1]=0;intindex=2;intcn=0;while(index&lt;next.length){if(chars[index-1]==chars[cn]){next[index++]=++cn;}else(cn&gt;0){cn=next[cn];}else{next[index++]=0;}}returnnext;}3.Manacherpublicstaticintmanacher(Stringstr){if(str==null||str.length==1){return0;}char[]chars=getManacherString(str);int[]help=newint[chars.length];intR=-1;//R为已找到的最大回文区域的右边界intC=-1;//C为最大回文区域的中心点intmax=Integer.MIN_VALUE;for(inti=0;i!=chars.length;i++){//情况1:i超出已知的最大回文区域右边界，正常向两边寻找回文区域//情况2:i在已知的最大回文区域右边界内部//1）i'的回文区域不超过最大回文区域的左边界：与i相同//2）i'的回文区域超过最大回文区域的左边界：与R-i相同//3）i'的回文区域正好在最大回文区域的左边界上：在R-i的基础上正常向两边寻找回文区域//2*C-i为i'help[i]=R&gt;i?Math.min(help[2*C-i],R-i):1;while(i+help[i]&lt;chars.length&amp;&amp;i-help[i]&gt;-1){if(chars[i+help[i]]==chars[i-help[i]]){help[i]++;}else{break;}}//更新R和Cif(i+help[i]&gt;R){R=i+help[i];C=i;}max=Math.max(max,help[i]);}returnmax-1;}publicstaticchar[]getManacherString(Stringstr){char[]chars=str.toCharArray();char[]res=newchar[str.length*2-1];intindex=0;for(inti=0;i&lt;chars.length;i++){res[i]=(i&amp;1)==0?'#':chars[index++];}returnres;}","link":"https://stevenXu1992.github.io/post/zi-fu-chuan-suan-fa/"},{"title":"并查集","content":"1.并查集结构publicclassUnionFind{//并查集元素publicstaticclassElement&lt;V&gt;{publicVvalue;publicElement(Vvalue){this.value=value;}}//并查集初始化publicstaticclassUnionSet{HashMap&lt;V,Element&lt;V&gt;&gt;elementMap;HashMap&lt;Element&lt;V&gt;,Element&lt;V&gt;&gt;fatherMap;HashMap&lt;Element&lt;V&gt;,Integer&gt;sizeMap;publicUnionSet&lt;V&gt;(List&lt;V&gt;list){elementMap=newHashMap&lt;&gt;();fatherMap=newHashMap&lt;&gt;();sizeMap=newHashMap&lt;&gt;();for(Vv:list){Element&lt;V&gt;e=newElement&lt;&gt;(v);elementMap.put(v,e);fatherMap.put(e,e);sizeMap.put(e,1);}}}//判断是否属于同一集合publicstaticbooleansame(Vv1,Vv2){if(elementMap.containsKey(v1)&amp;&amp;elementMap.containsKey(v2)){returnfindHead(elementMap.get(v1))==findHead(elementMap.get(v2));}returnfalse;}//集合合并publicstaticvoidunion(Vv1,Vv2){if(elementMap.containsKey(v1)&amp;&amp;elementMap.containsKey(v2)){Element&lt;V&gt;head1=findHead(elementMap.get(v1));Element&lt;V&gt;head2=findHead(elementMap.get(v2));if(head1!=head2){Element&lt;V&gt;big=sizeMap.get(head1)&gt;=sizeMap.get(head2)?head1:head2;Element&lt;V&gt;small=big==head1?head2:head1:fatherMap.put(small,big);sizeMap.put(big,sizeMap.get(big)+sizeMap.get(small));sizeMap.remove(small);}}}//查找头元素privatestaticElement&lt;V&gt;findHead(Element&lt;V&gt;e){Stack&lt;Element&lt;V&gt;&gt;stack=newStack&lt;&gt;();while(e!=fatherMap.get(e)){stack.push(e);e=fatherMap.get(e);}while(!stack.isEmpty()){fatherMap.put(stack.pop(),e);}returne;}}2.Kruskal最小生成树//优先级队列的比较器，权重小的边先出publicstaticclassmyComparatorimplementsComparator&lt;edge&gt;{publicintcompare(Edgeo1,Edgeo2){returno1.weight-o1.weight;}}publicstaticSet&lt;Edge&gt;kruskal(Graphgraph){List&lt;Node&gt;list=(List&lt;Node&gt;)graph.nodes.values();UnionSet&lt;Node&gt;unionSet=newunionSet&lt;&gt;(List);PriorityQueue&lt;Edge&gt;queue=newPriorityQueue&lt;&gt;(newmyComparator());for(Edgee:graph.edges){queue.add(e);}HashSet&lt;Edge&gt;res=newHashSet&lt;&gt;();while(!queue.isEmpty()){Edgee=queue.poll();if(!unionSet.same(e.from,e.to)){res.add(e);unionSet.union(e.from,e.to);}}returnres;}3.岛问题的并行算法设计publicstaticintisland(int[][]matrix){if(matrix==null||matrix[0]==null){return0;}intlength=matrix.length;intwidth=matrix[0].length;intres=0;for(inti=0;i&lt;length;i++){for(intj=0;j&lt;width;j++){if(matrix[i][j]==1){res++;infect(matrix,i,j,length,width);}}}}publicstaticvoidinfect(int[]matrix,inti,intj,intlength,intwidth){if(i&lt;0||i&gt;=length||j&lt;0||j&gt;=width||matrix[i][j]!=1){return;}matrix[i][j]=2;infect(matrix,i+1,j,length,width);infect(matrix,i-1,j,length,width);infect(matrix,i,j+1,length,width);infect(matrix,i,j-1,length,width);}","link":"https://stevenXu1992.github.io/post/bing-cha-ji/"},{"title":"暴力递归","content":"1.汉诺塔publicstaticvoidhannoi(intn){process(n,&quot;from&quot;,&quot;to&quot;,&quot;help&quot;);}publicstaticvoidprocess(intn,Stringfrom,Stringto,Stringhelp){if(n==1){System.out.println(&quot;move&quot;+from+&quot;to&quot;+to);}else{process(n-1,from,help,to);process(1,from,to,help);process(n-1,help,to,from);}}2.字符串子序列publicstaticList&lt;String&gt;subSequence(Stringstr){List&lt;String&gt;res=newArrayList&lt;&gt;();if(str==null){returnres;}if(str.length()==0){res.add(&quot;&quot;);returnres;}char[]chars=str.toCharArray();process(res,chars,&quot;&quot;,0);}publicstaticList&lt;String&gt;process(List&lt;String&gt;list,char[]chars,Stringpath,intindex){if(index==chars.length){list.add(path);}else{process(list,chars,path,index+1);process(list,chars,path+String.valueOf(chars[index]),index+1);}}3.字符串全排列publicstaticList&lt;String&gt;allArray(Stringstr){List&lt;String&gt;res=newArrayList&lt;&gt;();ArrayList&lt;String&gt;set=newArrayList&lt;&gt;();char[]chars=str.toCharArray();for(charc:chars){set.add(c);}process(set,&quot;&quot;,res);returnres;}publicstaticvoidprocess(ArrayList&lt;String&gt;set,Stringpath,List&lt;String&gt;list){if(set.isEmpty()){list.add(path);}HashSet&lt;Character&gt;picked=newHashSet&lt;&gt;();for(inti=0;i&lt;set.size();i++){if(!picked.contains(set.get(i))){picked.add(set.get(i));StringnewPath=path+set.get(i);ArrayList&lt;String&gt;next=newArrayList&lt;&gt;(set);next.remove(i);process(next,newPath,list);}}}4.背包问题publicstaticintbackpack(int[]weights,int[]values,intindex,intweighted,intbagLimit){if(weighted&gt;bagLimit){return0;}if(index&gt;weights.length){return0;}Math.max(backpack(weights,values,index+1,weighted,bagLimit),backpack(weights,values,index+1,weighted+weights[index],bagLimit)+values[index]);}5.纸牌问题publicstaticintmaxWinSorce(int[]arr){if(arr==null){return0;}returnMath.max(firstHand(arr,0,arr.length-1),)secondHand(arr,0,arr.length-1);}publicstaticintfirstHand(int[]arr,intleft,intright){if(left==right){returnarr[left];}Math.max(arr[left]+secondHand(arr,left+1,right),arr[right]+secondHand(arr,left,right-1));}publicstaticintsecondHand(int[]arr,intleft,intright){if(left==right){return0;}Math.min(firstHand(arr,left+1,right),firstHand(arr,left,right-1));}6.N皇后publicstaticintNQueen(intn){if(n&lt;1){return0;}returnprocess(0,newint[n],n);}publicstaticintprocess(intindex,int[]record,intn){if(index==n){return1;}intres=0;for(intj=0;j&lt;n;j++){if(valid(record,index,j)){record[index]=j;res+=process(index+1,record,n);}}returnres;}publicstaticbooleanvalid(int[]record,intindex,intj){for(intk=0;k&lt;index;k++){if(record[k]==j||Math.abs(record[k]-j)==Math.abs(i-k)){returnfalse;}}returntrue;}","link":"https://stevenXu1992.github.io/post/bao-li-di-gui/"},{"title":"图的经典算法","content":"1.模版publicclassGraph{publicHashMap&lt;Integer,Node&gt;nodes;publicHashSet&lt;Edge&gt;edges;publicGraph(){nodes=newHashMap&lt;&gt;();edges=newHashSet&lt;&gt;();}}publicclassNode{publicintvalue;publicintin;publicintout;publicArrayList&lt;Node&gt;nexts;publicArrayList&lt;Edge&gt;edges;publicNode(intdata){this.value=data;in=0;out=0;nexts=newArrayList&lt;&gt;();edges=newArrayList&lt;&gt;();}}publicclassEdge{publicintweight;publicNodefrom;publicNodeto;publicEdge(intweight,Nodefrom,Nodeto){this.weight=weight;this.from=from;this.to=to;}}2.图的遍历2.1宽度优先遍历publicstaticvoidBFS(Nodenode){if(node==null){return;}LinkedList&lt;Node&gt;queue=newLinkedList&lt;&gt;();HashSet&lt;Node&gt;set=newHashSet&lt;&gt;();queue.add(node);set.add(node);while(!queue.isEmpty()){Nodecur=queue.poll();//具体遍历操作for(Noden:cur.nexts){if(!set.contains(n)){queue.add(n);set.add(n);}}}}2.2深度优先遍历publicstaticvoidDFS(Nodenode){if(node==null){return;}Stack&lt;Node&gt;stack=newStack&lt;&gt;();HashSet&lt;Node&gt;set=newHashSet&lt;&gt;();stack.push(node);set.add(node);//具体遍历操作while(!stack.isEmpty()){Nodecur=stack.pop();for(Noden:cur.nexts){if(!set.contains(n)){stack.push(cur);stack.push(n);set.add(n);//具体遍历操作break;}}}}3.拓扑排序publicstaticList&lt;Node&gt;topologySort(Graphgraph){HashMap&lt;Node,Integer&gt;map=newHashMap&lt;&gt;();LinkedList&lt;Node&gt;queue=newLinkedList&lt;&gt;();ArrayList&lt;Node&gt;list=newArrayList&lt;&gt;();for(Noden:graph.nodes.values()){map.put(n,n.in);if(n.in==0){queue.add(n);}}while(!queue.isEmpty()){Nodecur=queue.pop();list.add(cur);for(Noden:cur.nexts){map.put(n,map.get(n)-1);if(map.get(n)==0){queue.add(n);}}}returnlist;}4.Prim算法publicstaticclassEdgeComparatorimplementsComparator&lt;Edge&gt;{publicintcompare(Edgeo1,Edgeo2){//自定义比较器://o1-o2&lt;0:o1--&gt;o2//o2-o1&lt;0:o2--&gt;o1returno1.weight-o2.weight;}}publicstaticSet&lt;Edge&gt;prim(Graphgraph){PriorityQueue&lt;Edge&gt;queue=newPriorityQueue&lt;&gt;();HashSet&lt;Node&gt;set=newHashSet&lt;Node&gt;();HashSet&lt;Edge&gt;res=newHashSet&lt;Edge&gt;();for(Nodenode:graph.nodes.values()){if(!set.contains(node)){set.add(node);for(Edgeedge:node.edges){queue.add(edge);}while(!queue.isEmpty()){Edgeedge=queue.poll();if(!set.contains(edge.to)){res.add(edge);set.add(edge.to);for(Edgee:edge.to.edges){queue.add(e);}}}}}returnres;}5.Dijkstra算法publicstaticHashMap&lt;Node,Integer&gt;dijkstra(Nodehead){//distanceMap:存储出发点至其他各点的距离HashMap&lt;Node,Integer&gt;distanceMap=newHashMap&lt;&gt;();//lockedSet:用于记录已锁定的点HashSet&lt;Node&gt;lockedSet=newHashSet&lt;&gt;();distanceMap.put(head,0);//unlockedMinNode:找出distanceMap中距离最小且未锁定的点NodeminNode=unlockedMinNode(distanceMap,lockedSet);while(minNode!=null){intdis=distanceMap.get(minNode);for(Edgeedge:minNode.edges){if(!distanceMap.containsKey(edge.to)){distanceMap.put(edge.to,dis+edge.weight);}//若distanceMap中已存在，则比较原距离和新发现的边所更新的距离distanceMap.put(edge.to,Math.min(distanceMap.get(edge.to),dis+edge.weight));}lockedSet.add(minNode);minNode=unlockedMinNode(distanceMap,lockedSet);}returndistanceMap;}publicstaticNodeunlockedMinNode(HashMap&lt;Node,Integer&gt;disMap,HashSet&lt;Node&gt;lockedSet){NodeminNode=null;intminDis=Integer.MAX_VALUE;for(Map.Entry&lt;Node,Integer&gt;entry:disMap.entrySet()){Noden=entry.getKey();intdis=entry.getValue();if(!lockedSet.contains(n)&amp;&amp;dis&lt;minDis){minNode=n;minDis=dis;}}returnminNode;}","link":"https://stevenXu1992.github.io/post/tu-de-jing-dian-suan-fa/"},{"title":"链表的常见算法","content":"1.反转链表//单向链表的反转publicstaticclassNode{intvalue;Nodenext;publicNode(intdata){this.value=data;}}publicstaticNodereverse(Nodehead){Nodepre=null;Nodenext=null;while(head!=null){next=head.next;head.next=pre;pre=head;head=next;}returnpre;}//双向链表的反转publicstaticclassDoubleNode{intvalue;DoubleNodenext;DoubleNodelast;publicDouble(intdata){this.value=data;}}publicstaticNodereverse(DoubleNodehead){DoubleNodepre=null;DoubleNodenext=null;while(head!=null){next=head.next;head.next=pre;head.last=next;pre=head;head=next;}returnpre;}2.判断是否为回文结构publicstaticbooleanpalindrome1(Nodehead){Stack&lt;Node&gt;stack=newStack&lt;Node&gt;();Nodecur=head;while(cur!=null){stack.push(cur);cur=cur.next;}while(!stack.isEmpty()){Noden=stack.pop();if(head.value!=n.value){returnfalse;}head=head.next;}returntrue;}publicstaticbooleanpalindrome2(Nodehead){Nodeslow=head.next;Nodefast=head;while(slow.next!=null&amp;&amp;fast.next.next!=null){slow=slow.next;fast=fast.next.next;}Stack&lt;Node&gt;stack=newStack&lt;Node&gt;();while(slow!=null){stack.push(slow);slow=slow.next;}while(!stack.isEmpty()){Noden=stack.pop();if(n.value!=head.value){returnfalse;}head=head.next;}returntrue;}publicstaticbooleanpalindrome3(Nodehead){Nodeslow=head;Nodefast=head;while(slow.next!=null&amp;&amp;fast.next.next!=null){slow=slow.next;fast=fast.next.next;}//此时slow停在中点，复用fast指针反转链表fast=slow.next;slow.next=null;Nodenext=null;while(fast!=null){next=fast.next;fast.next=slow;slow=fast;fast=next;}//反转完成，此时slow在尾部,fast为null，开始判断Nodeend=slow;//记录尾部节点，复原使用booleanres=true;while(head!=null&amp;&amp;slow!=null){if(head.value!=slow.value){res=false;}head=head.next;slow=slow.next;}//复原链表,复用fast指针fast=end.next;end.next=null;while(fast!=null){next=fast.next;fast.next=end;end=fast;fast=next;}returnres;}3.链表的荷兰国旗问题publicstaticNodeflag(Nodehead,intpivot){NodesHead=null;NodesTail=null;NodeeHead=null;NodeeTail=null;NodebHead=null;NodebTail=null;while(head!=null){if(head.value&lt;pivot){if(sHead==null){sHead=head;sTail=head;}else{sTail.next=head;sTail=head;}}elseif(head.value&gt;pivot){if(bHead==null){bHead=head;bTail=head;}else{bTail.next=head;bTail=head;}}else{if(eHead==null){eHead=head;eTail=head;}else{eTail.next=head;eTail=head;}}head=head.next;}if(sTail!=null){sTail.next=eHead;eTail=eTail==null?sTail:eTail;}if(eTail!=null){eTail.next=bHead;}returnsHead!=null?sHead:eHead!=null?eHead:bHead;}4.带随机指针的链表复制publicstaticNodecopy1(Nodehead){HashMap&lt;Node,Node&gt;map=newHashMap&lt;&gt;();Nodecur=head;while(cur!=null){map.put(cur,newNode(cur.value));cur=cur.next;}cur=head;while(cur!=null){map.get(cur).next=map.get(cur.next);map.get(cur).random=map.get(cur.random);cur=cur.next;}returnmap.get(head);}publicstaticNodecopy2(Nodehead){//先按照next指针在原链表中每个节点后面复制对应节点Nodecur=head;Nodenext=null;while(cur!=null){next=cur.next;cur.next=newNode(cur.value);cur.next.next=next;cur=next;}//复制原链表的random指针cur=head;Nodecopy=null;while(cur!=null){next=cur.next.next;copy=cur.next;copy.random=cur.random!=?cur.random.next:null;cur=next;}//将原链表与复制好的链表分离Noderes=head.next;cur=head;while(cur!=null){next=cur.next.next;copy=cur.next;cur.next=next;copy.next=next!=null?next.next:null;cur=next;}returnres;}5.链表相交相关问题判断两个链表是否相交，若相交返回相交节点publicstaticNodeintersection(Nodehead1,Nodehead2){if(head1==null||head2==null){returnnull;}Nodeloop1=getLoop(head1);Nodeloop2=getLoop(head2);//1.若两个链表都无环if(loop1==null&amp;&amp;loop2==null){returnnoLoop(head1,head2);}//2.若一个有环，一个无环，必定不相交//3.若两个链表都有环if(loop1!=null&amp;&amp;loop2!=null){returnbothLoop(head1,loop1,head2,loop2);}returnnull;}//判断一个链表是否有环并返回入环节点publicstaticNodegetLoop(Nodehead){if(head==null||head.next==null||head.next.next==null){returnnull;}Nodeslow=head.next;Nodefast=head.next.next;while(slow!=fast){slow=slow.next;fast=fast.next.next;}fast=head;while(slow!=fast){slow=slow.next;fast=fast.next;}returnfast;}//都无环publicstaticNodenoLoop(Nodehead1,Nodehead2){Nodecur1=head1;Nodecur2=head2;intlength=0;//分别找出两个链表的尾部,length用于求长度的差值while(cur1.next!=null){length++;cur1=cur1.next;}while(cur2.next!=null){length--;cur2=cur2.next;}//只有尾节点相同才会相交if(cur1==cur2){cur1=length&gt;0?head1:head2;//cur1指向更长链表的头部cur2=cur1==head1?head2:head1;length=Math.abs(length);while(length!=0){length--;cur1=cur1.next;}while(cur1!=cur2){cur1=cur1.next;cur2=cur2.next;}returncur1;}else{returnnull;}}//都有环publicstaticNodebothLoop(Nodehead1,Nodeloop1,Nodehead2,Nodeloop2){Nodecur1=null;Nodecur2=null;//若入环节点相同，则类似于无环相交的情况if(loop1==loop2){cur1=head1;cur2=head2;intlength=0;while(cur1!=loop1){length++;cur1=cur1.next;}while(cur2!=loop2){length--;cur2=cur.next;}cur1=length&gt;0?head1:head2;cur2=cur1==head1?head2:head1;length=Math.abs(length);while(length!=0){length--;cur1=cur1.next;}while(cur1!=cur2){cur1=cur1.next;cur2=cur2.next;}returncur1;}else{cur1=loop1.next;while(cur1!=loop1){if(cur1==loop2){returnloop1;}cur1=cur1.next;}returnnull;}}","link":"https://stevenXu1992.github.io/post/lian-biao-chang-jian-ti-mu/"},{"title":"排序算法","content":"1.冒泡排序publicstaticvoidbubbleSort(int[]arr){if(arr.length&lt;2||arr==null){return;}//大数冒泡for(inti=arr.length-1;i&gt;0;i--){for(intj=0;j&lt;i;j++){if(arr[j]&gt;arr[j+1]){swap(arr,j,j+1);}}}//小数冒泡for(inti=0;i&lt;arr.length-1;i++){for(intj=length-1;j&gt;i;j--){if(arr[j]&lt;arr[j-1]){swap(arr,j,j-1);}}}}publicstaticvoidswap(int[]arr,inta,intb){inttemp=arr[a];arr[a]=arr[b];arr[b]=temp;}2.插入排序publicstaticvoidinsertSort(int[]arr){if(arr==null||arr.length&lt;2){return;}for(inti=1;i&lt;arr.length;i++){for(intj=i-1;j&gt;=0&amp;&amp;arr[j]&gt;arr[j+1];j--){swap(arr,j,j+1);}}}3.选择排序publicstaticvoidselectSort(int[]arr){if(arr==null||arr.length&lt;2){return;}for(inti=0;i&lt;arr.length;i++){intminIndex=i;for(intj=i+1;j&lt;arr.length;j++){minIndex=arr[j]&lt;arr[minIndex]?j:minIndex;}swap(arr,minIndex,i);}}4.归并排序publicstaticvoidmergeSort(int[]arr){if(arr==null||arr.length&lt;2){return;}process(arr,0,arr.length-1);}publicstaticvoidprocess(int[]arr,intleft,intright){if(left==right){return;}intmid=(left+right)/2;process(arr,left,mid);process(arr,mid+1,right);merge(arr,left,mid,right);}publicstaticvoidmerge(int[]arr,intleft,intmid,intright){int[]help=newint[right-left+1];intp1=left;intp2=mid+1;inti=0;while(p1&lt;=mid&amp;&amp;p2&lt;=right){help[i++]=arr[p1]&lt;arr[p2]?arr[p1++]:arr[p2++];}while(p1&lt;=mid){help[i++]=arr[p1++];}while(p2&lt;=right){help[i++]=arr[p2++];}for(intj=0;j&lt;help.length;j++){arr[left+j]=help[j];}}5.随机快排publicstaticvoidquickSort(int[]arr){if(arr==null||arr.length&lt;2){return;}process(arr,0,arr.length-1);}publicstaticvoidprocess(int[]arr,intleft,intright){if(left&lt;right){swap(arr,right,left+(int)(Math.random()*(right-left+1)));int[]p=partition(arr,left,right);process(arr,left,p[0]-1);process(arr,p[1]+1,right);}}publicstaticint[]partition(int[]arr,intleft,intright){intlessZone=left-1;intmoreZone=right;while(left&lt;moreZone){if(arr[left]&gt;arr[right]){swap(arr,left,--moreZone);}if(arr[left]&lt;arr[right]){swap(arr,left++,++lessZone);}else{left++;}}swap(arr,right,moreZone);returnnewint[]{lessZone+1,moreZone};}6.堆排序用数组的方式表示完全二叉树，对于任意节点i：左子节点:2i+1,右子节点:2i+2,父节点:（i-1）/2publicstaticvoidheapSort(int[]arr){if(arr==null||arr.length&lt;2){return;}for(inti=0;i&lt;arr.length;i++){heapInsert(arr,i);}intsize=arr.length;swap(arr,0,--size);while(size&gt;0){heapify(arr,0,size);swap(arr,0,--size);}}publicstaticvoidheapInsert(int[]arr,intindex){while(arr[index]&gt;arr[(index-1)/2]){swap(arr,index,(index-1)/2);index=(index-1)/2;}}publicstaticvoidheapify(int[]arr,intindex,intsize){intleft=2*index+1;while(left&lt;size){intmax=left+1&lt;size&amp;&amp;arr[left+1]&gt;arr[left]?left+1:left;max=arr[max]&gt;arr[index]?max:index;if(max==index){break;}swap(arr,index,max);index=max;left=2*index+1;}}7.桶排序基数排序计数排序8.总结时间复杂度空间复杂度是否稳定选择排序O(N^2)O(1)否冒泡排序O(N^2)O(1)是插入排序O(N^2)O(1)是归并排序O(N*logN)O(N)是随机快排O(N*logN)O(logN)否堆排序O(N*logN)O(1)否桶排序O(N)O(M)是","link":"https://stevenXu1992.github.io/post/pai-xu-suan-fa/"},{"title":"二叉树的常见算法","content":"1.判断是否为完全二叉树判断标准：宽度优先遍历时1）若某节点有右节点无左节点，则不为完全二叉树2）某节点左右节点不全，后续都必须为叶节点，否则不是完全二叉树(用一个布尔值记录状态)publicstaticbooleanheapTree(Nodehead){if(head==null){returntrue;}LinkedList&lt;Node&gt;()queue=newLinkedList&lt;&gt;();queue.add(head);booleanleaf=false;Noderight=null;Nodeleft=null;while(!queue.isEmpty()){head=queue.poll();right=head.right;left=head.left;if((right!=null&amp;&amp;left==null)//条件1||(leaf&amp;&amp;(right!=null||left!=null))){//条件2returnfalse;}if(right!=null){queue.add(right);}if(left!=null){queue.add(left);}if(right==null||left==null){leaf=true;//左右子树有一个为空，开启叶节点的记录状态}}returntrue;}2.查找两个节点的最低公共祖先节点设两个节点为n1,n2，递归函数中：若头节点为n1或n2,返回自己（为空则返回空）递归黑盒求出左右子树的返回值若左右子树返回值都不为空，返回自己（已找到公共祖先）左右子树一个为空一个不为空，返回不为空的一项publicstaticNodeprocess(Nodehead,Noden1,Noden2){if(head==null||head==n1||head==n2){returnhead;}Nodeleft=process(head.left,n1,n2);Noderight=process(head.right,n1,n2);if(left!=null&amp;&amp;right!=null){returnhead;}returnleft==null?right:left;}3.查找某节点的后继节点后继节点：某节点在中序遍历中的下一个节点publicstaticNodefind(Nodenode){if(node==null){returnnode;}if(node.right!=null){//有右树returnprocess(node.right);//则中继为右树上最左的节点}else{//无右树Nodeparent=node.parent;//若node=parent.left,则直接返回parent//否则继续向上寻找，直到node=parent.node//最后，若一直未找到则返回null(最右节点的中继为null)while(parent!=null&amp;&amp;node!=parent.left){node=parent;parent=node.parent;}returnparent;}}publicstaticNodeprocess(Nodenode){if(node==null){returnnode;}while(node.left!=null){node=node.left;}returnnode;}4.序列化与反序列化//'#'表示null,'_'用于分隔publicstaticStringserial(Nodenode){if(node==null){return'#_';}Stringres=node.data+'_';//按照先序遍历的顺序将树序列化成字符串res+=serial(node.left);res+=serial(node.right);returnres;}publicstaticNoderecon(Stringstr){String[]arr=str.split('_');Queue&lt;String&gt;queue=newLinkedList&lt;String&gt;();for(inti=0;i!=arr.length;i++){queue.offer(arr[i]);}returnreconProcess(queue);}publicstaticNodereconProcess(Queue&lt;String&gt;queue){Stringstr=queue.poll();if(str.equals('#')){returnnull;}Nodehead=newNode(Integer.valueOf(str));head.left=reconProcess(queue);head.right=reconProcess(queue);returnhead;}","link":"https://stevenXu1992.github.io/post/er-cha-shu-chang-jian-ti-mu/"},{"title":"二叉树的递归框架","content":"1.判断一棵树是否为满二叉树满二叉树条件：总节点个数=2^高度-1定义一个信息类，用于获取需要的信息（此处为节点数和高度）递归函数中先使用黑盒，再补充黑盒中获取信息的操作（此处为假定通过黑盒已获取到了当前节点的左右子树的高度和节点个数，使用该信息得出当前节点处的高度和节点个数）在主函数中判断是否满足条件//定义信息类publicstaticclassInfo{publicintsize;publicintheight;publicInfo(ints,inth){this.size=s;this.height=h;}}//递归函数publicstaticInfoprocess(Nodehead){if(head==null){returnnewInfo(0,0);}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intsize=leftInfo.size+rightInfo.size+1;intheight=Math.max(leftInfo.height,rightInfo.height)+1;returnnewInfo(size,height);}//主函数publicstaticbooleanisFullTree(Nodehead){Infoinfo=process(head);returninfo.size==(1&lt;&lt;height)-1;//左移1位=2^height}2.判断一棵树是否为平衡二叉树平衡二叉树条件：左右子树高度差不超过1且所有子树都平衡信息类：高度，子树是否平衡publicstaticclassInfo{publicintheight;publicbooleanbalance;publicInfo(inth,booleanb){this.height=h;this.balance=b;}}publicstaticInfoprocess(Nodehead){if(head==null){returnnewInfo(0,true);}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intheight=Math.max(leftInfo.height,rightInfo.height)+1;booleanbalance=leftInfo.balance&amp;&amp;rightInfo.balance&amp;&amp;Math.abs(leftInfo.height-rightInfo.height)&lt;2;returnnewInfo(height,balance);}3.求二叉树两节点间的最大距离信息类：高度，最大距离最大距离出现的三种情况：左树上，右树上，横跨头节点publicstaticclassInfo{publicintheight;publicintdistance;publicInfo(inth,intd){this.height=h;this.distance=d;}}publicstaticInfoprocess(Nodehead){if(head=null){returnnewInfo(0,0);}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intheight=Math.max(leftInfo.height,rightInfo.height)+1;intdistance=Math.max(leftInfo.height+rightInfo.height+1,Math.max(leftInfo.distance,rightInfo.distance));returnnewInfo(height,distance);}4.判断一棵树是否为搜索二叉树搜索二叉树的条件：1）左树是搜索二叉树，2）右树是搜索二叉树，3）左树的最大值小于头节点，4）右树的最小值大于头节点信息类：是否为搜索二叉树，最大值，最小值publicstaticclassInfo{publicbooleansearchTree;publicintmax;publicintmin;publicInfo(booleans,intmax,intmin){this.searchTree=s;this.max=max;this.min=min;}}publicstaticInfoprocess(Nodehead){if(head==null){returnnull;}InfoleftInfo=process(head.left);InforightInfo=process(head.right);intmax=head.data;intmin=head.data;if(leftInfo!=null){max=Math.max(max,leftInfo.max);min=Math.min(min,leftInfo.min);}if(rightInfo!=null){max=Math.max(max,rightInfo.max);min=Math.min(min,rightInfo.min);}booleansearchTree=false;//三目的意义：若左树不为空，按1）左树是搜索树2）左树最大值小于节点值进行判断；若左树为空，则直接为true不用判断。右树同理。if((leftInfo!=null?(leftInfo.searchTree&amp;&amp;leftInfo.max&lt;head.data):true)&amp;&amp;(rightInfo!=null?(rightInfo.searchTree&amp;&amp;rightInfo.min&gt;head.data):true)){searchTree=true;}returnnewInfo(searchTree,max,min);}中序遍历方法publicstaticbooleansearchTree(Nodehead){if(head==null){returntrue;}Stack&lt;Node&gt;stack=newStack&lt;&gt;();Nodecur=head;intpre=Integer.MIN_VALUE;while(!stack.isEmpty()||cur!=null){if(cur!=null){stack.push(cur);cur=cur.left;}else{cur=stack.pop();if(cur.data&lt;=pre){returnfalse;}pre=cur.data;cur=cur.right;}}returntrue;}","link":"https://stevenXu1992.github.io/post/er-cha-shu-de-di-gui-kuang-jia/"},{"title":"二叉树的遍历","content":"1.递归遍历publicstaticclassNode{publicintvalue;publicNodeleft;publicNoderight;publicNode(intdata){this.value=data;}}publicstaticvoidf(Nodehead){if(head==null){return;}//先序遍历操作f(head.left);//中序遍历操作f(head.right);//后序遍历操作}二叉树递归遍历的本质：通过树的完整递归序加工而成完整递归序：1-&gt;2-&gt;2-&gt;2-&gt;1-&gt;3-&gt;3-&gt;3-&gt;1先序：第一次来到节点时进行操作1-&gt;2-&gt;3中序：第二次来到节点时进行操作2-&gt;1-&gt;3后序：第三次来到节点时进行操作2-&gt;3-&gt;12.非递归遍历2.1先序遍历遍历顺序：中--&gt;左--&gt;右，1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6-&gt;7建立栈结构，压入头节点从栈中弹出当前节点，并执行遍历操作先压入弹出节点的右子节点，再压左子节点，重复步骤2直到栈为空publicstaticvoidpreUnRecur(Nodehead){if(head!=null){Stack&lt;Node&gt;stack=newStack&lt;&gt;();stack.add(head);while(!stack.isEmpty()){head=stack.pop();//该处执行遍历操作if(head.right!=null){stack.push(head.right);}if(head.left!=null){stack.push(head.left);}}}}2.2中序遍历遍历顺序：左--&gt;中--&gt;右，4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7建立栈结构，压入头节点不断将当前节点的左子节点压栈，直到某节点的左子节点为空，此时从栈中弹出该节点并执行遍历操作若弹出节点的右子节点不为空，重复步骤2；若为空，则继续从栈中弹出下一节点直到栈为空publicvoidinUnRecur(Nodehead){if(head!=null){Stack&lt;Node&gt;stack=newStack&lt;&gt;();Nodecur=head;while(!stack.isEmpty()||cur!=null){if(cur!=null){stack.push(cur);cur=cur.left;}else{cur=stack.pop();//此处执行遍历操作cur=cur.right;}}}}2.3后序遍历遍历顺序：左--&gt;右--&gt;中，4-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1类似于先序遍历，按照先左后右的顺序压栈。额外准备一个栈，将弹出节点压入，直到1号栈为空时，将节点依次从2号栈弹出并执行遍历操作。publicstaticvoidpostUnRecur(Nodehead){if(head!=null){Stack&lt;Node&gt;s1=newStack&lt;&gt;();Stack&lt;Node&gt;s2=newStack&lt;&gt;();s1.push(head);while(!s1.isEmpty()){head=s1.pop();s2.push(head);if(head.left!=null){s1.push(head.left);}if(head.right!=null){s1.push(head.right);}}while(!s2.isEmpty()){head=s2.pop();//此处执行遍历操作}}}3.宽度优先遍历使用哈希表记录每个节点所在层数，使用队列进行宽度优先遍历每个节点都进入队列，其左右子节点层数+1进入哈希表从队列弹出时，比较该节点所在层数是否大于当前层数，若大于（说明已到了下一层），则将当前层宽度清零并更新当前层数；若不大于（说明还在同一层），则当前层宽度+1。每次对一个节点操作完成后都比较并更新最大宽度与当前层宽度的最大值。publicstaticintgetMaxWidth(Nodehead){if(head==null){return0;}intmaxWidth=0;intcurWidth=0;intcurLevel=0;HashMap&lt;Node,Integer&gt;levelMap=newHashMap&lt;&gt;();LinkedList&lt;Node&gt;queue=newLinkedList&lt;&gt;();levelMap.put(head,1);queue.add(head);Nodecur=null;Nodeleft=null;Noderight=null;while(!queue.isEmpty()){cur=queue.poll();left=cur.left;right=cur.right;if(left!=null){levelMap.put(left,levelMap.get(cur)+1);queue.add(left);}if(right!=null){levelMap.put(right,levelMap.get(cur)+1);queue.add(right);}if(levelMap.get(cur)&gt;curLevel){curWidth=0;curLevel=levelMap.get(cur);}else{curWidth++;}maxWidth=Math.max(curWidth,maxWidth);}returnmaxWidth;}","link":"https://stevenXu1992.github.io/post/er-cha-shu-de-bian-li/"},{"title":"Hello Gridea","content":"👏欢迎使用Gridea！✍️Gridea一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意......GithubGridea主页示例网站特性👇📝你可以使用最酷的Markdown语法，进行快速创作🌉你可以给文章配上精美的封面图和在文章任意位置插入图片🏷️你可以对文章进行标签分组📋你可以自定义菜单，甚至可以创建外部链接菜单💻你可以在Windows，MacOS或Linux设备上使用此客户端🌎你可以使用𝖦𝗂𝗍𝗁𝗎𝖻𝖯𝖺𝗀𝖾𝗌或CodingPages向世界展示，未来将支持更多平台💬你可以进行简单的配置，接入Gitalk或DisqusJS评论系统🇬🇧你可以使用中文简体或英语🌁你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力🖥你可以自定义源文件夹，利用OneDrive、百度网盘、iCloud、Dropbox等进行多设备同步🌱当然Gridea还很年轻，有很多不足，但请相信，它会不停向前🏃未来，它一定会成为你离不开的伙伴尽情发挥你的才华吧！😘Enjoy~","link":"https://stevenXu1992.github.io/post/hello-gridea/"}]}