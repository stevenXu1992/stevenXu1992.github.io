<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-05-31T15:13:22.618Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-134 Gas Station]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-134-gas-station/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-134-gas-station/">
        </link>
        <updated>2020-05-31T15:12:33.000Z</updated>
        <content type="html"><![CDATA[<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p><strong>Note:</strong></p>
<ul>
<li>If there exists a solution, it is guaranteed to be unique.</li>
<li>Both input arrays are non-empty and have the same length.</li>
<li>Each element in the input arrays is a non-negative integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
</code></pre>
<pre><code class="language-java">//my submission
public class GasNode{
    int gas;
    int cost;
    int index;
    GasNode next;
    public GasNode(int gas, int cost, int index){
      this.gas = gas;
      this.cost = cost;
      this.index = index;
    }
}

public int canCompleteCircuit(int[] gas, int[] cost) {
        
    //generate GasNode List
    GasNode head = new GasNode(gas[0], cost[0], 0);
    GasNode cur = head;
    for(int j = 1; j &lt; gas.length; j++){
      cur.next = new GasNode(gas[j], cost[j], j);
      cur = cur.next;
    }
    cur.next = head;

    //start from every station
    for(int i = 0; i &lt; gas.length; i++){
      GasNode node = head;
      int restGas = node.gas;
      while(restGas &gt;= node.cost){
        restGas -= node.cost;
        node = node.next;
        restGas += node.gas;
        if(node == head){
          return head.index;
        }
      }   
      head = head.next; 
    }
    return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-299 Bulls and Cows]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-299-bulls-and-cows/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-299-bulls-and-cows/">
        </link>
        <updated>2020-05-31T11:39:12.000Z</updated>
        <content type="html"><![CDATA[<p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called &quot;bulls&quot;) and how many digits match the secret number but locate in the wrong position (called &quot;cows&quot;). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend's guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows.</p>
<p>Please note that both secret number and friend's guess may contain duplicate digits.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;

Output: &quot;1A3B&quot;

Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;

Output: &quot;1A1B&quot;

Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.
</code></pre>
<p><strong>Note:</strong> You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.</p>
<pre><code class="language-java">//solution
public String getHint(String secret, String guess) {
  int[] record = new int[10];
  int A = 0;
  int B = 0;

  //使用record数组记录已出现过的数字（范围0～9）
  //在同位置的iSecret != iGuess的情况下，出现过的iSecret使record数组对应位置的数字+1
  //出现过的iGuess使record数组对应位置的数字-1
  //因此若发现 record[iSecret] &lt; 0 则表示此数字被发现过但还未使用过，record[iGuess] &gt; 0 同理。
  for(int i = 0; i &lt; secret.length(); i++){
    int iSecret = Character.getNumericValue(secret.charAt(i));
    int iGuess = Character.getNumericValue(guess.charAt(i));
    if(iSecret == iGuess){
      A++;
    }else{
      if(record[iSecret] &lt; 0 ){
        B++;
      }
      if(record[iGuess] &gt; 0){
        B++;
      }
      record[iSecret]++;
      record[iGuess]--;
    }
  }
  String ans = A + &quot;A&quot; + B + &quot;B&quot;;
  return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-41 First Missing Positive]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-41-first-missing-positive/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-41-first-missing-positive/">
        </link>
        <updated>2020-05-31T10:57:05.000Z</updated>
        <content type="html"><![CDATA[<p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,2,0]
Output: 3
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [3,4,-1,1]
Output: 2
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: [7,8,9,11,12]
Output: 1
</code></pre>
<p><strong>Note:</strong></p>
<p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p>
<pre><code class="language-java">//solution
public int firstMissingPositive(int[] A) {
  int i = 0;
  //遍历数组并将每个数n放到n-1位置A[A[i]-1] != A[i]
  while(i &lt; A.length){
    if(A[i] &gt;= 1 &amp;&amp; A[i] &lt;= A.length &amp;&amp; A[A[i]-1] != A[i]) {
      swap(A, i, A[i]-1);
    }else{ i++; }
  }
  //放好位置后再次遍历，第一次遇到 A[i] != i + 1 时就是答案
  for(int i = 0; i &lt; A.length; i++) 
    if( A[i] != i + 1 ){return i + 1; }
  return A.length + 1;
}

private void swap(int[] A, int i, int j){
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-189 Rotate Array]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-189-rotate-array/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-189-rotate-array/">
        </link>
        <updated>2020-05-28T14:45:11.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n * k)
//Space complexity: O(1)
public void rotate(int[] nums, int k) {
    if(nums.length &lt; 2){
      return;
    }
    while(k != 0){
      rotateOnce(nums);
      k--;
    }
}
public void rotateOnce(int[] arr){
    for(int i = arr.length - 1; i &gt; 0; i--){
      int temp = arr[i - 1];
      arr[i - 1] = arr[i];
      arr[i] = temp;
    }
}

//solution
//Time complexity: O(n)
//Space complexity: O(1)
public void rotate(int[] nums, int k) {
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
}
public void reverse(int[] nums, int start, int end) {
    while (start &lt; end) {
      int temp = nums[start];
      nums[start] = nums[end];
      nums[end] = temp;
      start++;
      end--;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-80 Remove Duplicates from Sorted Array II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/">
        </link>
        <updated>2020-05-28T13:16:18.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public int removeDuplicates(int[] nums) {
    if(nums.length &lt; 3){
      return nums.length;
    }
    int dif = 2;
    for(int i = 2; i &lt; nums.length; i++){
      if(nums[i] != nums[dif-2]){
        nums[dif++] = nums[i];
      }
    }
    return dif;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-26 Remove Duplicates from Sorted Array]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/">
        </link>
        <updated>2020-05-28T13:15:26.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public static int f(int[] nums){
  if(nums.length == 0){ return 0;}
  int i = 0;
  for(int j = 1; j &lt; nums.length; j++){
    if(nums[i] != nums[j]){
      i++;
      nums[i] = nums[j];
    }
  }
  return i + 1;
  
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-27 Remove Element]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-27-remove-element/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-27-remove-element/">
        </link>
        <updated>2020-05-28T13:14:54.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//my submission
public int removeElement(int[] nums, int val) {
    if(nums.length == 0){
      return 0;
    }
    if(nums.length == 1){
      return nums[0] == val ? 0 : 1;
    }

    int zone = nums.length - 1;
    int index = 0;
    while(index &lt;= zone){
      if(nums[index] == val){
        swap(nums, index, zone--);
      }else{
        index++;
      }
    }
    return zone + 1;
}

public static void swap(int[] arr, int a, int b){
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-5 Longest Palindromic Substring]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/">
        </link>
        <updated>2020-05-28T09:18:58.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;cbbd&quot;
Output: &quot;bb&quot;
</code></pre>
<pre><code class="language-java">//my submission
public String longestPalindrome(String s) {
    if(s.length() &lt; 2){
      return s.length() == 1 ? s : &quot;&quot;;
    }

    //生成Manacher最长回文半径数组
    int[] manacher = manacher(s);
    char[] chars = getManacherString(s);
    int max = Integer.MIN_VALUE;
    int maxIndex = 0;
    for(int i = 0; i &lt; manacher.length; i++){
      if(manacher[i] &gt; max){
        max = manacher[i];
        maxIndex = i;
      }
    }

    String res = &quot;&quot;;
    max--;
    for(int j = maxIndex - max; j &lt;= maxIndex + max; j++){
      res += chars[j];
    }
  	//去除特殊符号
    res = restore(res, '#');
    return res;
}
    
public static int[] manacher(String s){
    char[] chars = getManacherString(s);
    int R = -1;
    int C = -1;
    int[] manacher = new int[chars.length];

    for(int i = 0; i != chars.length; i++){
      
      //先算出不需要重复扩充的半径区域
      manacher[i] = R &gt; i ? Math.min(manacher[2*C-i],R-i) : 1;
      
      //扩充过程
      while(i-manacher[i]&gt;-1 &amp;&amp; i+manacher[i] &lt; chars.length){
        if(chars[i + manacher[i]] == chars[i - manacher[i]]){
          manacher[i]++;
        }else {break;}
      }
      
      //更新最大回文区域的右边界
      if(i + manacher[i] &gt; R){
        R = i + manacher[i];
        C = i;
      }
    }
  
    return manacher;
}
    
public static char[] getManacherString(String s){
    char[] chars = s.toCharArray();
    char[] res = new char[s.length() * 2 + 1];
    int index = 0;
    for(int i = 0; i != res.length; i++){
      res[i] = (i &amp; 1) == 0 ? '#' : chars[index++];
    }
    return res;
}

public static String restore(String s, char r){
    String res = &quot;&quot;;
    for(int i = 0; i &lt; s.length(); i++){
      if(s.charAt(i) != r){
        res += s.charAt(i);
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-4 Median of Two Sorted Arrays]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/">
        </link>
        <updated>2020-05-28T06:19:36.000Z</updated>
        <content type="html"><![CDATA[<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre>
<pre><code class="language-java">//my submission
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
  int N1 = nums1.length;
  int N2 = nums2.length;
  if(N1 == 0){
    return N2 % 2 == 0 ? 
      (nums2[N2 / 2] + nums2[N2 / 2 - 1]) / 2.0 
      : nums2[N2 / 2];
  }else if(N2 == 0){
    return N1 % 2 == 0 ? 
  		(nums1[N1 / 2] + nums1[N1 / 2 - 1] ) / 2.0 
      : nums1[N1 / 2];
  }

  Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); 
  Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b-a );


  for(int i = 0; i &lt; nums1.length / 2; i++){
    maxHeap.add(nums1[i]);
  }

  for(int j = nums1.length - 1; j &gt;= nums1.length / 2; j--){
    minHeap.add(nums1[j]);
  }

  for(int k = 0; k &lt; nums2.length; k++){
    if(nums2[k] &gt; minHeap.element()){
      minHeap.add(nums2[k]);
    }else {
      maxHeap.add(nums2[k]);
    }

    if(maxHeap.size() - minHeap.size() &gt; 1){
      minHeap.add(maxHeap.poll());
    }else if(minHeap.size() - maxHeap.size() &gt; 1){
      maxHeap.add(minHeap.poll());
    }
  }

  if(minHeap.size() == maxHeap.size()){
    return (maxHeap.element() + minHeap.element()) / 2.0;
  }else{
    return maxHeap.size() &gt; minHeap.size() ? 
      maxHeap.element() : minHeap.element();
  }
}

//solution
//Time complexity: O(n + m)
//Space complexity: O(1)
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int index1 = 0;
    int index2 = 0;
    int med1 = 0;
    int med2 = 0;
    for (int i=0; i&lt;=(nums1.length+nums2.length)/2; i++) {
        med1 = med2;
        if (index1 == nums1.length) {
            med2 = nums2[index2];
            index2++;
        } else if (index2 == nums2.length) {
            med2 = nums1[index1];
            index1++;
        } else if (nums1[index1] &lt; nums2[index2] ) {
            med2 = nums1[index1];
            index1++;
        }  else {
            med2 = nums2[index2];
            index2++;
        }
    }
    if ((nums1.length+nums2.length)%2 == 0) {
        return (float)(med1+med2)/2;
    }
    return med2;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-3 Longest Substring Without Repeating Characters]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/">
        </link>
        <updated>2020-05-27T14:29:39.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;abcabcbb&quot;
Output: 3 
Explanation: The answer is &quot;abc&quot;, with the length of 3. 
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3. 
             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n)
public int lengthOfLongestSubstring(String s) {
    if(s == null || s.length() == 0){
      return 0;
    }

    char[] chars = s.toCharArray();
    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
    int max = Integer.MIN_VALUE;

    for(int i = 0; i &lt; chars.length; i++){
      while(!queue.isEmpty() &amp;&amp; set.contains(chars[i])){
        set.remove(chars[queue.pollFirst()]);
      }
      queue.addLast(i);
      set.add(chars[i]);
      max = Math.max(max, queue.size());
    }
    return max;
}

//solution
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();
    int ans = 0, i = 0, j = 0;
    while (i &lt; n &amp;&amp; j &lt; n) {
      // try to extend the range [i, j]
      if (!set.contains(s.charAt(j))){
        set.add(s.charAt(j++));
        ans = Math.max(ans, j - i);
      }
      else {
        set.remove(s.charAt(i++));
      }
    }
    return ans;
}
</code></pre>
]]></content>
    </entry>
</feed>