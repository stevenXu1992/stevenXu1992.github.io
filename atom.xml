<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-06-11T10:04:10.521Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-67 Add Binary]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-67-add-binary/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-67-add-binary/">
        </link>
        <updated>2020-06-11T10:03:37.000Z</updated>
        <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: a = &quot;11&quot;, b = &quot;1&quot;
Output: &quot;100&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: a = &quot;1010&quot;, b = &quot;1011&quot;
Output: &quot;10101&quot;
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>Each string consists only of <code>'0'</code> or <code>'1'</code> characters.</li>
<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>
<li>Each string is either <code>&quot;0&quot;</code> or doesn't contain any leading zero.</li>
</ul>
<pre><code class="language-java">//solution
public String addBinary(String a, String b) {
    StringBuilder sb = new StringBuilder();
    int p1 = a.length() - 1;
    int p2 = b.length() - 1;
    int carry = 0;
    while(p1 &gt;= 0 || p2 &gt;= 0){
      int sum = carry;
      if(p1 &gt;= 0){
        sum += a.charAt(p1--) - '0';
      }
      if(p2 &gt;= 0){
        sum += b.charAt(p2--) - '0';
      }
      sb.append(sum % 2);  //0%2 = 0, 1%2 = 1, 2%2 = 0
      carry = sum / 2;  //0/2 = 0, 1/2 = 0, 2/2 = 1
    }
    if(carry != 0){
      sb.append(carry);
    }
    return sb.reverse().toString();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-258 Add Digits]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-258-add-digits/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-258-add-digits/">
        </link>
        <updated>2020-06-11T10:02:48.000Z</updated>
        <content type="html"><![CDATA[<p>Given a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 38
Output: 2 
Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. 
             Since 2 has only one digit, return it.
</code></pre>
<pre><code class="language-java">// solution
public int addDigits(int num) {
    int digitalRoot = 0;
    while(num &gt; 0){
      digitalRoot += num % 10;
      num /= 10;
      if(num == 0 &amp;&amp; digitalRoot &gt; 9){ //还是大于10，重置参数
        num = digitalRoot;
        digitalRoot = 0;
      }
    }
    return digitalRoot;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-8 String to Integer (atoi)]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-8-string-to-integer-atoi/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-8-string-to-integer-atoi/">
        </link>
        <updated>2020-06-11T10:02:01.000Z</updated>
        <content type="html"><![CDATA[<p>Implement <code>atoi</code> which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Only the space character <code>' '</code> is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;42&quot;
Output: 42
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;   -42&quot;
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;4193 with words&quot;
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: &quot;words and 987&quot;
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical 
             digit or a +/- sign. Therefore no valid conversion could be performed.
</code></pre>
<p><strong>Example 5:</strong></p>
<pre><code>Input: &quot;-91283472332&quot;
Output: -2147483648
Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
</code></pre>
<pre><code class="language-java">//solution
public int myAtoi(String str) {
    str = str.trim();
    if(str.isEmpty()) return 0;
    int sign = 1;
    int index = 0;
    if(str.charAt(index) == '-' || str.charAt(index) == '+'){
      sign = str.charAt(index) == '-' ? -1 : 1;
      if(str.length() &lt; 2 || 
        !Character.isDigit(str.charAt(++index))){
        return 0;
      }
    }
    int temp = 0;
    while(index &lt; str.length()){
      if(Character.isDigit(str.charAt(index))){
        int num = str.charAt(index++) - '0';
        if(temp &gt; (Integer.MAX_VALUE - num) / 10){
          return sign == -1 ? 
            Integer.MIN_VALUE : Integer.MAX_VALUE;
        }
        temp = temp * 10 + num;
      }else{
        break;
      }
    }
    return temp * sign;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-165 Compare Version Numbers]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-165-compare-version-numbers/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-165-compare-version-numbers/">
        </link>
        <updated>2020-06-11T10:01:03.000Z</updated>
        <content type="html"><![CDATA[<p>Compare two version numbers <em>version1</em> and <em>version2</em>.<br>
If <code>*version1* &gt; *version2*</code> return <code>1;</code> if <code>*version1* &lt; *version2*</code> return <code>-1;</code>otherwise return <code>0</code>.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.</p>
<p>The <code>.</code> character does not represent a decimal point and is used to separate number sequences.</p>
<p>For instance, <code>2.5</code> is not &quot;two and a half&quot; or &quot;half way to version three&quot;, it is the fifth second-level revision of the second first-level revision.</p>
<p>You may assume the default revision number for each level of a version number to be <code>0</code>. For example, version number <code>3.4</code> has a revision number of <code>3</code> and <code>4</code> for its first and second level revision number. Its third and fourth level revision number are both <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;
Output: -1
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;
Output: 1
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;
Output: -1
</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;
Output: 0
Explanation: Ignoring leading zeroes, both “01” and “001&quot; represent the same number “1”
</code></pre>
<pre><code class="language-java">//solution
public int compareVersion(String version1, String version2) {
    int p1 = 0;
    int p2 = 0;
    int N1 = version1.length();
    int N2 = version2.length();
    int temp1 = 0;
    int temp2 = 0;

    while(p1 &lt; N1 || p2 &lt; N2){
      temp1 = 0;
      temp2 = 0;
      while(p1 &lt; N1 &amp;&amp; version1.charAt(p1) != '.'){
        temp1 = temp1 * 10 + (version1.charAt(p1++) - '0');
      }
      while(p2 &lt; N2 &amp;&amp; version2.charAt(p2) != '.'){
        temp2 = temp2 * 10 + (version2.charAt(p2++) - '0');
      }
      if(temp1 &gt; temp2){
        return 1;
      }else if(temp1 &lt; temp2){
        return -1;
      }else{
        p1++;
        p2++;
      }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-7 Reverse Integer]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-7-reverse-integer/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-7-reverse-integer/">
        </link>
        <updated>2020-06-11T09:59:55.000Z</updated>
        <content type="html"><![CDATA[<p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 123
Output: 321
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: -123
Output: -321
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: 120
Output: 21
</code></pre>
<p><strong>Note:</strong><br>
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<pre><code class="language-java">//solution
public int reverse(int x) {
    final int max = Integer.MAX_VALUE;
    final int min = Integer.MIN_VALUE;
    int rev = 0;
    while(x != 0){
      int pop = x % 10;
      x /= 10;
      if(rev &gt; max / 10 || (rev == max / 10 &amp;&amp; pop &gt; 7)){
        return 0;
      }
      if(rev &lt; min / 10 || (rev == min / 10 &amp;&amp; pop &lt; -8)){
        return 0;
      } 
      rev = rev * 10 + pop;
    }
    return rev;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-151 Reverse Words in a String]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-151-reverse-words-in-a-string/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-151-reverse-words-in-a-string/">
        </link>
        <updated>2020-06-11T09:59:08.000Z</updated>
        <content type="html"><![CDATA[<p>Given an input string, reverse the string word by word.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;the sky is blue&quot;
Output: &quot;blue is sky the&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;  hello world!  &quot;
Output: &quot;world! hello&quot;
Explanation: Your reversed string should not contain leading or trailing spaces.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;a good   example&quot;
Output: &quot;example good a&quot;
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. 
</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>A word is defined as a sequence of non-space characters.</li>
<li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li>
<li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li>
</ul>
<pre><code class="language-java">//solution
public String reverseWords(String s) {
    if(s.length() == 0){
      return &quot;&quot;;
    }
    char[] c = s.toCharArray();
    reverseAll(c, 0, c.length - 1);
    reverseWord(c);
    return cleanSpace(c);
}

public void reverseAll(char[] c, int a, int b){
    while(a &lt; b){
      char temp = c[a];
      c[a++] = c[b];
      c[b--] = temp;
    }
}

public void reverseWord(char[] c){
    int N = c.length;
    int i = 0;
    int j = 0;
    while(i &lt; N){
      while(i &lt; j || i &lt; N &amp;&amp; c[i] == ' '){
        i++;
      }
      while(j &lt; i || j &lt; N &amp;&amp; c[j] != ' '){
        j++;
      }
      reverseAll(c, i, j - 1);
    }
}

public String cleanSpace(char[] c){
    int N = c.length;
    int i = 0;
    int j = 0;
    while(j &lt; N){
      while(j &lt; N &amp;&amp; c[j] == ' '){
        j++;
      }
      while(j &lt; N &amp;&amp; c[j] != ' '){
        c[i++] = c[j++];
      }
      while(j &lt; N &amp;&amp; c[j] == ' '){
        j++;
      }
      if(j &lt; N){
        c[i++] = ' ';
      }
    }
    return new String(c).substring(0, i);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-383 Ransom Note]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-383-ransom-note/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-383-ransom-note/">
        </link>
        <updated>2020-06-06T14:55:11.000Z</updated>
        <content type="html"><![CDATA[<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: ransomNote = &quot;a&quot;, magazine = &quot;b&quot;
Output: false
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;
Output: false
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;
Output: true
</code></pre>
<pre><code class="language-java">//my submission
public boolean canConstruct(String ransomNote, String magazine) {
    int[] count = new int[26];
    char[] cMagazi = magazine.toCharArray();
    char[] cRansom = ransomNote.toCharArray();
    for(int i = 0; i &lt; cMagazi.length; i++){
      count[cMagazi[i] - 'a']++;
    }

    boolean res = true;
    for(int j = 0; j &lt; cRansom.length; j++){
      if(count[cRansom[j] - 'a'] &gt; 0){
        count[cRansom[j] - 'a']--;
      }else{
        res = false;
        break;
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-384 First Unique Character in a String]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-384-first-unique-character-in-a-string/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-384-first-unique-character-in-a-string/">
        </link>
        <updated>2020-06-06T14:54:03.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.</p>
<p><strong>Examples:</strong></p>
<pre><code>s = &quot;leetcode&quot;
return 0.

s = &quot;loveleetcode&quot;,
return 2.
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n)
//Space complexity: O(n)
public int firstUniqChar(String s) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    char c = ' ';
    for(int i = 0; i &lt; s.length(); i++){
      c = s.charAt(i);
      if(map.containsKey(c)){
        map.put(c, map.get(c) + 1);
      }else{
        map.put(c, 1);
      }
    }

    int res = -1;
    for(int j = 0; j &lt; s.length(); j++){
      c = s.charAt(j);
      if(map.get(c) == 1){
        res = j;
        break;
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-14 Longest Common Prefix]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-14-longest-common-prefix/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-14-longest-common-prefix/">
        </link>
        <updated>2020-06-05T14:45:35.000Z</updated>
        <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
Output: &quot;fl&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
Output: &quot;&quot;
Explanation: There is no common prefix among the input strings.
</code></pre>
<pre><code class="language-java">//my submission
public String longestCommonPrefix(String[] strs) {
    if(strs == null || strs.length==0 || strs[0].length()==0){
      return &quot;&quot;;
    }
    if(strs.length == 1){
      return strs[0];
    }
    Trie trie = new Trie();
    String prefix = &quot;&quot;;
    char first = strs[0].charAt(0);
    for(int i = 0; i &lt; strs.length; i++){
      if(strs[i].length()==0 || first != strs[i].charAt(0)){
        return &quot;&quot;;
      }
      prefix = trie.insert(strs[i]);
      first = strs[i].charAt(0);
    }
    return prefix;
}

public class TrieNode{
    public int pass;
    public int end;
    public TrieNode[] next;

    public TrieNode(){
      pass = 0;
      end = 0;
      next = new TrieNode[26];
    }
}

public class Trie{
    private TrieNode root;
    public Trie(){
      root = new TrieNode();
    }

    public String insert(String word){
        if(word == null){
          return &quot;&quot;;
        }
        char[] c = word.toCharArray();
        TrieNode node = root;
        node.pass++;
        int index = 0;
        int maxPass = 0;
        StringBuilder prefix = new StringBuilder();
        for(int i = 0; i &lt; c.length; i++){
          index = c[i] - 'a';
          if(node.next[index] == null){
            node.next[index] = new TrieNode();
          }
          node = node.next[index];
          node.pass++;
          if(node.pass &gt;= maxPass &amp;&amp; node.pass != 1){
            prefix.append(c[i]);
            maxPass = node.pass;
          }
        }
        node.end++;
        return prefix.toString();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-11 Container With Most Water]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-11-container-with-most-water/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-11-container-with-most-water/">
        </link>
        <updated>2020-06-01T13:01:17.000Z</updated>
        <content type="html"><![CDATA[<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, ..., <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
<figure data-type="image" tabindex="1"><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img" loading="lazy"></figure>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [1,8,6,2,5,4,8,3,7]
Output: 49
</code></pre>
<pre><code class="language-java">//solution
public int maxArea(int[] height) {
    int max = 0;
    for(int i = 0; i &lt; height.length; i++){
      for(int j = 1; j &lt; height.length; j++){
        if(Math.abs(j-i) * Math.min(height[i],height[j])&gt;max){
          max = Math.abs(j-i) * Math.min(height[i],height[j]);
        }
      }
    }
    return max;
}
</code></pre>
]]></content>
    </entry>
</feed>