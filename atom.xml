<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-06-01T09:09:46.115Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-45 Jump Game II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-45-jump-game-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-45-jump-game-ii/">
        </link>
        <updated>2020-06-01T09:09:02.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre>
<p><strong>Note:</strong></p>
<p>You can assume that you can always reach the last index.</p>
<pre><code class="language-java">//暴力递归(超时未通过)
 public int jump(int[] nums) {
   r	eturn process(nums, 0, 0);
 }

public int process(int[] nums, int index, int step){
    if(index == nums.length - 1){
      return step;
    }

    int min = Integer.MAX_VALUE;
    int maxDis = Math.min(index+nums[index], nums.length-1);
    for(int i = index + 1; i &lt;= maxDis; i++){
      min = Math.min(process(nums, i, step + 1), min);
    }
    return min;
}

//严格表结构动态规划
public int jump(int[] nums) {
  	return process(nums);
}

public int process(int[] nums){
    int N = nums.length;
    int[] dp = new int[N];
    Arrays.fill(dp, Integer.MAX_VALUE / 2);
    dp[N - 1] = 0;

    for(int index = N - 2; index &gt;= 0; index--){
      int maxDis = Math.min(index + nums[index], N - 1);
      for(int i = maxDis; i &gt;= index + 1; i--){
        dp[index] = Math.min(dp[index], dp[i] + 1);   
      }
    }
    return dp[0];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-55 Jump Game]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-55-jump-game/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-55-jump-game/">
        </link>
        <updated>2020-06-01T06:45:22.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>0 &lt;= nums[i][j] &lt;= 10^5</code></li>
</ul>
<pre><code class="language-java">//暴力递归
//Time complexity: O(2^n)
//Space complexity: O(n)
public boolean canJump(int[] nums) {
  	return process(nums, 0);
}

public boolean process(int[] nums, int index){
    if(index == nums.length - 1){
      return true;
    }

    int maxDis = Math.min(index + nums[index], nums.length - 1);
    for(int i = index + 1; i &lt;= maxDis; i++){
      if(process(nums, i)){
        return true;
      }
    }
    return false;
}

//记忆化搜索
//Time complexity: O(n^2)
//Space complexity: O(n)
public boolean canJump(int[] nums) {
    int[] dp = new int[nums.length + 1];
    int res = process(nums, 0, dp);
    return res == 1 ? true : false;
}

public int process(int[] nums, int index, int[] dp){
    if(dp[index] != 0){
      return dp[index];
    }
    if(index == nums.length - 1){
      dp[index] = 1;
      return dp[index];
    }
    int maxDis = Math.min(index+nums[index], nums.length-1);
    for(int i = index + 1; i &lt;= maxDis; i++){
      dp[index] = process(nums, i, dp);
      if(dp[index] == 1){
        return dp[index];
      }
    }
    dp[index] = -1;
    return dp[index];
}

//严格表结构动态规划
//Time complexity: O(n^2)
//Space complexity: O(n)
public boolean canJump(int[] nums) {
    int res = process(nums);
    return res == 1 ? true : false;
}

public int process(int[] nums){
    int[] dp = new int[nums.length];
    dp[nums.length - 1] = 1;
    for(int index = nums.length - 2; index &gt;= 0; index--){
      int maxDis = Math.min(index+nums[index], nums.length-1);
      for(int i = index + 1; i &lt;= maxDis; i++){
        if(dp[i] == 1){
          dp[index] = 1;
          break;
        }
      }
    }
    return dp[0];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-275 H-Index II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-275-h-index-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-275-h-index-ii/">
        </link>
        <updated>2020-06-01T06:44:30.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of citations <strong>sorted in ascending order</strong> (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index">definition of h-index on Wikipedia</a>: &quot;A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each.&quot;</p>
<p><strong>Example:</strong></p>
<pre><code>Input: citations = [0,1,3,5,6]
Output: 3 
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had 
             received 0, 1, 3, 5, 6 citations respectively. 
             Since the researcher has 3 papers with at least 3 citations each and the remaining 
             two with no more than 3 citations each, her h-index is 3.
</code></pre>
<p><strong>Note:</strong></p>
<p>If there are several possible values for <em>h</em>, the maximum one is taken as the h-index.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/h-index/description/">H-Index</a>, where <code>citations</code> is now guaranteed to be sorted in ascending order.</li>
<li>Could you solve it in logarithmic time complexity?</li>
</ul>
<pre><code class="language-java">//solution
public int hIndex(int[] citations) {
    if(citations.length == 0){
      return 0;
    }

    int N = citations.length;
    int H = 0;
    for(int i = N - 1; i &gt;= 0; i--){
      int num = N - i;
      if(citations[i] &gt;= num){
        H = num;
      }
    }
    return H;
}
</code></pre>
<p>注：</p>
<p>定义变量  num表示每个数在citations中对应的比自己大的数的个数（引用论文次数大于等于自己被引用的次数     的总的篇数），比如0对应的num就是5，因为比0大或等的数的个数为5。因此，citations对应的num为：</p>
<p>citations：0    1     3     5      6</p>
<p>num:         5     4     3     2       1</p>
<p>“代表他（她）的 N 篇论文中至多有 h 篇论文，分别被引用了至少 h 次“，仔细分析这句话”至多有 h 篇论文“表示的是num[i]对就的数，”分别被引用了至少 h 次“表示的是citations[i]，则num[i]&lt;=citations[i]才满足条件。此处满足条件的是citations=[3,5,6]，对应的num=[3,2,1]。而我们只需要取num的最大值就可以了。<br>
————————————————<br>
版权声明：本文为CSDN博主「lear_scu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_36327328/java/article/details/83117379</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-274 H-Index]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-274-h-index/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-274-h-index/">
        </link>
        <updated>2020-06-01T06:43:53.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index">definition of h-index on Wikipedia</a>: &quot;A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em>papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each.&quot;</p>
<p><strong>Example:</strong></p>
<pre><code>Input: citations = [3,0,6,1,5]
Output: 3 
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had 
             received 3, 0, 6, 1, 5 citations respectively. 
             Since the researcher has 3 papers with at least 3 citations each and the remaining 
             two with no more than 3 citations each, her h-index is 3.
</code></pre>
<p><strong>Note:</strong> If there are several possible values for <em>h</em>, the maximum one is taken as the h-index.</p>
<pre><code class="language-java">//solution
public int hIndex(int[] citations) {
    int n = citations.length;
    int[] buckets = new int[n+1];
    for(int c : citations) {
        if(c &gt;= n) {
            buckets[n]++;
        } else {
            buckets[c]++;
        }
    }
    int count = 0;
    for(int i = n; i &gt;= 0; i--) {
        count += buckets[i];
        if(count &gt;= i) {
            return i;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-134 Gas Station]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-134-gas-station/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-134-gas-station/">
        </link>
        <updated>2020-05-31T15:12:33.000Z</updated>
        <content type="html"><![CDATA[<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p><strong>Note:</strong></p>
<ul>
<li>If there exists a solution, it is guaranteed to be unique.</li>
<li>Both input arrays are non-empty and have the same length.</li>
<li>Each element in the input arrays is a non-negative integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
</code></pre>
<pre><code class="language-java">//my submission
public class GasNode{
    int gas;
    int cost;
    int index;
    GasNode next;
    public GasNode(int gas, int cost, int index){
      this.gas = gas;
      this.cost = cost;
      this.index = index;
    }
}

public int canCompleteCircuit(int[] gas, int[] cost) {
        
    //generate GasNode List
    GasNode head = new GasNode(gas[0], cost[0], 0);
    GasNode cur = head;
    for(int j = 1; j &lt; gas.length; j++){
      cur.next = new GasNode(gas[j], cost[j], j);
      cur = cur.next;
    }
    cur.next = head;

    //start from every station
    for(int i = 0; i &lt; gas.length; i++){
      GasNode node = head;
      int restGas = node.gas;
      while(restGas &gt;= node.cost){
        restGas -= node.cost;
        node = node.next;
        restGas += node.gas;
        if(node == head){
          return head.index;
        }
      }   
      head = head.next; 
    }
    return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-299 Bulls and Cows]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-299-bulls-and-cows/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-299-bulls-and-cows/">
        </link>
        <updated>2020-05-31T11:39:12.000Z</updated>
        <content type="html"><![CDATA[<p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called &quot;bulls&quot;) and how many digits match the secret number but locate in the wrong position (called &quot;cows&quot;). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend's guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows.</p>
<p>Please note that both secret number and friend's guess may contain duplicate digits.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;

Output: &quot;1A3B&quot;

Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;

Output: &quot;1A1B&quot;

Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.
</code></pre>
<p><strong>Note:</strong> You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.</p>
<pre><code class="language-java">//solution
public String getHint(String secret, String guess) {
  int[] record = new int[10];
  int A = 0;
  int B = 0;

  //使用record数组记录已出现过的数字（范围0～9）
  //在同位置的iSecret != iGuess的情况下，出现过的iSecret使record数组对应位置的数字+1
  //出现过的iGuess使record数组对应位置的数字-1
  //因此若发现 record[iSecret] &lt; 0 则表示此数字被发现过但还未使用过，record[iGuess] &gt; 0 同理。
  for(int i = 0; i &lt; secret.length(); i++){
    int iSecret = Character.getNumericValue(secret.charAt(i));
    int iGuess = Character.getNumericValue(guess.charAt(i));
    if(iSecret == iGuess){
      A++;
    }else{
      if(record[iSecret] &lt; 0 ){
        B++;
      }
      if(record[iGuess] &gt; 0){
        B++;
      }
      record[iSecret]++;
      record[iGuess]--;
    }
  }
  String ans = A + &quot;A&quot; + B + &quot;B&quot;;
  return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-41 First Missing Positive]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-41-first-missing-positive/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-41-first-missing-positive/">
        </link>
        <updated>2020-05-31T10:57:05.000Z</updated>
        <content type="html"><![CDATA[<p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,2,0]
Output: 3
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [3,4,-1,1]
Output: 2
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: [7,8,9,11,12]
Output: 1
</code></pre>
<p><strong>Note:</strong></p>
<p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p>
<pre><code class="language-java">//solution
public int firstMissingPositive(int[] A) {
  int i = 0;
  //遍历数组并将每个数n放到n-1位置A[A[i]-1] != A[i]
  while(i &lt; A.length){
    if(A[i] &gt;= 1 &amp;&amp; A[i] &lt;= A.length &amp;&amp; A[A[i]-1] != A[i]) {
      swap(A, i, A[i]-1);
    }else{ i++; }
  }
  //放好位置后再次遍历，第一次遇到 A[i] != i + 1 时就是答案
  for(int i = 0; i &lt; A.length; i++) 
    if( A[i] != i + 1 ){return i + 1; }
  return A.length + 1;
}

private void swap(int[] A, int i, int j){
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-189 Rotate Array]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-189-rotate-array/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-189-rotate-array/">
        </link>
        <updated>2020-05-28T14:45:11.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n * k)
//Space complexity: O(1)
public void rotate(int[] nums, int k) {
    if(nums.length &lt; 2){
      return;
    }
    while(k != 0){
      rotateOnce(nums);
      k--;
    }
}
public void rotateOnce(int[] arr){
    for(int i = arr.length - 1; i &gt; 0; i--){
      int temp = arr[i - 1];
      arr[i - 1] = arr[i];
      arr[i] = temp;
    }
}

//solution
//Time complexity: O(n)
//Space complexity: O(1)
public void rotate(int[] nums, int k) {
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
}
public void reverse(int[] nums, int start, int end) {
    while (start &lt; end) {
      int temp = nums[start];
      nums[start] = nums[end];
      nums[end] = temp;
      start++;
      end--;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-80 Remove Duplicates from Sorted Array II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/">
        </link>
        <updated>2020-05-28T13:16:18.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public int removeDuplicates(int[] nums) {
    if(nums.length &lt; 3){
      return nums.length;
    }
    int dif = 2;
    for(int i = 2; i &lt; nums.length; i++){
      if(nums[i] != nums[dif-2]){
        nums[dif++] = nums[i];
      }
    }
    return dif;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-26 Remove Duplicates from Sorted Array]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/">
        </link>
        <updated>2020-05-28T13:15:26.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public static int f(int[] nums){
  if(nums.length == 0){ return 0;}
  int i = 0;
  for(int j = 1; j &lt; nums.length; j++){
    if(nums[i] != nums[j]){
      i++;
      nums[i] = nums[j];
    }
  }
  return i + 1;
  
}
</code></pre>
]]></content>
    </entry>
</feed>