<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-06-12T14:00:06.506Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-113 Path Sum II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-113-path-sum-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-113-path-sum-ii/">
        </link>
        <updated>2020-06-12T13:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre>
<p>Return:</p>
<pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre>
<pre><code class="language-java">//my submission
public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    process(root, sum, new ArrayList&lt;Integer&gt;(), res);
    return res;
}

public void process(TreeNode node, int rest, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; list){
    if(node == null) return;
    path.add(node.val);
    if(node.left == null &amp;&amp; node.right == null 
       &amp;&amp; rest - node.val == 0){
      list.add(new ArrayList&lt;Integer&gt;(path));
    }else{
      process(node.left, rest - node.val, path, list);
      process(node.right, rest - node.val, path, list);
    }
    path.remove(path.size() - 1);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-112 Path Sum]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-112-path-sum/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-112-path-sum/">
        </link>
        <updated>2020-06-12T13:58:36.000Z</updated>
        <content type="html"><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<pre><code class="language-java">//my submission
public boolean hasPathSum(TreeNode root, int sum) {
    if(root == null) return false;
    return process(root, sum);
}

public boolean process(TreeNode node, int rest){
    if(rest - node.val == 0 &amp;&amp; node.right == null &amp;&amp; node.left == null) return true;
    boolean left = false;
    boolean right = false;
    if(node.left != null){
      left = process(node.left, rest - node.val);
    }
    if(node.right != null){
      right = process(node.right, rest - node.val);
    }
    return left || right;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-257 Binary Tree Paths]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-257-binary-tree-paths/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-257-binary-tree-paths/">
        </link>
        <updated>2020-06-12T13:57:47.000Z</updated>
        <content type="html"><![CDATA[<p>Given a binary tree, return all root-to-leaf paths.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<pre><code>Input:

   1
 /   \
2     3
 \
  5

Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3
</code></pre>
<pre><code class="language-java">// my submission
public List&lt;String&gt; binaryTreePaths(TreeNode root) {
    List&lt;String&gt; res = new ArrayList&lt;&gt;();
    if(root != null) process(root, &quot;&quot;, res);
    return res;
}

public void process(TreeNode node, String path, List&lt;String&gt; list){
    if(node.left == null &amp;&amp; node.right == null){
      list.add(path + node.val);
    } 
    if(node.left != null){
      process(node.left, path + node.val + &quot;-&gt;&quot;, list);
    }
    if(node.right != null){
      process(node.right, path + node.val + &quot;-&gt;&quot;, list);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-226 Invert Binary Tree]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-226-invert-binary-tree/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-226-invert-binary-tree/">
        </link>
        <updated>2020-06-12T13:57:03.000Z</updated>
        <content type="html"><![CDATA[<p>Invert a binary tree.</p>
<pre><code class="language-java">//Recursive
public TreeNode invert1(TreeNode root){
    if(root == null) return null;
    TreeNode right = invert1(root.right);
    TreeNode left = invert1(root.left);
    root.left = right;
    root.right = left;
    return root;
}

//Iterative
public TreeNode invertTree(TreeNode root) {
    if(root == null) return null;
    LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while(!queue.isEmpty()){
      TreeNode cur = queue.poll();
      TreeNode temp = cur.left;
      cur.left = cur.right;
      cur.right = temp;
      if(cur.left != null) queue.add(cur.left);
      if(cur.right != null) queue.add(cur.right);
    }
    return root;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-101 Symmetric Tree]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-101-symmetric-tree/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-101-symmetric-tree/">
        </link>
        <updated>2020-06-12T13:56:09.000Z</updated>
        <content type="html"><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre>
<p><strong>Follow up:</strong> Solve it both recursively and iteratively.</p>
<pre><code class="language-java">//Recursive
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}

public boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null &amp;&amp; t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    return (t1.val == t2.val)
        &amp;&amp; isMirror(t1.right, t2.left)
        &amp;&amp; isMirror(t1.left, t2.right);
}

//Iterative
public boolean isSymmetric(TreeNode root) {
    if(root == null) return true;
    LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root.left);
    queue.add(root.right);
    while(!queue.isEmpty()){
      TreeNode n1 = queue.poll();
      TreeNode n2 = queue.poll();
      if(n1 == null &amp;&amp; n2 == null) continue;
      if(n1 == null || n2 == null) return false;
      if(n1.val != n2.val) return false;
      queue.add(n1.left);
      queue.add(n2.right);
      queue.add(n1.right);
      queue.add(n2.left);
    }
    return true;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-69 Sqrt(x)]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-69-sqrtx/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-69-sqrtx/">
        </link>
        <updated>2020-06-12T13:55:19.000Z</updated>
        <content type="html"><![CDATA[<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 4
Output: 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since 
             the decimal part is truncated, 2 is returned.
</code></pre>
<pre><code class="language-java">//solution
public static int mySqrt(int x) {  //牛顿迭代法
    if(x == 0) return 0;
    double a = 0;  // b和a是相邻两次迭代结果
    double b = 1;      // 在1附近开始找，迭代逼近目标值
    while(Math.abs(b-a) &gt; 0.1)  // 判断条件为abs(b-a) &gt; 0.1
    {
      a = b;
      b = (b + x/b)/2.0;
    }
    return (int)b;  // 返回值要求为int，需强制转换
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-50 Pow(x, n)]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-50-powx-n/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-50-powx-n/">
        </link>
        <updated>2020-06-12T13:54:30.000Z</updated>
        <content type="html"><![CDATA[<p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em> (xn).</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 2.00000, 10
Output: 1024.00000
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 2.10000, 3
Output: 9.26100
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> is a 32-bit signed integer, within the range [−231, 231 − 1]</li>
</ul>
<pre><code class="language-java">//solution
public double myPow(double x, int n) {
    if(n &lt; 0) return 1 / pow(x, -n);
    return pow(x, n);
}

public double pow(double x, int n){
    if(n == 0) return 1;
    double half = pow(x, n / 2);
    if(n % 2 == 0){
      return half * half;
    }else{
      return x * half * half;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-29 Divide Two Integers]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-29-divide-two-integers/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-29-divide-two-integers/">
        </link>
        <updated>2020-06-12T13:53:36.000Z</updated>
        <content type="html"><![CDATA[<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>
<p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>truncate(8.345) = 8</code> and <code>truncate(-2.7335) = -2</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.
</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function <strong>returns 231 − 1 when the division result overflows</strong>.</li>
</ul>
<pre><code class="language-java">//solution
public int divide(int dividend, int divisor) {
    //Reduce the problem to positive long integer to make it easier.
    //Use long to avoid integer overflow cases.
    int sign = 1;
    if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || 
        (dividend &lt; 0 &amp;&amp; divisor &gt; 0))
      sign = -1;
    long ldividend = Math.abs((long) dividend);
    long ldivisor = Math.abs((long) divisor);

    //Take care the edge cases.
    if (ldivisor == 0) return Integer.MAX_VALUE;
    if ((ldividend == 0) || (ldividend &lt; ldivisor))	return 0;

    long lans = ldivide(ldividend, ldivisor);

    int ans;
    if (lans &gt; Integer.MAX_VALUE){ //Handle overflow.
      ans = (sign == 1)? 
        Integer.MAX_VALUE : Integer.MIN_VALUE;
    } else {
      ans = (int) (sign * lans);
    }
    return ans;
}

private long ldivide(long ldividend, long ldivisor) {
  // Recursion exit condition
  if (ldividend &lt; ldivisor) return 0;

  //  Find the largest multiple so that (divisor * multiple &lt;= dividend), 
  //  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.
  //  Think this as a binary search.
  long sum = ldivisor;
  long multiple = 1;
  while ((sum+sum) &lt;= ldividend) {
    sum += sum;
    multiple += multiple;
  }
  //Look for additional value for the multiple from the reminder (dividend - sum) recursively.
  return multiple + ldivide(ldividend - sum, ldivisor);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-43 Multiply Strings]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-43-multiply-strings/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-43-multiply-strings/">
        </link>
        <updated>2020-06-12T13:52:33.000Z</updated>
        <content type="html"><![CDATA[<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;
Output: &quot;6&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;
Output: &quot;56088&quot;
</code></pre>
<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>
<li>Both <code>num1</code> and <code>num2</code> contain only digits <code>0-9</code>.</li>
<li>Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number 0 itself.</li>
<li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li>
</ol>
<pre><code class="language-java">//solution
public String multiply(String num1, String num2) {
    int n1 = num1.length(), n2 = num2.length();
    int[] products = new int[n1 + n2];
    for (int i = n1 - 1; i &gt;= 0; i--) {
      for (int j = n2 - 1; j &gt;= 0; j--) {
        int d1 = num1.charAt(i) - '0';
        int d2 = num2.charAt(j) - '0';
        products[i + j + 1] += d1 * d2;
      }
    }
    int carry = 0;
    for (int i = products.length - 1; i &gt;= 0; i--) {
      int tmp = (products[i] + carry) % 10;
      carry = (products[i] + carry) / 10;
      products[i] = tmp;
    }
    StringBuilder sb = new StringBuilder();
    for (int num : products) sb.append(num);
    while(sb.length()!=0 &amp;&amp; sb.charAt(0)=='0'){
      sb.deleteCharAt(0);
    }
    return sb.length() == 0 ? &quot;0&quot; : sb.toString();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-67 Add Binary]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-67-add-binary/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-67-add-binary/">
        </link>
        <updated>2020-06-11T10:03:37.000Z</updated>
        <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: a = &quot;11&quot;, b = &quot;1&quot;
Output: &quot;100&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: a = &quot;1010&quot;, b = &quot;1011&quot;
Output: &quot;10101&quot;
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>Each string consists only of <code>'0'</code> or <code>'1'</code> characters.</li>
<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>
<li>Each string is either <code>&quot;0&quot;</code> or doesn't contain any leading zero.</li>
</ul>
<pre><code class="language-java">//solution
public String addBinary(String a, String b) {
    StringBuilder sb = new StringBuilder();
    int p1 = a.length() - 1;
    int p2 = b.length() - 1;
    int carry = 0;
    while(p1 &gt;= 0 || p2 &gt;= 0){
      int sum = carry;
      if(p1 &gt;= 0){
        sum += a.charAt(p1--) - '0';
      }
      if(p2 &gt;= 0){
        sum += b.charAt(p2--) - '0';
      }
      sb.append(sum % 2);  //0%2 = 0, 1%2 = 1, 2%2 = 0
      carry = sum / 2;  //0/2 = 0, 1/2 = 0, 2/2 = 1
    }
    if(carry != 0){
      sb.append(carry);
    }
    return sb.reverse().toString();
}
</code></pre>
]]></content>
    </entry>
</feed>