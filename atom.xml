<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-06-06T14:56:06.600Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-383 Ransom Note]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-383-ransom-note/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-383-ransom-note/">
        </link>
        <updated>2020-06-06T14:55:11.000Z</updated>
        <content type="html"><![CDATA[<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: ransomNote = &quot;a&quot;, magazine = &quot;b&quot;
Output: false
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;
Output: false
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;
Output: true
</code></pre>
<pre><code class="language-java">//my submission
public boolean canConstruct(String ransomNote, String magazine) {
    int[] count = new int[26];
    char[] cMagazi = magazine.toCharArray();
    char[] cRansom = ransomNote.toCharArray();
    for(int i = 0; i &lt; cMagazi.length; i++){
      count[cMagazi[i] - 'a']++;
    }

    boolean res = true;
    for(int j = 0; j &lt; cRansom.length; j++){
      if(count[cRansom[j] - 'a'] &gt; 0){
        count[cRansom[j] - 'a']--;
      }else{
        res = false;
        break;
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-384 First Unique Character in a String]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-384-first-unique-character-in-a-string/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-384-first-unique-character-in-a-string/">
        </link>
        <updated>2020-06-06T14:54:03.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.</p>
<p><strong>Examples:</strong></p>
<pre><code>s = &quot;leetcode&quot;
return 0.

s = &quot;loveleetcode&quot;,
return 2.
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n)
//Space complexity: O(n)
public int firstUniqChar(String s) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
    char c = ' ';
    for(int i = 0; i &lt; s.length(); i++){
      c = s.charAt(i);
      if(map.containsKey(c)){
        map.put(c, map.get(c) + 1);
      }else{
        map.put(c, 1);
      }
    }

    int res = -1;
    for(int j = 0; j &lt; s.length(); j++){
      c = s.charAt(j);
      if(map.get(c) == 1){
        res = j;
        break;
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-14 Longest Common Prefix]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-14-longest-common-prefix/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-14-longest-common-prefix/">
        </link>
        <updated>2020-06-05T14:45:35.000Z</updated>
        <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
Output: &quot;fl&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
Output: &quot;&quot;
Explanation: There is no common prefix among the input strings.
</code></pre>
<pre><code class="language-java">//my submission
public String longestCommonPrefix(String[] strs) {
    if(strs == null || strs.length==0 || strs[0].length()==0){
      return &quot;&quot;;
    }
    if(strs.length == 1){
      return strs[0];
    }
    Trie trie = new Trie();
    String prefix = &quot;&quot;;
    char first = strs[0].charAt(0);
    for(int i = 0; i &lt; strs.length; i++){
      if(strs[i].length()==0 || first != strs[i].charAt(0)){
        return &quot;&quot;;
      }
      prefix = trie.insert(strs[i]);
      first = strs[i].charAt(0);
    }
    return prefix;
}

public class TrieNode{
    public int pass;
    public int end;
    public TrieNode[] next;

    public TrieNode(){
      pass = 0;
      end = 0;
      next = new TrieNode[26];
    }
}

public class Trie{
    private TrieNode root;
    public Trie(){
      root = new TrieNode();
    }

    public String insert(String word){
        if(word == null){
          return &quot;&quot;;
        }
        char[] c = word.toCharArray();
        TrieNode node = root;
        node.pass++;
        int index = 0;
        int maxPass = 0;
        StringBuilder prefix = new StringBuilder();
        for(int i = 0; i &lt; c.length; i++){
          index = c[i] - 'a';
          if(node.next[index] == null){
            node.next[index] = new TrieNode();
          }
          node = node.next[index];
          node.pass++;
          if(node.pass &gt;= maxPass &amp;&amp; node.pass != 1){
            prefix.append(c[i]);
            maxPass = node.pass;
          }
        }
        node.end++;
        return prefix.toString();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-11 Container With Most Water]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-11-container-with-most-water/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-11-container-with-most-water/">
        </link>
        <updated>2020-06-01T13:01:17.000Z</updated>
        <content type="html"><![CDATA[<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, ..., <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
<figure data-type="image" tabindex="1"><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img" loading="lazy"></figure>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [1,8,6,2,5,4,8,3,7]
Output: 49
</code></pre>
<pre><code class="language-java">//solution
public int maxArea(int[] height) {
    int max = 0;
    for(int i = 0; i &lt; height.length; i++){
      for(int j = 1; j &lt; height.length; j++){
        if(Math.abs(j-i) * Math.min(height[i],height[j])&gt;max){
          max = Math.abs(j-i) * Math.min(height[i],height[j]);
        }
      }
    }
    return max;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-121 122 Best Time to Buy and Sell Stock]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-121-122-best-time-to-buy-and-sell-stock/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-121-122-best-time-to-buy-and-sell-stock/">
        </link>
        <updated>2020-06-01T12:59:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="leetcode-121">leetcode-121</h2>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://leetcode.com/media/original_images/121_profit_graph.png" alt="Profit Graph" loading="lazy"></figure>
<pre><code class="language-java">//solution
public int maxProfit(int prices[]) {
    int minprice = Integer.MAX_VALUE;
    int maxprofit = 0;
    for (int i = 0; i &lt; prices.length; i++) {
      if (prices[i] &lt; minprice)
        minprice = prices[i];
      else if (prices[i] - minprice &gt; maxprofit)
        maxprofit = prices[i] - minprice;
    }
    return maxprofit;
}
</code></pre>
<h2 id="leetcode-122">leetcode-122</h2>
<p>Say you have an array <code>prices</code> for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
</code></pre>
<pre><code class="language-java">//solution
public int maxProfit(int[] prices) {
    int i = 0;
    int valley = prices[0];
    int peak = prices[0];
    int maxprofit = 0;
    while (i &lt; prices.length - 1) {
      while (i &lt; prices.length-1 &amp;&amp; prices[i] &gt;= prices[i+1])
        i++;
      valley = prices[i];
      while (i &lt; prices.length-1 &amp;&amp; prices[i] &lt;= prices[i+1])
        i++;
      peak = prices[i];
      maxprofit += peak - valley;
    }
    return maxprofit;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-45 Jump Game II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-45-jump-game-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-45-jump-game-ii/">
        </link>
        <updated>2020-06-01T09:09:02.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre>
<p><strong>Note:</strong></p>
<p>You can assume that you can always reach the last index.</p>
<pre><code class="language-java">//暴力递归(超时未通过)
 public int jump(int[] nums) {
   r	eturn process(nums, 0, 0);
 }

public int process(int[] nums, int index, int step){
    if(index == nums.length - 1){
      return step;
    }

    int min = Integer.MAX_VALUE;
    int maxDis = Math.min(index+nums[index], nums.length-1);
    for(int i = index + 1; i &lt;= maxDis; i++){
      min = Math.min(process(nums, i, step + 1), min);
    }
    return min;
}

//严格表结构动态规划
public int jump(int[] nums) {
  	return process(nums);
}

public int process(int[] nums){
    int N = nums.length;
    int[] dp = new int[N];
    Arrays.fill(dp, Integer.MAX_VALUE / 2);
    dp[N - 1] = 0;

    for(int index = N - 2; index &gt;= 0; index--){
      int maxDis = Math.min(index + nums[index], N - 1);
      for(int i = maxDis; i &gt;= index + 1; i--){
        dp[index] = Math.min(dp[index], dp[i] + 1);   
      }
    }
    return dp[0];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-55 Jump Game]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-55-jump-game/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-55-jump-game/">
        </link>
        <updated>2020-06-01T06:45:22.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>0 &lt;= nums[i][j] &lt;= 10^5</code></li>
</ul>
<pre><code class="language-java">//暴力递归
//Time complexity: O(2^n)
//Space complexity: O(n)
public boolean canJump(int[] nums) {
  	return process(nums, 0);
}

public boolean process(int[] nums, int index){
    if(index == nums.length - 1){
      return true;
    }

    int maxDis = Math.min(index + nums[index], nums.length - 1);
    for(int i = index + 1; i &lt;= maxDis; i++){
      if(process(nums, i)){
        return true;
      }
    }
    return false;
}

//记忆化搜索
//Time complexity: O(n^2)
//Space complexity: O(n)
public boolean canJump(int[] nums) {
    int[] dp = new int[nums.length + 1];
    int res = process(nums, 0, dp);
    return res == 1 ? true : false;
}

public int process(int[] nums, int index, int[] dp){
    if(dp[index] != 0){
      return dp[index];
    }
    if(index == nums.length - 1){
      dp[index] = 1;
      return dp[index];
    }
    int maxDis = Math.min(index+nums[index], nums.length-1);
    for(int i = index + 1; i &lt;= maxDis; i++){
      dp[index] = process(nums, i, dp);
      if(dp[index] == 1){
        return dp[index];
      }
    }
    dp[index] = -1;
    return dp[index];
}

//严格表结构动态规划
//Time complexity: O(n^2)
//Space complexity: O(n)
public boolean canJump(int[] nums) {
    int res = process(nums);
    return res == 1 ? true : false;
}

public int process(int[] nums){
    int[] dp = new int[nums.length];
    dp[nums.length - 1] = 1;
    for(int index = nums.length - 2; index &gt;= 0; index--){
      int maxDis = Math.min(index+nums[index], nums.length-1);
      for(int i = index + 1; i &lt;= maxDis; i++){
        if(dp[i] == 1){
          dp[index] = 1;
          break;
        }
      }
    }
    return dp[0];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-275 H-Index II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-275-h-index-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-275-h-index-ii/">
        </link>
        <updated>2020-06-01T06:44:30.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of citations <strong>sorted in ascending order</strong> (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index">definition of h-index on Wikipedia</a>: &quot;A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each.&quot;</p>
<p><strong>Example:</strong></p>
<pre><code>Input: citations = [0,1,3,5,6]
Output: 3 
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had 
             received 0, 1, 3, 5, 6 citations respectively. 
             Since the researcher has 3 papers with at least 3 citations each and the remaining 
             two with no more than 3 citations each, her h-index is 3.
</code></pre>
<p><strong>Note:</strong></p>
<p>If there are several possible values for <em>h</em>, the maximum one is taken as the h-index.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/h-index/description/">H-Index</a>, where <code>citations</code> is now guaranteed to be sorted in ascending order.</li>
<li>Could you solve it in logarithmic time complexity?</li>
</ul>
<pre><code class="language-java">//solution
public int hIndex(int[] citations) {
    if(citations.length == 0){
      return 0;
    }

    int N = citations.length;
    int H = 0;
    for(int i = N - 1; i &gt;= 0; i--){
      int num = N - i;
      if(citations[i] &gt;= num){
        H = num;
      }
    }
    return H;
}
</code></pre>
<p>注：</p>
<p>定义变量  num表示每个数在citations中对应的比自己大的数的个数（引用论文次数大于等于自己被引用的次数     的总的篇数），比如0对应的num就是5，因为比0大或等的数的个数为5。因此，citations对应的num为：</p>
<p>citations：0    1     3     5      6</p>
<p>num:         5     4     3     2       1</p>
<p>“代表他（她）的 N 篇论文中至多有 h 篇论文，分别被引用了至少 h 次“，仔细分析这句话”至多有 h 篇论文“表示的是num[i]对就的数，”分别被引用了至少 h 次“表示的是citations[i]，则num[i]&lt;=citations[i]才满足条件。此处满足条件的是citations=[3,5,6]，对应的num=[3,2,1]。而我们只需要取num的最大值就可以了。<br>
————————————————<br>
版权声明：本文为CSDN博主「lear_scu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/qq_36327328/java/article/details/83117379</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-274 H-Index]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-274-h-index/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-274-h-index/">
        </link>
        <updated>2020-06-01T06:43:53.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index">definition of h-index on Wikipedia</a>: &quot;A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em>papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each.&quot;</p>
<p><strong>Example:</strong></p>
<pre><code>Input: citations = [3,0,6,1,5]
Output: 3 
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had 
             received 3, 0, 6, 1, 5 citations respectively. 
             Since the researcher has 3 papers with at least 3 citations each and the remaining 
             two with no more than 3 citations each, her h-index is 3.
</code></pre>
<p><strong>Note:</strong> If there are several possible values for <em>h</em>, the maximum one is taken as the h-index.</p>
<pre><code class="language-java">//solution
public int hIndex(int[] citations) {
    int n = citations.length;
    int[] buckets = new int[n+1];
    for(int c : citations) {
        if(c &gt;= n) {
            buckets[n]++;
        } else {
            buckets[c]++;
        }
    }
    int count = 0;
    for(int i = n; i &gt;= 0; i--) {
        count += buckets[i];
        if(count &gt;= i) {
            return i;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-134 Gas Station]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-134-gas-station/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-134-gas-station/">
        </link>
        <updated>2020-05-31T15:12:33.000Z</updated>
        <content type="html"><![CDATA[<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p><strong>Note:</strong></p>
<ul>
<li>If there exists a solution, it is guaranteed to be unique.</li>
<li>Both input arrays are non-empty and have the same length.</li>
<li>Each element in the input arrays is a non-negative integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
</code></pre>
<pre><code class="language-java">//my submission
public class GasNode{
    int gas;
    int cost;
    int index;
    GasNode next;
    public GasNode(int gas, int cost, int index){
      this.gas = gas;
      this.cost = cost;
      this.index = index;
    }
}

public int canCompleteCircuit(int[] gas, int[] cost) {
        
    //generate GasNode List
    GasNode head = new GasNode(gas[0], cost[0], 0);
    GasNode cur = head;
    for(int j = 1; j &lt; gas.length; j++){
      cur.next = new GasNode(gas[j], cost[j], j);
      cur = cur.next;
    }
    cur.next = head;

    //start from every station
    for(int i = 0; i &lt; gas.length; i++){
      GasNode node = head;
      int restGas = node.gas;
      while(restGas &gt;= node.cost){
        restGas -= node.cost;
        node = node.next;
        restGas += node.gas;
        if(node == head){
          return head.index;
        }
      }   
      head = head.next; 
    }
    return -1;
}
</code></pre>
]]></content>
    </entry>
</feed>