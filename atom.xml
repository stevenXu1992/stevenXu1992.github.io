<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Gridea</title>
    <updated>2020-05-25T06:34:21.950Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[特殊结构]]></title>
        <id>https://stevenXu1992.github.io/post/te-shu-jie-gou/</id>
        <link href="https://stevenXu1992.github.io/post/te-shu-jie-gou/">
        </link>
        <updated>2020-05-25T06:33:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1滑动窗口">1.滑动窗口</h2>
<pre><code class="language-java">//窗口结构（最大值）
public static class WindowMax{
  private int L;
  private int R;
  private int[] arr;
  //队列中存放数组的下标，peekfirst最大值
  private LinkedList&lt;Integer&gt; queue; 
  
  //初始化窗口
  public WindowMax(int[] arr){
    this.arr = arr;
    L = -1;
    R = 0;
    queue = new LinkedList&lt;&gt;(); 
  }
  
  //窗口右边界移动
  public void shiftRight(){
    if(R == arr.length){
      return;
    }
    while(!queue.isEmpty() &amp;&amp; arr[queue.peekLast()]&lt;=arr[R]){
      queue.pollLast();
    }
    queue.addLast(R);
    R++;
  }
  
  //窗口左边界移动
  public void shiftLeft(){
    if(L &gt; R - 1){
      return;
    }
    L++;
    if(queue.peekFirst() == L){
      queue.pollFirst();
    }
  }
  
  //获取窗口内最大值
  public int getMax(){
    if(!queue.isEmpty()){
      return arr[queue.peekFirst()];
    }
    return null;
  }
}

//请实现一个函数。 输入:整型数组arr，窗口大小为w。 输出:一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值
public static int[] getMaxInWindow(int[] arr, int w){
  if(arr == null || w &lt; 1 || arr.length &lt; w){
    return null;
  }
  LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
  int[] res = new int[arr.length - w + 1];
  int index = 0;
  for(int i = 0; i &lt; arr.length; i++){
    //窗口右边界向右滑动
    while(!queue.isEmpty() &amp;&amp; arr[queue.peekLast()] &lt;=arr[i]){
      queue.pollLast();
    }
  	queue.addLast(i);
    //窗口左边界向右滑动
    if(queue.peekFirst() == i - w){ 
      //i-w：过期的点，刚从窗口中出来的点，判断该点是否是队列的first
      queue.pollFirst();
    }
    //保存最大值信息
    if(i &gt;= w - 1){
      res[index++] = queue.peekFirst();
    }
  }
  return res;
}
</code></pre>
<h2 id="2单调栈">2.单调栈</h2>
<p>在数组中想找到一个数，左边和右边比这个数小、且离这个数最近的位置。如果对每一个数都想求这样的信息，能不能整体代价达到O(N)?</p>
<pre><code class="language-java">public static int[][] monotonousStack1(int[] arr){
  if(arr == null || arr.length &lt; 1){
    return null;
  }
  int[][] res = new int[arr.length][2];
  //单调栈顶为最大值,栈内存储数组的下标
  Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
  for(int i = 0; i &lt; arr.length; i++){
    //若新加元素小于栈顶，则弹出栈顶元素并记录结果
    while(!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]){
      int popIndex = stack.pop();
      int leftIndex = stack.isEmpty() ? -1 : stack.peek();
      res[popIndex][0] = leftIndex;
      res[popIndex][1] = i;
    }
    stack.push(i);
  }
  //加完全部元素并记录了结果后，弹出剩下的元素并记录
  while(!stack.isEmpty()){
    int popIndex = stack.pop();
    int leftIndex = stack.isEmpty() ? -1 : stack.peek();
    res[popIndex][0] = leftIndex;
    res[popIndex][1] = -1;
  }
  return res;
}

//数组中有重复的元素
public static int[][] monotonousStack2(int[] arr){
  Stack&lt;List&lt;Integer&gt;&gt; stack = new Stack&lt;&gt;();
  int[][] res = new int[arr.length][2];
  for(int i = 0; i &lt; arr.length; i++){
    //新加元素小于栈顶
    	while(!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){
        int popIndex = stack.pop();
        int leftIndex = stack.isEmpty() ? 
          -1 : stack.peek().get(stack.peek().size() - 1);
        res[popIndex][0] = leftIndex;
        res[popIndex][1] = i;
      }
    //新加元素等于栈顶
    if(arr[i] == arr[stack.peek().get(0)]{
      stack.peek().add(Integer.valueOf(i));
    }else{
      //新加元素大于栈顶
      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
      list.add(i);
      stack.push(list);
    }
  }
  //加完全部元素并记录了结果后，弹出剩下的元素并记录
  while(!stack.isEmpty()){
    List&lt;Integer&gt; restList = stack.pop();
    int leftIndex = stack.isEmpty() ? 
      -1 : stack.peek().get(stack.peek().size() - 1);
    for(Integer i : restList){
      res[i][0] = leftIndex;
      res[i][1] = -1;
    }
  }
  return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串算法]]></title>
        <id>https://stevenXu1992.github.io/post/zi-fu-chuan-suan-fa/</id>
        <link href="https://stevenXu1992.github.io/post/zi-fu-chuan-suan-fa/">
        </link>
        <updated>2020-05-23T17:17:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-前缀树">1. 前缀树</h2>
<pre><code class="language-java">public static class TrieNode{
  public int pass;
  public int end;
  public TrieNode[] nexts;
  
  public TrieNode(){
    pass = 0;
    end = 0;
    nexts = new TrieNode[26];
  }
}

public static class Trie{
  private TrieNode root;
  public Trie(){
    root = new TrieNode();
  }
  
  //加入单词
  public static void insert(String word){
    if(word == null){
      return;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    node.pass++;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        node.nexts[index] = new TrieNode();
      }
      node = node.nexts[index];
      node.pass++;
    }
    node.end++;
  }
  
  //查询某单词加过几次
  public static int search(String word){
    if(word == null){
      return 0;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        return 0;
      }
      node = node.nexts[index];
    }
    return node.end;
  }
  
  //查询某前缀加过几次
  public static int searchPrefix(String word){
    if(word == null){
      return 0;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        return 0;
      }
      node = node.nexts[index];
    }
    return node.pass;
  }
  
  //删除单词
  public static void delete(String word){
    if(search(word) == 0){
      return;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    node.pass--;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(--node.nexts[index].pass == 0){
        node.nexts[index] == null;
        return;
      }
    }
    node.end--;
  }
  
}
</code></pre>
<h2 id="2-kmp">2. KMP</h2>
<pre><code class="language-java">public static int KMP(String str1, String str2){
  if(str1 == null || str2 == null || 
     str2.length &gt; str1.length || str2.length() &lt; 1){
    return -1;
  }
  char[] char1 = str1.toCharArray();
  char[] char2 = str2.toCharArray();
  int[] next = getNext(char2);
  int i1 = 0;
  int i2 = 0;
  
  while(i1 &lt; char1.length &amp;&amp; i2 &lt; char2.length){
    if(char1[i1] == char2[i2]){
      i1++;
      i2++;
    }else if(i2 == 0){
      i1++;
    }else{
      i2 = next[i2];
    }
  }
  return i2 == char2.length ? i1 - i2 : -1;
}

//获取每个字符之前的最大相同前缀后缀的长度
public static int[] getNext(char[] chars){
  if(chars.length == 1){
    return new int[]{-1};
  }
  
  int[] next = new int[chars.length];
  next[0] = -1;
  next[1] = 0;
  int index = 2;
  int cn = 0;
  
  while(index &lt; next.length){
    if(chars[index - 1] == chars[cn]){
      next[index++] = cn++;
    }else(cn &gt; 0){
      cn = next[cn];
    }else{
      next[index++] = 0;
    }
  }
  return next;
}
</code></pre>
<h2 id="3-manacher">3. Manacher</h2>
<pre><code class="language-java">public static int manacher(String str){
  if(str == null || str.length == 1){
    return 0;
  }
  char[] chars = getManacherString(str);
  int[] help = new int[chars.length];
  int R = -1;	//R为已找到的最大回文区域的右边界
  int C = -1;	//C为最大回文区域的中心点
  int max = Integer.MIN_VALUE;
  for(int i = 0; i != chars.length; i++){
    
    //情况1: i超出已知的最大回文区域右边界，正常向两边寻找回文区域
    //情况2: i在已知的最大回文区域右边界内部
    //	1）i'的回文区域不超过最大回文区域的左边界：与i相同
    //	2）i'的回文区域超过最大回文区域的左边界：与R-i相同
    //	3）i'的回文区域正好在最大回文区域的左边界上：在R-i的基础上正常向两边寻找回文区域
    //2 * C - i 为 i'
    help[i] = R &gt; i ? Math.min(help[2 * C - i], R - i) : 1;
    while(i + help[i] &lt; chars.length &amp;&amp; i - help[i] &gt; -1){
      if(chars[i + help[i]] == chars[i - help[i]]){
        help[i]++;
      }else{
        break;
      }
    }
    //更新R和C
     if(i + help[i] &gt; R){
        R = i + help[i];
        C = i;
      }
      max = Math.max(max, help[i]);
  }
  return max - 1;
}

public static char[] getManacherString(String str){
  char[] chars = str.toCharArray();
  char[] res = new char[str.length * 2 - 1];
  int index = 0;
  for(int i = 0; i &lt; chars.length; i++){
    res[i] = (i &amp; 1) == 0 ? '#' : chars[index++];
  }
  return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集]]></title>
        <id>https://stevenXu1992.github.io/post/bing-cha-ji/</id>
        <link href="https://stevenXu1992.github.io/post/bing-cha-ji/">
        </link>
        <updated>2020-05-23T06:56:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-并查集结构">1. 并查集结构</h2>
<pre><code class="language-java">public class UnionFind{
  
  //并查集元素
  public static class Element&lt;V&gt;{
    public V value;
    public Element(V value){
      this.value = value;
    }
  } 
  
  //并查集初始化
  public static class UnionSet{
    HashMap&lt;V, Element&lt;V&gt;&gt; elementMap;
    HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;
    HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap;
    
    public UnionSet&lt;V&gt;(List&lt;V&gt; list){
      elementMap = new HashMap&lt;&gt;();
      fatherMap = new HashMap&lt;&gt;();
      sizeMap = new HashMap&lt;&gt;();
      for(V v: list){
        Element&lt;V&gt; e = new Element&lt;&gt;(v);
        elementMap.put(v, e);
        fatherMap.put(e, e);
        sizeMap.put(e, 1);
      }
    }
  }
  
  //判断是否属于同一集合
  public static boolean same(V v1, V v2){
    if( elementMap.containsKey(v1)
     &amp;&amp; elementMap.containsKey(v2)){
      	return findHead(elementMap.get(v1)) 
          ==  findHead(elementMap.get(v2));	
    	}
    return false;
  }
  
  
  //集合合并
  public static void union(V v1, V v2){
    if(elementMap.containsKey(v1)
     &amp;&amp; elementMap.containsKey(v2)){
      Element&lt;V&gt; head1 = findHead(elementMap.get(v1));
      Element&lt;V&gt; head2 = findHead(elementMap.get(v2));
      if(head1 != head2){
        Element&lt;V&gt; big = 
          sizeMap.get(head1) &gt;= sizeMap.get(head2) ?
          head1 : head2;
        Element&lt;V&gt; small = big == head1 ? head2 : head1:
        fatherMap.put(small, big);
        sizeMap.put(big,sizeMap.get(big)+sizeMap.get(small));
        sizeMap.remove(small);
      }
    }
  }
  
  
  //查找头元素
  private static Element&lt;V&gt; findHead(Element&lt;V&gt; e){
    Stack&lt;Element&lt;V&gt;&gt; stack = new Stack&lt;&gt;();
    while(e != fatherMap.get(e)){
      stack.push(e);
      e = fatherMap.get(e);
    }
    while(!stack.isEmpty()){
      fatherMap.put(stack.pop(), e);
    }
    return e;
  }  
  
}
</code></pre>
<h2 id="2kruskal最小生成树">2.Kruskal最小生成树</h2>
<pre><code class="language-java">//优先级队列的比较器，权重小的边先出
public static class myComparator implements Comparator&lt;edge&gt;{
  public int compare(Edge o1, Edge o2){
    return o1.weight - o1.weight;
  }
}

public static Set&lt;Edge&gt; kruskal(Graph graph){
  List&lt;Node&gt; list = (List&lt;Node&gt;)graph.nodes.values();
  UnionSet&lt;Node&gt; unionSet = new unionSet&lt;&gt;(List);
  PriorityQueue&lt;Edge&gt; queue = 
    new PriorityQueue&lt;&gt;(new myComparator());
  for(Edge e : graph.edges){
    queue.add(e);
  }
  
  HashSet&lt;Edge&gt; res = new HashSet&lt;&gt;();
  while(!queue.isEmpty()){
    Edge e = queue.poll();
    if(!unionSet.same(e.from, e.to)){
      res.add(e);
      unionSet.union(e.from, e.to);
    }
  }
  return res;
  
}
</code></pre>
<h2 id="3-岛问题的并行算法设计">3. 岛问题的并行算法设计</h2>
<pre><code class="language-java">public static int island(int[][] matrix){
  if(matrix == null || matrix[0] == null){
    return 0;
  }
  
  int length = matrix.length;
  int width = matrix[0].length;
  int res = 0;
  
  for(int i = 0; i &lt; length; i++){
    for(int j = 0; j &lt; width; j++){
      if(matrix[i][j] == 1){
        res++;
        infect(matrix, i, j, length, width);
      }
    }
  }
}

public static void infect(int[] matrix, int i, int j, int length, int width){
  if(i &lt; 0 || i &gt;= length || j &lt; 0 || j &gt;= width 
     || matrix[i][j] != 1){
    return;
  }
  	matrix[i][j] = 2;
    infect(matrix, i + 1, j, length, width);
    infect(matrix, i - 1, j, length, width);
    infect(matrix, i, j + 1, length, width);
    infect(matrix, i, j - 1, length, width);
  
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[暴力递归]]></title>
        <id>https://stevenXu1992.github.io/post/bao-li-di-gui/</id>
        <link href="https://stevenXu1992.github.io/post/bao-li-di-gui/">
        </link>
        <updated>2020-05-21T09:31:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-汉诺塔">1. 汉诺塔</h2>
<pre><code class="language-java">public static void hannoi(int n){
  process(n, &quot;from&quot;, &quot;to&quot;, &quot;help&quot;);
} 

public static void process(int n, String from, String to, String help){
  if(n == 1){
    System.out.println(&quot;move&quot; + from + &quot;to&quot; + to);
  }else{
    process(n - 1, from, help, to);
    process(1, from, to, help);
    process(n - 1, help, to, from);
  }
}
</code></pre>
<h2 id="2-字符串子序列">2. 字符串子序列</h2>
<pre><code class="language-java">public static List&lt;String&gt; subSequence(String str){
  List&lt;String&gt; res = new ArrayList&lt;&gt;();
  if(str == null){
    return res;
  }
  if(str.length() == 0){
    res.add(&quot;&quot;);
    return res;
  }
  
  char[] chars = str.toCharArray();
  process(res, chars, &quot;&quot;, 0);
}

public static List&lt;String&gt; process(List&lt;String&gt; list, char[] chars, String path, int index){
  if(index == chars.length){
    list.add(path);
  }else{
    process(list, chars, path, index + 1);
    process(list, chars, path + String.valueOf(chars[index]), index + 1);
  }
}
</code></pre>
<h2 id="3字符串全排列">3.字符串全排列</h2>
<pre><code class="language-java">public static List&lt;String&gt; allArray(String str){
  List&lt;String&gt; res = new ArrayList&lt;&gt;();
  ArrayList&lt;String&gt; set = new ArrayList&lt;&gt;();
  char[] chars = str.toCharArray();
  for(char c : chars){
    set.add(c);
  }
  process(set, &quot;&quot;, res);
  return res;
}

public static void process(ArrayList&lt;String&gt; set, String path, List&lt;String&gt; list){
  if(set.isEmpty()){
    list.add(path);
  }
  HashSet&lt;Character&gt; picked = new HashSet&lt;&gt;();
  for(int i = 0; i &lt; set.size(); i++){
    if(!picked.contains(set.get(i))){
      picked.add(set.get(i));
      String newPath = path + set.get(i);
      ArrayList&lt;String&gt; next = new ArrayList&lt;&gt;(set);
      next.remove(i);
      process(next, newPath, list);
    }
  }
}
</code></pre>
<h2 id="4背包问题">4.背包问题</h2>
<pre><code class="language-java">public static int backpack(int[] weights, int[] values, int index, int weighted, int bagLimit){
  if(weighted &gt; bagLimit){
    return 0;
  }
  if(index &gt; weights.length){
    return 0;
  }
  Math.max(
    backpack(weights, values, index + 1, weighted, bagLimit),
  	backpack(weights, values, index + 1, weighted + weights[index], bagLimit) + values[index]
  );
}
</code></pre>
<h2 id="5纸牌问题">5.纸牌问题</h2>
<pre><code class="language-java">public static int maxWinSorce(int[] arr){
  if(arr == null){
    return 0;
  }
  return Math.max(
    firstHand(arr, 0, arr.length - 1),)
    secondHand(arr, 0, arr.length - 1);
}

public static int firstHand(int[] arr, int left, int right){
  if(left == right){
    return arr[left];
  }
  Math.max(
    arr[left] + secondHand(arr, left + 1, right),
  	arr[right] + secondHand(arr, left, right -1)
  );
}

public static int secondHand(int[] arr, int left, int right){
  if(left == right){
    return 0;
  }
  Math.min(
    firstHand(arr, left + 1, right),
  	firstHand(arr, left, right -1)
  );
}
</code></pre>
<h2 id="6n皇后">6.N皇后</h2>
<pre><code class="language-java">public static int NQueen(int n){
  if(n &lt; 1){
    return 0;
  }
  return process(0, new int[n], n);
}

public static int process(int index, int[] record, int n){
  if(index == n){
    return 1;
  }
  int res = 0;
  for(int j = 0; j &lt; n; j++){
    if(valid(record, index, j)){
      record[index] = j;
      res += process(index + 1, record, n);
    }
  }
  return res;
}

public static boolean valid(int[] record, int index, int j){
  for(int k = 0; k &lt; index; k++){
    if(record[k] == j || Math.abs(record[k] - j) == Math.abs(i - k)){return false;}
  }
  return true;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图的经典算法]]></title>
        <id>https://stevenXu1992.github.io/post/tu-de-jing-dian-suan-fa/</id>
        <link href="https://stevenXu1992.github.io/post/tu-de-jing-dian-suan-fa/">
        </link>
        <updated>2020-05-18T06:00:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-模版">1. 模版</h2>
<pre><code class="language-java">public class Graph{
  public HashMap&lt;Integer, Node&gt; nodes;
  public HashSet&lt;Edge&gt; edges;
  public Graph(){
    nodes = new HashMap&lt;&gt;();
    edges = new HashSet&lt;&gt;();
  }
}

public class Node{
  public int value;
  public int in;
  public int out;
  public ArrayList&lt;Node&gt; nexts;
  public ArrayList&lt;Edge&gt; edges;
  public Node(int data){
    this.value = data;
    in = 0;
    out = 0;
    nexts = new ArrayList&lt;&gt;();
    edges = new ArrayList&lt;&gt;();
  }
}

public class Edge{
  public int weight;
  public Node from;
  public Node to;
  public Edge(int weight, Node from, Node to){
    this.weight = weight;
    this.from = from;
    this.to = to;
  }
}
</code></pre>
<h2 id="2-图的遍历">2. 图的遍历</h2>
<h3 id="21-宽度优先遍历">2.1 宽度优先遍历</h3>
<pre><code class="language-java">public static void BFS(Node node){
  if(node == null){
    return;
  }
  LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();
  HashSet&lt;Node&gt; set = new HashSet&lt;&gt;();
  queue.add(node);
  set.add(node);
  while(!queue.isEmpty()){
    Node cur = queue.poll();
    //具体遍历操作
    for(Node n : cur.nexts){
      if(!set.contains(n)){
        queue.add(n);
        set.add(n);
      }
    }
  }
}
</code></pre>
<h3 id="22-深度优先遍历">2.2 深度优先遍历</h3>
<pre><code class="language-java">public static void DFS(Node node){
  if(node == null){
    return;
  }
  Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
  HashSet&lt;Node&gt; set = new HashSet&lt;&gt;();
  stack.push(node);
  set.add(node);
  //具体遍历操作
  while(!stack.isEmpty()){
    Node cur = stack.pop();
    for(Node n : cur.nexts){
      if(!set.contains(n)){
        stack.push(cur);
        stack.push(n);
        set.add(n);
        //具体遍历操作
        break;
      }
    }
  }
}
</code></pre>
<h2 id="3拓扑排序">3.拓扑排序</h2>
<pre><code class="language-java">public static List&lt;Node&gt; topologySort(Graph graph){
  HashMap&lt;Node, Integer&gt; map = new HashMap&lt;&gt;();
  LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();
  ArrayList&lt;Node&gt; list = new ArrayList&lt;&gt;();
  
  for(Node n : graph.nodes.values()){
    map.put(n, n.in);
    if(n.in == 0){
      queue.add(n);
    }
  }
  
  while(!queue.isEmpty()){
    Node cur = queue.pop();
    list.add(cur);
    for(Node n : cur.nexts){
      map.put(n, map.get(n) - 1);
      if(map.get(n) == 0){
        queue.add(n);
      }
    }
  }
  return list;
}
</code></pre>
<h2 id="4-prim算法">4. Prim算法</h2>
<pre><code class="language-java">public static class EdgeComparator implements Comparator&lt;Edge&gt;{
  public int compare(Edge o1, Edge o2){
    //自定义比较器:
    // o1 - o2 &lt; 0 : o1 --&gt; o2
    // o2 - o1 &lt; 0 : o2 --&gt; o1       
    return o1.weight - o2.weight;
  }
}

public static Set&lt;Edge&gt; prim(Graph graph){
  PriorityQueue&lt;Edge&gt; queue = new PriorityQueue&lt;&gt;();
  HashSet&lt;Node&gt; set = new HashSet&lt;Node&gt;();
  HashSet&lt;Edge&gt; res = new HashSet&lt;Edge&gt;();
  
  for(Node node : graph.nodes.values()){
    if(!set.contains(node)){
      set.add(node);
      for(Edge edge : node.edges){
        queue.add(edge);
      }
      while(!queue.isEmpty()){
        Edge edge = queue.poll();
        if(!set.contains(edge.to)){
          res.add(edge);
          set.add(edge.to);
          for(Edge e : edge.to.edges){
            queue.add(e);
          }
        }
      }
    }
  }
  return res;
}
</code></pre>
<h2 id="5-dijkstra算法">5. Dijkstra算法</h2>
<pre><code class="language-java">public static HashMap&lt;Node, Integer&gt; dijkstra(Node head){
  
  //distanceMap: 存储出发点至其他各点的距离
  HashMap&lt;Node, Integer&gt; distanceMap = new HashMap&lt;&gt;();
  //lockedSet: 用于记录已锁定的点
  HashSet&lt;Node&gt; lockedSet = new HashSet&lt;&gt;();
  distanceMap.put(head, 0);
  //unlockedMinNode: 找出distanceMap中距离最小且未锁定的点
  Node minNode = unlockedMinNode(distanceMap, lockedSet);
  
  while(minNode != null){
    int dis = distanceMap.get(minNode);
    for(Edge edge : minNode.edges){
      if(!distanceMap.containsKey(edge.to)){
        distanceMap.put(edge.to, dis + edge.weight);
      }
      //若distanceMap中已存在，则比较原距离和新发现的边所更新的距离
      distanceMap.put(edge.to, 
                      Math.min(distanceMap.get(edge.to), 
                      				 dis + edge.weight));
    }
    lockedSet.add(minNode);
    minNode = unlockedMinNode(distanceMap, lockedSet);
  }
  return distanceMap;
}

public static Node unlockedMinNode(
  HashMap&lt;Node, Integer&gt; disMap, HashSet&lt;Node&gt; lockedSet){
  Node minNode = null;
  int minDis = Integer.MAX_VALUE;
  for(Map.Entry&lt;Node, Integer&gt; entry : disMap.entrySet()){
    Node n = entry.getKey();
    int dis = entry.getValue();
    if(!lockedSet.contains(n) &amp;&amp; dis &lt; minDis){
      minNode = n;
      minDis = dis;
    }
  }
  return minNode;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表的常见算法]]></title>
        <id>https://stevenXu1992.github.io/post/lian-biao-chang-jian-ti-mu/</id>
        <link href="https://stevenXu1992.github.io/post/lian-biao-chang-jian-ti-mu/">
        </link>
        <updated>2020-05-17T14:23:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1反转链表">1.反转链表</h2>
<pre><code class="language-java">//单向链表的反转
public static class Node{
  int value;
  Node next;
  public Node(int data){
    this.value = data;
  }
}

public static Node reverse(Node head){
  Node pre = null;
  Node next = null;
  while(head != null){
    next = head.next;
    head.next = pre;
    pre = head;
    head = next;
  }
  return pre;
}

//双向链表的反转
public static class DoubleNode{
  int value;
  DoubleNode next;
  DoubleNode last;
  public Double(int data){
    this.value = data;
  }
}

public static Node reverse(DoubleNode head){
  DoubleNode pre = null;
  DoubleNode next = null;
  while(head != null){
    next = head.next;
    head.next = pre;
    head.last = next;
    pre = head;
    head = next;
  }
  return pre;
}
</code></pre>
<h2 id="2判断是否为回文结构">2.判断是否为回文结构</h2>
<pre><code class="language-java">public static boolean palindrome1(Node head){
  Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
  Node cur = head;
  while(cur != null){
    stack.push(cur);
    cur = cur.next;
  }
  while(!stack.isEmpty()){
    Node n = stack.pop();
    if(head.value != n.value){
      return false;
    }
    head = head.next;
  }
  return true;
}

public static boolean palindrome2(Node head){
  Node slow = head.next;
  Node fast = head;
  while(slow.next != null &amp;&amp; fast.next.next != null){
    slow = slow.next;
    fast = fast.next.next;
  }
  Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
  while(slow != null){
    stack.push(slow);
    slow = slow.next;
  }
  while(!stack.isEmpty()){
    Node n = stack.pop();
    if(n.value != head.value){
      return false;
    }
    head = head.next;
  }
  return true;
}

public static boolean palindrome3(Node head){
  Node slow = head;
  Node fast = head;
  while(slow.next != null &amp;&amp; fast.next.next != null){
    slow = slow.next;
    fast = fast.next.next;
  }
  
  //此时slow停在中点，复用fast指针反转链表
  fast = slow.next;
  slow.next = null;
  Node next = null;
  while(fast != null){
    next = fast.next;
    fast.next = slow;
    slow = fast;
    fast = next;
  }
  
  //反转完成，此时slow在尾部,fast为null，开始判断
  Node end = slow; //记录尾部节点，复原使用
  boolean res = true;
  while(head != null &amp;&amp; slow != null){
    if(head.value != slow.value){
      res = false;
    }
    head = head.next;
    slow = slow.next;
  }
  
  //复原链表,复用fast指针
  fast = end.next;
  end.next = null;
  while(fast != null){
    next = fast.next;
    fast.next = end;
    end = fast;
    fast = next;
  }
  return res;
}
</code></pre>
<h2 id="3-链表的荷兰国旗问题">3. 链表的荷兰国旗问题</h2>
<pre><code class="language-java">public static Node flag(Node head, int pivot){
  
  Node sHead = null;
  Node sTail = null;
  
  Node eHead = null;
  Node eTail = null;
  
  Node bHead = null;
  Node bTail = null;
  
  while(head != null){
    if(head.value &lt; pivot){
      if(sHead == null){
        sHead = head;
        sTail = head;
      }else{
        sTail.next = head;
        sTail = head;
      }
    }else if(head.value &gt; pivot){
      if(bHead == null){
        bHead = head;
        bTail = head;
      }else{
        bTail.next = head;
        bTail = head;
      }
    }else{
      if(eHead == null){
        eHead = head;
        eTail = head;
      }else{
        eTail.next = head;
        eTail = head;
      }
    }
    head = head.next;
  }
  
  if(sTail != null){
    sTail.next = eHead;
    eTail = eTail == null ? sTail : eTail;
  }
  
  if(eTail != null){
    eTail.next = bHead;
  }
  
  return sHead != null ? 
    		 sHead : eHead != null ? eHead : bHead; 
}
</code></pre>
<h2 id="4带随机指针的链表复制">4.带随机指针的链表复制</h2>
<pre><code class="language-java">public static Node copy1(Node head){
  HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();
  Node cur = head;
  while(cur != null){
    map.put(cur, new Node(cur.value));
    cur = cur.next;
  }
  cur = head;
  while(cur != null){
    map.get(cur).next = map.get(cur.next);
    map.get(cur).random = map.get(cur.random);
    cur = cur.next;
  }
  return map.get(head);
}

public static Node copy2(Node head){
  
  //先按照next指针在原链表中每个节点后面复制对应节点
  Node cur = head;
  Node next = null;
  while(cur != null){
    next = cur.next;
    cur.next = new Node(cur.value);
    cur.next.next = next;
    cur = next;
  }
  
  //复制原链表的random指针
  cur = head;
  Node copy = null;
  while(cur != null){
    next = cur.next.next;
    copy = cur.next;
    copy.random = cur.random != ? cur.random.next : null;
    cur = next;
  }
  
  //将原链表与复制好的链表分离
  Node res = head.next;
  cur = head;
  while(cur != null){
    next = cur.next.next;
    copy = cur.next;
    cur.next = next;
    copy.next = next != null ? next.next : null;
    cur = next;
  }
  return res;
}
</code></pre>
<h2 id="5链表相交相关问题">5.链表相交相关问题</h2>
<p>判断两个链表是否相交，若相交返回相交节点</p>
<pre><code class="language-java">public static Node intersection(Node head1, Node head2){
  if(head1 == null || head2 == null){
    return null;
  }
  Node loop1 = getLoop(head1);
  Node loop2 = getLoop(head2);
  //1.若两个链表都无环
  if(loop1 == null &amp;&amp; loop2 == null){
    return noLoop(head1, head2);
  }
  //2.若一个有环，一个无环，必定不相交
  //3.若两个链表都有环
  if(loop1 != null &amp;&amp; loop2 != null){
    return bothLoop(head1, loop1, head2, loop2);
  }
  return null;
}

//判断一个链表是否有环并返回入环节点
public static Node getLoop(Node head){
  if(head == null || head.next == null 
     || head.next.next == null){
    return null;
  }
  Node slow = head.next;
  Node fast = head.next.next;
  while(slow != fast){
    slow = slow.next;
    fast = fast.next.next;
  }
  fast = head;
  while(slow != fast){
    slow = slow.next;
    fast = fast.next;
  }
  return fast;
}

//都无环
public static Node noLoop(Node head1, Node head2){
  Node cur1 = head1;
  Node cur2 = head2;
  int length = 0;
  //分别找出两个链表的尾部,length用于求长度的差值
  while(cur1.next != null){
    length++;
    cur1 = cur1.next;
  }
  while(cur2.next != null){
    length--;
    cur2 = cur2.next;
  }
  //只有尾节点相同才会相交
  if(cur1 == cur2){
    cur1 = length &gt; 0 ? head1 : head2; //cur1指向更长链表的头部
    cur2 = cur1 == head1 ? head2 : head1;
    length = Math.abs(length);
    while(length != 0){
      length--;
      cur1 = cur1.next;
    }
    while(cur1 != cur2){
      cur1 = cur1.next;
      cur2 = cur2.next;
    }
    return cur1;
  }else{
    return null;
  }
}

//都有环
public static Node bothLoop(
  Node head1, Node loop1, Node head2, Node loop2){
  Node cur1 = null;
  Node cur2 = null;
  //若入环节点相同，则类似于无环相交的情况
  if(loop1 == loop2){
    cur1 = head1;
    cur2 = head2;
    int length = 0;
    while(cur1 != loop1){
      length++;
      cur1 = cur1.next;
    }
    while(cur2 != loop2){
      length--;
      cur2 = cur.next;
    }
    cur1 = length &gt; 0 ? head1 : head2;
    cur2 = cur1 == head1 ? head2 : head1;
    length = Math.abs(length);
    while(length != 0){
      length--;
      cur1 = cur1.next;
    }
    while(cur1 != cur2){
      cur1 = cur1.next;
      cur2 = cur2.next;
    }
    return cur1;
  }else{
    cur1 = loop1.next;
    while(cur1 != loop1){
      if(cur1 == loop2){
        return loop1;
      }
      cur1 = cur1.next;
    }
    return null;
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://stevenXu1992.github.io/post/pai-xu-suan-fa/</id>
        <link href="https://stevenXu1992.github.io/post/pai-xu-suan-fa/">
        </link>
        <updated>2020-05-15T13:37:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1冒泡排序">1.冒泡排序</h2>
<pre><code class="language-java">public static void bubbleSort(int[] arr){
  if(arr.length &lt; 2 || arr == null){
    return;
  }
  //大数冒泡
  for(int i = arr.length - 1; i &gt; 0; i--){
    for(int j = 0; j &lt; i; j++){
      if(arr[j] &gt; arr[j + 1]){
        swap(arr, j, j + 1);
      }
    }
  }
  
  //小数冒泡
  for(int i = 0; i &lt; arr.length - 1; i++){
    for(int j = length - 1; j &gt; i; j--){
      if(arr[j] &lt; arr[j - 1]){
        swap(arr, j, j - 1);
      }
    }
  }
}

public static void swap(int[] arr, int a, int b){
  int temp = arr[a];
  arr[a] = arr[b];
  arr[b] = temp;
}
</code></pre>
<h2 id="2插入排序">2.插入排序</h2>
<pre><code class="language-java">public static void insertSort(int[] arr){
  if(arr == null || arr.length &lt; 2){
    return;
  }
  for(int i = 1; i &lt; arr.length; i++){
    for(int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--){
      swap(arr, j, j + 1);
    }
  }
}
</code></pre>
<h2 id="3-选择排序">3. 选择排序</h2>
<pre><code class="language-java">public static void selectSort(int[] arr){
  if(arr == null || arr.length &lt; 2){
    return;
  }
  for(int i = 0; i &lt; arr.length; i++){
    int minIndex = i;
    for(int j = i + 1; j &lt; arr.length; j++){
      minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;
    }
    swap(arr, minIndex, i);
  }
  
}
</code></pre>
<h2 id="4-归并排序">4. 归并排序</h2>
<pre><code class="language-java">public static void mergeSort(int[] arr){
   if(arr == null || arr.length &lt; 2){
    return;
  }
  process(arr, 0, arr.length - 1);
}

public static void process(int[] arr, int left, int right){
  if(left == right){
    return;
  }
  int mid = (left + right) / 2;
  process(arr, left, mid);
  process(arr, mid + 1, right);
  merge(arr, left, mid, right);
}

public static void merge(int[] arr, int left, int mid, int right){
  int[] help = new int[right - left + 1];
  int p1 = left;
  int p2 = mid + 1;
  int i = 0;
  while(p1 &lt;= mid &amp;&amp; p2 &lt;= right){
    help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];
  }
  while(p1 &lt;= mid){
    help[i++] = arr[p1++];
  }
  while(p2 &lt;= right){
    help[i++] = arr[p2++];
  }
  for(int j = 0; j &lt; help.length; j++){
    arr[left + j] = help[j];
  }
}
</code></pre>
<h2 id="5-随机快排">5. 随机快排</h2>
<pre><code class="language-java">public static void quickSort(int[] arr){
  if(arr == null || arr.length &lt; 2){
    return;
  }
  process(arr, 0, arr.length - 1);
}

public static void process(int[] arr, int left, int right){
  if(left &lt; right){
    swap(arr, right, 
         left + (int)(Math.random() * (right - left + 1)));
    int[] p = partition(arr, left, right);
    process(arr, left, p[0] - 1);
    process(arr, p[1] + 1, right);
  }
}

public static int[] partition(int[] arr, int left, int right){
  int lessZone = left - 1;
  int moreZone = right;
  while(left &lt; moreZone){
    if(arr[left] &gt; arr[right]){
      swap(arr, left, --moreZone);
    }if(arr[left] &lt; arr[right]){
      swap(arr, left++, ++lessZone);
    }else{
      left++;
    }
  }
  swap(arr, right, moreZone);
  return new int[] {lessZone + 1, moreZone};
}
</code></pre>
<h2 id="6-堆排序">6. 堆排序</h2>
<p>用数组的方式表示完全二叉树，对于任意节点i：</p>
<p>左子节点: 2i + 1, 	右子节点: 2i + 2, 	父节点: （i - 1）/ 2</p>
<pre><code class="language-java">public static void heapSort(int[] arr){
  if(arr == null || arr.length &lt; 2){
    return;
  }
  for(int i = 0; i &lt; arr.length; i++){
    heapInsert(arr, i);
  }
  int size = arr.length;
  swap(arr, 0, --size);
  while(size &gt; 0){
    heapify(arr, 0, size);
    swap(arr, 0, --size);
  }
}

public static void heapInsert(int[] arr, int index){
  while(arr[index] &gt; arr[(index - 1) / 2]){
    swap(arr, index, (index - 1) / 2);
    index = (index - 1) / 2;
  }
}

public static void heapify(int[] arr, int index, int size){
  int left = 2 * index + 1;
  while(left &lt; size){
    int max = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] 
      ? left + 1 : left;
    max = arr[max] &gt; arr[index] ? max : index;
    if(max == index){
      break;
    }
    swap(arr, index, max);
    index = max;
    left = 2 * index + 1;
  }
}
</code></pre>
<h2 id="7-桶排序">7. 桶排序</h2>
<p>基数排序</p>
<p>计数排序</p>
<h2 id="8-总结">8. 总结</h2>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>冒泡排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>插入排序</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">O(N*logN)</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>随机快排</td>
<td style="text-align:center">O(N*logN)</td>
<td style="text-align:center">O(logN)</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">O(N*logN)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>桶排序</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">O(M)</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的常见算法]]></title>
        <id>https://stevenXu1992.github.io/post/er-cha-shu-chang-jian-ti-mu/</id>
        <link href="https://stevenXu1992.github.io/post/er-cha-shu-chang-jian-ti-mu/">
        </link>
        <updated>2020-05-12T09:22:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1判断是否为完全二叉树">1.判断是否为完全二叉树</h2>
<p>判断标准：宽度优先遍历时 1）若某节点有右节点无左节点，则不为完全二叉树 2）某节点左右节点不全，后续都必须为叶节点，否则不是完全二叉树(用一个布尔值记录状态)</p>
<pre><code class="language-java">public static boolean heapTree(Node head){
  if(head == null){
    return true;
  }
  LinkedList&lt;Node&gt;() queue = new LinkedList&lt;&gt;();
  queue.add(head);
  boolean leaf = false;
  Node right = null;
  Node left = null;
  while(!queue.isEmpty()){
    head = queue.poll();
    right = head.right;
    left = head.left;
    if( (right != null &amp;&amp; left == null) //条件1
       || (leaf &amp;&amp; (right != null || left != null))){ //条件2
      return false;
    }
    if(right != null){
      queue.add(right);
    }
    if(left != null){
      queue.add(left);
    }
    if(right == null || left == null){
      leaf = true; //左右子树有一个为空，开启叶节点的记录状态
    }
  }
  return true;
} 
</code></pre>
<h2 id="2查找两个节点的最低公共祖先节点">2.查找两个节点的最低公共祖先节点</h2>
<p>设两个节点为n1,n2， 递归函数中：</p>
<ol>
<li>若头节点为n1或n2,返回自己（为空则返回空 ）</li>
<li>递归黑盒求出左右子树的返回值</li>
<li>若左右子树返回值都不为空，返回自己（已找到公共祖先）</li>
<li>左右子树一个为空一个不为空，返回不为空的一项</li>
</ol>
<pre><code class="language-java">public static Node process(Node head, Node n1, Node n2){
  if(head == null || head == n1 || head == n2){
    return head;
  }
  Node left = process(head.left, n1, n2);
  Node right = process(head.right, n1, n2);
  if(left != null &amp;&amp; right != null){
    return head;
  }
  return left == null ? right : left;
}
</code></pre>
<h2 id="3查找某节点的后继节点">3.查找某节点的后继节点</h2>
<p>后继节点：某节点在中序遍历中的下一个节点</p>
<pre><code class="language-java">public static Node find(Node node){
  if(node == null){
    return node;
  }
  if(node.right != null){ //有右树
    return process(node.right); //则中继为右树上最左的节点
  }else{ 	//	无右树
    Node parent = node.parent;
    //若node = parent.left, 则直接返回parent
    //否则继续向上寻找，直到node = parent.node
    //最后，若一直未找到则返回null(最右节点的中继为null)
    while(parent != null &amp;&amp; node != parent.left){
      node = parent;
      parent = node.parent;
    }
    return parent;
  }
} 

public static Node process(Node node){
  if(node == null){
    return node;
  }
  while(node.left != null){
    node = node.left;
  }
  return node;
}
</code></pre>
<h2 id="4序列化与反序列化">4.序列化与反序列化</h2>
<pre><code class="language-java">// '#'表示null, '_'用于分隔
public static String serial(Node node){
  if(node == null){
    return '#_';
  }
  String res = node.data + '_';
  //按照先序遍历的顺序将树序列化成字符串
  res += serial(node.left);
  res += serial(node.right);
  return res;
}

public static Node recon(String str){
  String[] arr = str.split('_');
  Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
  for(int i = 0; i != arr.length; i++){
    queue.offer(arr[i]);
  }
  return reconProcess(queue);
}

public static Node reconProcess(Queue&lt;String&gt; queue){
  String str = queue.poll();
  if(str.equals('#')){
    return null;
  }
  Node head = new Node(Integer.valueOf(str));
  head.left = reconProcess(queue);
  head.right = reconProcess(queue);
  return head;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的递归框架]]></title>
        <id>https://stevenXu1992.github.io/post/er-cha-shu-de-di-gui-kuang-jia/</id>
        <link href="https://stevenXu1992.github.io/post/er-cha-shu-de-di-gui-kuang-jia/">
        </link>
        <updated>2020-04-24T09:04:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1判断一棵树是否为满二叉树">1.判断一棵树是否为满二叉树</h2>
<p>满二叉树条件：总节点个数 = 2 ^ 高度 - 1</p>
<ol>
<li>定义一个信息类，用于获取需要的信息（此处为节点数和高度）</li>
<li>递归函数中先使用黑盒，再补充黑盒中获取信息的操作（此处为假定通过黑盒已获取到了当前节点的左右子树的高度和节点个数，使用该信息得出当前节点处的高度和节点个数）</li>
<li>在主函数中判断是否满足条件</li>
</ol>
<pre><code class="language-java">//定义信息类
public static class Info{
  public int size;
  public int height;
  public Info(int s, int h){
    this.size = s;
    this.height = h;
  }
}
//递归函数
public static Info process(Node head){
  if(head == null){
    return new Info(0, 0);
  }
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  int size = leftInfo.size + rightInfo.size + 1;
  int height = Math.max(leftInfo.height, rightInfo.height)+1;
  return new Info(size, height);
} 
//主函数
public static boolean isFullTree(Node head){
  Info info = process(head);
  return info.size == (1 &lt;&lt; height) - 1; // 左移1位=2^height
}
</code></pre>
<h2 id="2判断一棵树是否为平衡二叉树">2.判断一棵树是否为平衡二叉树</h2>
<p>平衡二叉树条件：左右子树高度差不超过1且所有子树都平衡<br>
信息类：高度，子树是否平衡</p>
<pre><code class="language-java">public static class Info{
  public int height;
  public boolean balance;
  public Info(int h, boolean b){
    this.height = h;
    this.balance = b;
  }
}
public static Info process(Node head){
  if(head == null){
    return new Info(0, true);
  }
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  int height = Math.max(leftInfo.height, rightInfo.height) +1;
  boolean balance = 
    leftInfo.balance &amp;&amp; rightInfo.balance 
    &amp;&amp; Math.abs(leftInfo.height - rightInfo.height) &lt; 2;
  return new Info(height, balance);
}
</code></pre>
<h2 id="3求二叉树两节点间的最大距离">3.求二叉树两节点间的最大距离</h2>
<p>信息类：高度，最大距离<br>
最大距离出现的三种情况：左树上，右树上，横跨头节点</p>
<pre><code class="language-java">public static class Info{
  public int height;
  public int distance;
  public Info(int h, int d){
    this.height = h;
    this.distance = d;
  }
}
public static Info process(Node head){
  if(head = null){
    return new Info(0, 0);
  }
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  int height = Math.max(leftInfo.height, rightInfo.height) +1;
  int distance = Math.max(leftInfo.height+rightInfo.height+1,
             Math.max(leftInfo.distance, rightInfo.distance));
  return new Info(height, distance);
}
</code></pre>
<h2 id="4判断一棵树是否为搜索二叉树">4.判断一棵树是否为搜索二叉树</h2>
<p>搜索二叉树的条件：1）左树是搜索二叉树， 2）右树是搜索二叉树，3）左树的最大值小于头节点， 4）右树的最小值大于头节点<br>
信息类：是否为搜索二叉树，最大值，最小值</p>
<pre><code class="language-java">public static class Info{
  public boolean searchTree;
  public int max;
  public int min;
  public Info(boolean s, int max, int min){
    this.searchTree = s;
    this.max = max;
    this.min = min;
  }
}
public static Info process(Node head){
  if(head == null){
    return null;
  }
  
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  
  int max = head.data;
  int min = head.data;
  
  if(leftInfo != null){
    max = Math.max(max, leftInfo.max);
    min = Math.min(min, leftInfo.min);
  }
  if(rightInfo != null){
    max = Math.max(max, rightInfo.max);
    min = Math.min(min, rightInfo.min);
  }
  
  boolean searchTree = false;
  //三目的意义：若左树不为空，按1）左树是搜索树 2）左树最大值小于节点值 进行判断；若左树为空，则直接为true不用判断。右树同理。
  if(
    (leftInfo != null ? 
    (leftInfo.searchTree &amp;&amp; leftInfo.max &lt; head.data) : true)
    &amp;&amp;
    (rightInfo != null ?
    (rightInfo.searchTree &amp;&amp; rightInfo.min &gt; head.data): true)
  ){
    searchTree = true;
  }
  return new Info(searchTree, max, min);
}
</code></pre>
<h3 id="中序遍历方法">中序遍历方法</h3>
<pre><code class="language-java">public static boolean searchTree(Node head){
  if(head == null){
    return true;
  }
  Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
  Node cur = head;
  int pre = Integer.MIN_VALUE;
  while(!stack.isEmpty() || cur != null){
    if(cur != null){
      stack.push(cur);
      cur = cur.left;
    }else{
      cur = stack.pop();
      if(cur.data &lt;= pre){
        return false;
      }
      pre = cur.data;
      cur = cur.right;
    }
  }
  return true;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的遍历]]></title>
        <id>https://stevenXu1992.github.io/post/er-cha-shu-de-bian-li/</id>
        <link href="https://stevenXu1992.github.io/post/er-cha-shu-de-bian-li/">
        </link>
        <updated>2020-04-19T13:04:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-递归遍历">1. 递归遍历</h2>
<pre><code class="language-java">public static class Node{
  public int value;
  public Node left;
  public Node right;
  
  public Node(int data){
    this.value = data;
  }
}

public static void f(Node head){
  if(head == null){
    return;
  }
  //先序遍历操作
  f(head.left);
  //中序遍历操作
  f(head.right);
  //后序遍历操作
}
</code></pre>
<p>二叉树递归遍历的本质：通过树的完整递归序加工而成<br>
完整递归序：1 -&gt; 2 -&gt; 2 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 1<br>
先序：第一次来到节点时进行操作 1 -&gt; 2 -&gt; 3<br>
中序：第二次来到节点时进行操作 2 -&gt; 1 -&gt; 3<br>
后序：第三次来到节点时进行操作 2 -&gt; 3 -&gt; 1</p>
<h2 id="2-非递归遍历">2. 非递归遍历</h2>
<h3 id="21-先序遍历">2.1 先序遍历</h3>
<p>遍历顺序：中 --&gt; 左 --&gt; 右，1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p>
<ol>
<li>建立栈结构，压入头节点</li>
<li>从栈中弹出当前节点，并执行遍历操作</li>
<li>先压入弹出节点的右子节点，再压左子节点，重复步骤2直到栈为空</li>
</ol>
<pre><code class="language-java">public static void preUnRecur(Node head){
  if(head != null){
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    stack.add(head);
    while(!stack.isEmpty()){
      head = stack.pop();
      //该处执行遍历操作
      if(head.right != null){
        stack.push(head.right);
      }
      if(head.left != null){
        stack.push(head.left);
      }
    }
  }
}
</code></pre>
<h3 id="22-中序遍历">2.2 中序遍历</h3>
<p>遍历顺序：左 --&gt; 中 --&gt; 右，4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</p>
<ol>
<li>建立栈结构，压入头节点</li>
<li>不断将当前节点的左子节点压栈，直到某节点的左子节点为空，此时从栈中弹出该节点并执行遍历操作</li>
<li>若弹出节点的右子节点不为空，重复步骤2；若为空，则继续从栈中弹出下一节点直到栈为空</li>
</ol>
<pre><code class="language-java">public void inUnRecur(Node head){
  if(head != null){
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    Node cur = head;
    while(!stack.isEmpty() || cur != null){
      if(cur != null){
        stack.push(cur);
        cur = cur.left;
      }else{
        cur = stack.pop();
        //此处执行遍历操作
        cur = cur.right;
      }
    }
  }
}
</code></pre>
<h3 id="23-后序遍历">2.3 后序遍历</h3>
<p>遍历顺序：左 --&gt; 右 --&gt; 中，4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1<br>
类似于先序遍历，按照先左后右的顺序压栈。额外准备一个栈，将弹出节点压入，直到1号栈为空时，将节点依次从2号栈弹出并执行遍历操作。</p>
<pre><code class="language-java">public static void postUnRecur(Node head){
  if(head != null){
    Stack&lt;Node&gt; s1 = new Stack&lt;&gt;();
    Stack&lt;Node&gt; s2 = new Stack&lt;&gt;();
    s1.push(head);
    while(!s1.isEmpty()){
      head = s1.pop();
      s2.push(head);
      if(head.left != null){
        s1.push(head.left);
      }
      if(head.right != null){
        s1.push(head.right);
      }
    }
    while(!s2.isEmpty()){
      head = s2.pop();
      //此处执行遍历操作
    }
  }
}
</code></pre>
<h2 id="3宽度优先遍历">3.宽度优先遍历</h2>
<ol>
<li>使用哈希表记录每个节点所在层数，使用队列进行宽度优先遍历</li>
<li>每个节点都进入队列，其左右子节点层数+1进入哈希表</li>
<li>从队列弹出时，比较该节点所在层数是否大于当前层数，若大于（说明已到了下一层），则将当前层宽度清零并更新当前层数；若不大于（说明还在同一层），则当前层宽度+1。每次对一个节点操作完成后都比较并更新最大宽度与当前层宽度的最大值。</li>
</ol>
<pre><code class="language-java">public static int getMaxWidth(Node head){
  if(head ==null){
    return 0;
  }
  int maxWidth = 0;
  int curWidth = 0;
  int curLevel = 0;
  HashMap&lt;Node, Integer&gt; levelMap = new HashMap&lt;&gt;();
  LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();
  levelMap.put(head, 1);
  queue.add(head);
  Node cur = null;
  Node left = null;
  Node right = null;
  while(!queue.isEmpty()){
    cur = queue.poll();
    left = cur.left;
    right = cur.right;
    if(left != null){
      levelMap.put(left, levelMap.get(cur) + 1);
      queue.add(left);
    }
    if(right != null){
      levelMap.put(right, levelMap.get(cur) + 1);
      queue.add(right);
    }
    if(levelMap.get(cur) &gt; curLevel){
      curWidth = 0;
      curLevel = levelMap.get(cur);
    }else{
      curWidth++;
    }
    maxWidth = Math.max(curWidth, maxWidth);
  }
  return maxWidth;
}
</code></pre>
]]></content>
    </entry>
</feed>