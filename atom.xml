<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-05-28T13:19:12.904Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-80 Remove Duplicates from Sorted Array II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/">
        </link>
        <updated>2020-05-28T13:16:18.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public int removeDuplicates(int[] nums) {
    if(nums.length &lt; 3){
      return nums.length;
    }
    int dif = 2;
    for(int i = 2; i &lt; nums.length; i++){
      if(nums[i] != nums[dif-2]){
        nums[dif++] = nums[i];
      }
    }
    return dif;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-26 Remove Duplicates from Sorted Array]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/">
        </link>
        <updated>2020-05-28T13:15:26.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public static int f(int[] nums){
  if(nums.length == 0){ return 0;}
  int i = 0;
  for(int j = 1; j &lt; nums.length; j++){
    if(nums[i] != nums[j]){
      i++;
      nums[i] = nums[j];
    }
  }
  return i + 1;
  
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-27 Remove Element]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-27-remove-element/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-27-remove-element/">
        </link>
        <updated>2020-05-28T13:14:54.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//my submission
public int removeElement(int[] nums, int val) {
    if(nums.length == 0){
      return 0;
    }
    if(nums.length == 1){
      return nums[0] == val ? 0 : 1;
    }

    int zone = nums.length - 1;
    int index = 0;
    while(index &lt;= zone){
      if(nums[index] == val){
        swap(nums, index, zone--);
      }else{
        index++;
      }
    }
    return zone + 1;
}

public static void swap(int[] arr, int a, int b){
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-5 Longest Palindromic Substring]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/">
        </link>
        <updated>2020-05-28T09:18:58.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;cbbd&quot;
Output: &quot;bb&quot;
</code></pre>
<pre><code class="language-java">//my submission
public String longestPalindrome(String s) {
    if(s.length() &lt; 2){
      return s.length() == 1 ? s : &quot;&quot;;
    }

    //生成Manacher最长回文半径数组
    int[] manacher = manacher(s);
    char[] chars = getManacherString(s);
    int max = Integer.MIN_VALUE;
    int maxIndex = 0;
    for(int i = 0; i &lt; manacher.length; i++){
      if(manacher[i] &gt; max){
        max = manacher[i];
        maxIndex = i;
      }
    }

    String res = &quot;&quot;;
    max--;
    for(int j = maxIndex - max; j &lt;= maxIndex + max; j++){
      res += chars[j];
    }
  	//去除特殊符号
    res = restore(res, '#');
    return res;
}
    
public static int[] manacher(String s){
    char[] chars = getManacherString(s);
    int R = -1;
    int C = -1;
    int[] manacher = new int[chars.length];

    for(int i = 0; i != chars.length; i++){
      
      //先算出不需要重复扩充的半径区域
      manacher[i] = R &gt; i ? Math.min(manacher[2*C-i],R-i) : 1;
      
      //扩充过程
      while(i-manacher[i]&gt;-1 &amp;&amp; i+manacher[i] &lt; chars.length){
        if(chars[i + manacher[i]] == chars[i - manacher[i]]){
          manacher[i]++;
        }else {break;}
      }
      
      //更新最大回文区域的右边界
      if(i + manacher[i] &gt; R){
        R = i + manacher[i];
        C = i;
      }
    }
  
    return manacher;
}
    
public static char[] getManacherString(String s){
    char[] chars = s.toCharArray();
    char[] res = new char[s.length() * 2 + 1];
    int index = 0;
    for(int i = 0; i != res.length; i++){
      res[i] = (i &amp; 1) == 0 ? '#' : chars[index++];
    }
    return res;
}

public static String restore(String s, char r){
    String res = &quot;&quot;;
    for(int i = 0; i &lt; s.length(); i++){
      if(s.charAt(i) != r){
        res += s.charAt(i);
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-4 Median of Two Sorted Arrays]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/">
        </link>
        <updated>2020-05-28T06:19:36.000Z</updated>
        <content type="html"><![CDATA[<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre>
<pre><code class="language-java">//my submission
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
  int N1 = nums1.length;
  int N2 = nums2.length;
  if(N1 == 0){
    return N2 % 2 == 0 ? 
      (nums2[N2 / 2] + nums2[N2 / 2 - 1]) / 2.0 
      : nums2[N2 / 2];
  }else if(N2 == 0){
    return N1 % 2 == 0 ? 
  		(nums1[N1 / 2] + nums1[N1 / 2 - 1] ) / 2.0 
      : nums1[N1 / 2];
  }

  Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); 
  Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b-a );


  for(int i = 0; i &lt; nums1.length / 2; i++){
    maxHeap.add(nums1[i]);
  }

  for(int j = nums1.length - 1; j &gt;= nums1.length / 2; j--){
    minHeap.add(nums1[j]);
  }

  for(int k = 0; k &lt; nums2.length; k++){
    if(nums2[k] &gt; minHeap.element()){
      minHeap.add(nums2[k]);
    }else {
      maxHeap.add(nums2[k]);
    }

    if(maxHeap.size() - minHeap.size() &gt; 1){
      minHeap.add(maxHeap.poll());
    }else if(minHeap.size() - maxHeap.size() &gt; 1){
      maxHeap.add(minHeap.poll());
    }
  }

  if(minHeap.size() == maxHeap.size()){
    return (maxHeap.element() + minHeap.element()) / 2.0;
  }else{
    return maxHeap.size() &gt; minHeap.size() ? 
      maxHeap.element() : minHeap.element();
  }
}

//solution
//Time complexity: O(n + m)
//Space complexity: O(1)
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int index1 = 0;
    int index2 = 0;
    int med1 = 0;
    int med2 = 0;
    for (int i=0; i&lt;=(nums1.length+nums2.length)/2; i++) {
        med1 = med2;
        if (index1 == nums1.length) {
            med2 = nums2[index2];
            index2++;
        } else if (index2 == nums2.length) {
            med2 = nums1[index1];
            index1++;
        } else if (nums1[index1] &lt; nums2[index2] ) {
            med2 = nums1[index1];
            index1++;
        }  else {
            med2 = nums2[index2];
            index2++;
        }
    }
    if ((nums1.length+nums2.length)%2 == 0) {
        return (float)(med1+med2)/2;
    }
    return med2;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-3 Longest Substring Without Repeating Characters]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/">
        </link>
        <updated>2020-05-27T14:29:39.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;abcabcbb&quot;
Output: 3 
Explanation: The answer is &quot;abc&quot;, with the length of 3. 
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3. 
             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n)
public int lengthOfLongestSubstring(String s) {
    if(s == null || s.length() == 0){
      return 0;
    }

    char[] chars = s.toCharArray();
    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
    int max = Integer.MIN_VALUE;

    for(int i = 0; i &lt; chars.length; i++){
      while(!queue.isEmpty() &amp;&amp; set.contains(chars[i])){
        set.remove(chars[queue.pollFirst()]);
      }
      queue.addLast(i);
      set.add(chars[i]);
      max = Math.max(max, queue.size());
    }
    return max;
}

//solution
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();
    int ans = 0, i = 0, j = 0;
    while (i &lt; n &amp;&amp; j &lt; n) {
      // try to extend the range [i, j]
      if (!set.contains(s.charAt(j))){
        set.add(s.charAt(j++));
        ans = Math.max(ans, j - i);
      }
      else {
        set.remove(s.charAt(i++));
      }
    }
    return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-2 Add Two Numbers]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-2-add-two-numbers/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-2-add-two-numbers/">
        </link>
        <updated>2020-05-27T14:27:20.000Z</updated>
        <content type="html"><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
</code></pre>
<pre><code class="language-java">//solution
//Time complexity: O(Max(m, n))
//Space complexity: O(Max(m, n))
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1;
    ListNode q = l2;
    ListNode cur = dummyHead;
    int carry = 0; 
    while(p != null || q != null){
      //若两链表不等长，多出来的按0计算
      int x = p == null ? 0 : p.val;
      int y = q == null ? 0 : q.val;
      
      //carry表示进位
      //若sum小于10, carry = sum / 10 = 0
      //若sum大于10，carry = sum / 10 = 1
      int sum = carry + x + y;
      carry = sum / 10;
      
     	//若sum小于10, sum % 10 = sum
      //若sum大于10，sum % 10 = sum - 10
      cur.next = new ListNode(sum % 10);
      cur = cur.next;
      if(p != null){
        p = p.next;
      }
      if(q != null){
        q = q.next;
      }
    }
    if(carry &gt; 0){
      cur.next = new ListNode(carry);
    }
    return dummyHead.next;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-1 Two Sum]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-1-two-sum/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-1-two-sum/">
        </link>
        <updated>2020-05-27T14:24:42.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have *<strong>exactly*</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>
<pre><code class="language-java">//my submission 
//Time complexity: O(n^2)
//Space complexity: O(1)
public int[] twoSum(int[] nums, int target) {
    if(nums == null || nums.length == 0){
      return null;
    }
    int[] res = new int[2];        
    for(int i = 0; i &lt; nums.length; i++){
      for(int j = 0; j &lt; nums.length; j++){
        if(nums[i] + nums[j] == target &amp;&amp; i != j){
          res[0] = i;
          res[1] = j;
        }
      }
    }   
    return res;
}

//solution
//Time complexity: O(n)
//Space complexity: O(n)
public int[] twoSum(int[] nums, int target) {
    if(nums == null || nums.length == 0){
      return null;
    }
    int[] res = new int[2];
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for(int i = 0; i &lt; nums.length; i++){
      map.put(nums[i], i);
    }
    for(int j = 0; j &lt; nums.length; j++){
      int rest = target - nums[j];
      if(map.containsKey(rest) &amp;&amp; map.get(rest) != j){
        res[0] = j;
        res[1] = map.get(rest);
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划]]></title>
        <id>https://stevenXu1992.github.io/post/dong-tai-gui-hua/</id>
        <link href="https://stevenXu1992.github.io/post/dong-tai-gui-hua/">
        </link>
        <updated>2020-05-26T16:15:07.000Z</updated>
        <content type="html"><![CDATA[<p>暴力递归 --&gt; 动态规划步骤：</p>
<p>1)找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了</p>
<p>2)把可变参数的所有组合映射成一张表，有1个可变参数就是一维表，2个可变参数就 是二维</p>
<p>3)最终答案要的是表中的哪个位置，在表中标出</p>
<p>4)根据递归过程的 base case，把这张表的最简单不需要依赖其他位置的那些位置填好值</p>
<p>5)根据递归过程非base case的部分，也就是分析表中的普遍位置需要怎么计算得到，那 么这张表的填写顺序也就确定了</p>
<p>6)综上确定计算顺序，填好表，返回最终答案在表中位置的值</p>
<h2 id="1-机器人达到指定位置">1. 机器人达到指定位置</h2>
<p>假设有排成一行的 N 个位置，记为 1~N，N 一定大于或等于 2。开始时机器人在其中的 M 位 置上(M 一定是 1~N 中的一个)，机器人可以往左走或者往右走，如果机器人来到 1 位置， 那 么下一步只能往右来到 2 位置;如果机器人来到 N 位置，那么下一步只能往左来到 N-1 位置。 规定机器人必须走 K 步，最终能来到 P 位置(P 也一定是 1~N 中的一个)的方法有多少种。给 定四个参数 N、M、K、P，返回方法数。</p>
<pre><code class="language-java">public static int robot(int N, int S, int E, int K){
  // N:	共N个位置
  // S:	起点
  // E: 终点
  // K: 可以走的步数
  if(N &lt; 2 || K &lt; 1 || S &lt; 1 || S &gt; N || E &lt; 1 || E &gt; N){
    return 0;
  }
  
  //暴力递归
  int res = process1(N, S, E, K);
  
  //记忆化搜索
  int[][] dp = new int[K + 1][N + 1];
  for(int i = 0; i &lt; K; i++){
    for(int j = 0; j &lt; N; j++){
      dp[i][j] = -1;
    }
  }
  int res = process2(N, S, E, K, dp);
  
  //严格表结构动态规划
  int res = process(N, S, E, K);
  
}

//暴力递归
public static int process1(int N, int index, int E, int rest){
  // index: 当前位置
  // rest: 还剩rest步
  if(rest == 0){
    return index == E ? 1 : 0;
  }
  if(index == 1){
    return process(N, 2, E, rest - 1);
  }
  if(index == N){
    return process(N, N - 1, E, rest - 1);
  }
  return process(N, index + 1, E, rest - 1) 
        +  process(N, index - 1, E, rest - 1);
}

//记忆化搜索
public static int process2(int N, int index, int E, int rest, int[][] dp){
  if(dp[index][rest] != -1){
    return dp[index][rest];
  }
  
  if(rest == 0){
    dp[index][rest] = E ? 1 : 0;
  }else if(index == 1){
    dp[index][rest] = process(N, 2, E, rest - 1);
  }else if(index == N){
    dp[index][rest] = process(N, N - 1, E, rest - 1);
  }else{
    dp[index][rest] = process(N, index + 1, E, rest - 1) 
                         + process(N, index - 1, E, rest - 1);
  }
  return dp[index][rest];
}

//严格表结构动态规划
public static int process3(int N, int index, int E, int rest){
  int[][] dp = new int[index + 1][rest + 1];
  dp[E][0] = 1;
  for(int i = 1; i &lt; index; i++){
    for(int j = 1; j &lt; rest; j++){
      if(i == 1){
        dp[i][j] = dp[2][ j - 1];
      }
      if(i == N){
       dp[i][j] = dp[N - 1][j - 1]; 
      }
  		dp[i][j] = dp[i + 1][j - 1] + dp[i - 1][j - 1]
    }
  }
  return dp[index][rest];
}

</code></pre>
<h2 id="2-换钱的最少货币数">2. 换钱的最少货币数</h2>
<p>给定数组 arr，arr 中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim，代表要找的钱数，求组成 aim 的最少货币数。</p>
<pre><code class="language-java">public static int minCoin(int[] arr, int aim){
  if(arr.length == 0 || arr == null || aim &lt; 0){
    return -1;
  }
  
  //暴力递归
  int res = process1(arr, 0, aim);
  
  //记忆化搜索
  int[][] dp = new int[arr.length + 1][aim + 1];
  for(int i = 0; i &lt;= arr.length; i++){
    for(int j = 0; j &lt;= aim; j++){
      dp[i][j] = -2;
    }
  }
  int res = process2(arr, 0, aim, dp);
  
  
  //严格表结构动态规划
  int res = process3(arr, 0, aim);
}

//暴力递归
public static int process1(int[] arr, int index, int rest){
  if(rest &lt; 0){
    return -1;
  }
  if(rest == 0){
    return 0;
  }
  if(index == arr.length){
    return -1;
  }
  int p1 = process1(arr, index + 1, rest);
  int p2 = process1(arr, index + 1, rest - arr[index]);
  
  if(p1 == -1 &amp;&amp; p2 == -1){
    return -1;
  }
  if(p1 == -1){
    return p2 + 1;
  }
  if(p2 == -1){
    return p1;
  }
  return Math.min(p1, p2 + 1);
}


//记忆化搜索
public static int process2(int[] arr, int index, int rest, int[][] dp){
  if(rest &lt; 0){
    return -1;
  }
  if(dp[index][rest] != -2){
    return dp[index][rest];
  }
  
  if(rest == 0){
    dp[index][rest] = 0;
  }else if(index == arr.length){
    dp[index][rest] = -1;
  }else {
    int p1 = process1(arr, index + 1, rest);
  	int p2 = process1(arr, index + 1, rest - arr[index]);
    if(p1 == -1 &amp;&amp; p2 == -1){
    	dp[index][rest] = -1;
  	}else{
    	if(p1 == -1){
    		dp[index][rest] = p2 + 1;
  		}else if(p2 == -1){
    		dp[index][rest] = p1;
  		}else{
        dp[index][rest] = Math.min(p1, p2 + 1);  
      }
    }
  }
  return dp[index][rest];
}

//严格表结构动态规划
public static int process3(int[] arr, int index, int rest){
  int[][] dp = new int[arr.length + 1][rest + 1];
  for(int i = 0; i &lt;= arr.length; i++){
    dp[i][0] = 0;
  }
  for(int j = 1; j &lt;= rest; j++){
    dp[arr.length][j] = -1;
  }
  
  for(int i = arr.length - 1; i &gt;= 0; i--){
    for(int j = 1; j &lt;= rest; j++){
      int p1 = dp[i + 1][j];
      int p2 = -1;
      if(j - arr[i] &gt;= 0){
        p2 = dp[i + 1][j - arr[j]];
      }
      if(p1 == -1 &amp;&amp; p2 == -1){
        dp[i][j] = -1;
      }
      if(p1 == -1){
        dp[i][j] = p2 + 1;
      }
      if(p2 == -1){
        dp[i][j] = p1;
      }
      dp[i][j] = Math.min(p1, p2 + 1);
    }
  }
  return dp[index][rest];
}

</code></pre>
<h2 id="3-取纸牌问题">3. 取纸牌问题</h2>
<p>给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸 牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A 和玩家B都绝顶聪明。请返回最后获胜者的分数。</p>
<pre><code class="language-java">//暴力递归
public static int maxWinSorce1(int[] arr){
  if(arr == null){
    return 0;
  }
  return Math.max(
    firstHand(arr, 0, arr.length - 1),
    secondHand(arr, 0, arr.length - 1));
}

public static int firstHand(int[] arr, int left, int right){
  if(left == right){
    return arr[left];
  }
  Math.max(
    arr[left] + secondHand(arr, left + 1, right),
  	arr[right] + secondHand(arr, left, right -1)
  );
}

public static int secondHand(int[] arr, int left, int right){
  if(left == right){
    return 0;
  }
  Math.min(
    firstHand(arr, left + 1, right),
  	firstHand(arr, left, right -1)
  );
}

//动态规划
public static int maxWinScorce2(int[] arr){
  if(arr == null || arr.length = 0){
    return 0;
  }
  
  int N = arr.length;
  int[][] dpF = new int[N][N];
  int[][] dpS = new int[N][N];
  
  for(int left = 0; left &lt; N; left++){
    dpF[left][left] = arr[left];
    for(int right = left - 1; right &gt;= 0; right--){
      dpF[left][right] = Math.max(
        arr[left] + dpS[left + 1][right],
      	arr[right] + dpS[left][right - 1]);
       dpS[left][right] = Math.min(
        dpF[left + 1][right],
        dpF[left][right - 1]);
    }
  }
  return Math.max(dpF[0][N - 1], dpS[0][N - 1]);
}


</code></pre>
<h2 id="4象棋中马的跳法">4.象棋中马的跳法</h2>
<p>请同学们自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下 角是(0,0)位置。那么整个棋盘就是横坐标上9条线、纵坐标上10条线的一个区域。给你三个 参数，x，y，k，返回如果“马”从(0,0)位置出发，必须走k步，最后落在(x,y)上的方法数 有多少种?</p>
<pre><code class="language-java">//暴力递归
public static int process1(int x, int y, int k){
  if(x &lt; 0 || x &gt; 8 || y &lt; 0 || y &gt; 9){
    return 0;
  }
  //剩余步数为零时，所在位置(x,y)距终点的相对距离为(0,0)时找到一种跳法
  if(k == 0){
    return (x == 0 &amp;&amp; y == 0) ? 1 : 0;
  }
  int res = process1(x - 1, y + 2, k - 1)
				+ process1(x + 1, y + 2, k - 1)
				+ process1(x + 2, y + 1, k - 1)
				+ process1(x + 2, y - 1, k - 1)
				+ process1(x + 1, y - 2, k - 1)
				+ process1(x - 1, y - 2, k - 1)
				+ process1(x - 2, y - 1, k - 1)
				+ process1(x - 2, y + 1, k - 1);
  return res;
}

//动态规划
public static int process2(int x, int y, int k){
  if(x &lt; 0 || x &gt; 8 || y &lt; 0 || y &gt; 9){
    return 0;
  }
  
  //x,y,k为立方体的长宽高, k层的数据取决于k-1层，因此从下往上填
  int[][][] dp = new int[9][10][k + 1];
  dp[0][0][0] = 1;
  for(int height = 1; height &lt;= k; height++){
    for(int len = 0; len &lt; 9; len++){
      for(int wid = 0; wid &lt; 10; wid++){
        dp[len][wid][height] =
          getValue(dp, len - 1, wid + 2, height - 1)
				+ getValue(dp, len + 1, wid + 2, height - 1)
				+ getValue(dp, len + 2, wid + 1, height - 1)
				+ getValue(dp, len + 2, wid - 1, height - 1)
				+ getValue(dp, len + 1, wid - 2, height - 1)
				+ getValue(dp, len - 1, wid - 2, height - 1)
				+ getValue(dp, len - 2, wid - 1, height - 1)
				+ getValue(dp, len - 2, wid + 1, height - 1);
      }
    }
  }
  return dp[x][y][k];
}

public static int getValue(int[][][] dp, int height, int len, int wid){
  if(len &lt; 0 || len &gt; 8 || wid &lt; 0 || wid &gt; 9){
    return 0;
  }
  return dp[len][wid][height];
}

</code></pre>
<h2 id="5-bob的生存概率">5. Bob的生存概率</h2>
<p>给定五个参数n,m,i,j,k。表示在一个N*M的区域，Bob处在(i,j)点，每次Bob等概率的向上、 下、左、右四个方向移动一步，Bob必须走K步。如果走完之后，Bob还停留在这个区域上， 就算Bob存活，否则就算Bob死亡。请求解Bob的生存概率，返回字符串表示分数的方式。</p>
<pre><code class="language-java">//暴力递归
public static String bob(int n, int m, int i, int j, int k){
  long all = (long)Math.pow(4, k);
  long live = process1(n, m, i, j, k);
  long gc = gcd(all, live);
  return String.valueOf((live / gc) + &quot;/&quot; + (all / gc));
  
}

//返回可以存活的走法数
public static long process1(int N, int M, int i, int j, 
                           int rest){
  if(i &lt; 0 || i &gt; N || j &lt; 0 || j &gt; M){
    return 0;
  }
  if(rest == 0){
    return 1;
  }
  long live = process1(N, M, i + 1, j, rest - 1)
    				+ process1(N, M, i, j + 1, rest - 1)
    				+ process1(N, M, i - 1, j, rest - 1)
    				+ process1(N, M, i, j - 1, rest - 1);
}

//动态规划
public static long process2(int N, int M, int i, int j, 
                           int K){
  int[][][] dp = new int[N + 1][M + 1][K + 1];
  for(int len = 0; len &lt;= N; len++){
    for(int wid = 0; wid &lt;= M; wid++){
      dp[len][wid][0] = 1;
    }
  }
  for(int height = 1; height &lt;= K; height++){
    for(int len = 0; len &lt;= N; len++){
      for(int wid = 0; wid &lt;= M; wid++){
        dp[len][wid][height] = 
        			dp[len + 1][wid][height - 1]
    				+ dp[len - 1][wid][height - 1]
    				+ dp[len][wid + 1][height - 1]
    				+ dp[len][wid - 1][height - 1];
      }
    }
  }
  return dp[i][j][K];
}


public static long gcd(long m, long n){
  return n == 0 ? m : gcd(n, m % n);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Morris遍历]]></title>
        <id>https://stevenXu1992.github.io/post/morris-bian-li/</id>
        <link href="https://stevenXu1992.github.io/post/morris-bian-li/">
        </link>
        <updated>2020-05-25T08:14:24.000Z</updated>
        <content type="html"><![CDATA[<p>Morris遍历细节 假设来到当前节点cur，开始时cur来到头节点位置</p>
<p>1)如果cur没有左孩子，cur向右移动(cur = cur.right)</p>
<p>2)如果cur有左孩子，找到左子树上最右的节点mostRight:</p>
<p>​	a.如果mostRight的右指针指向空，让其指向cur， 然后cur向左移动(cur = cur.left)</p>
<p>​	b.如果mostRight的右指针指向cur，让其指向null， 然后cur向右移动(cur = cur.right)</p>
<p>3)cur为空时遍历停止</p>
<h2 id="1morris自然序遍历">1.Morris自然序遍历</h2>
<p>Morris序： 1 -&gt; 2 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 3 -&gt; 6 -&gt; 3 -&gt; 7</p>
<pre><code class="language-java">public static void morrisClassical(Node head){
  if(head == null){
    return;
  }
  
  Node cur = head;
  Node mostR = null;
  while(cur != null){
    mostR = cur.left;
    //cur有左树，找到左树上最右的节点
    if(mostR != null){
      while(mostR.right != null &amp;&amp; mostR.right != cur){
        mostR = mostR.right;
      }
      //此时mostR已到达cur左树上最右的节点处
      if(mostR.right == null){
        //若发现mostR右树为空，则是第一次到达该点
        mostR.right = cur;
        //先序操作
        //将mostR.right指向cur后，cur继续往下走执行外部while循环
        cur = cur.left;
        continue;
      }else{
        //若发现mostR.right指向cur，则是第二次到达该点，还原指针
        mostR.right = null;
        //edgeR(cur.left); 后序操作
      }
    }//else{先序操作}
    //cur无左树，cur向右移动（通过之前修改的mostR.right指针返回父节点）,继续执行外部的while循环
    //中序操作
    cur = cur.right;
  }
  //edgeR（head); 后序操作
}
</code></pre>
<h2 id="2先序遍历">2.先序遍历</h2>
<p>先序： 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p>
<p>首次到达时进行操作，见1自然序注释</p>
<h2 id="3中序遍历">3.中序遍历</h2>
<p>先序： 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</p>
<p>叶节点直接操作，其他节点第二次达到时操作，见1自然序注释</p>
<h2 id="4后序遍历">4.后序遍历</h2>
<p>后序： 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1</p>
<p>发现第二次到达时，逆序操作cur左树的右边界，遍历完成后逆序操作整棵树的右边界，见1自然序注释</p>
<pre><code class="language-java">public static void edgeR(Node head){
  Node tail = reverseEdge(head);
  Node cur = tail;
  while(cur != null){
    //遍历操作
    cur = cur.right;
  }
  reverseEdge(tail);
}

public static Node reverseEdge(Node from){
  Node pre = null;
  Node next = next;
  while(from != null){
    next = from.right;
    from.right = pre;
    pre = from;
    from = next;
  }
  return pre;
}
</code></pre>
]]></content>
    </entry>
</feed>