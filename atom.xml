<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-05-31T10:57:43.954Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-41 First Missing Positive]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-41-first-missing-positive/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-41-first-missing-positive/">
        </link>
        <updated>2020-05-31T10:57:05.000Z</updated>
        <content type="html"><![CDATA[<p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,2,0]
Output: 3
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [3,4,-1,1]
Output: 2
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: [7,8,9,11,12]
Output: 1
</code></pre>
<p><strong>Note:</strong></p>
<p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p>
<pre><code class="language-java">//solution
public int firstMissingPositive(int[] A) {
  int i = 0;
  //遍历数组并将每个数n放到n-1位置A[A[i]-1] != A[i]
  while(i &lt; A.length){
    if(A[i] &gt;= 1 &amp;&amp; A[i] &lt;= A.length &amp;&amp; A[A[i]-1] != A[i]) {
      swap(A, i, A[i]-1);
    }else{ i++; }
  }
  //放好位置后再次遍历，第一次遇到 A[i] != i + 1 时就是答案
  for(int i = 0; i &lt; A.length; i++) 
    if( A[i] != i + 1 ){return i + 1; }
  return A.length + 1;
}

private void swap(int[] A, int i, int j){
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-189 Rotate Array]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-189-rotate-array/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-189-rotate-array/">
        </link>
        <updated>2020-05-28T14:45:11.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n * k)
//Space complexity: O(1)
public void rotate(int[] nums, int k) {
    if(nums.length &lt; 2){
      return;
    }
    while(k != 0){
      rotateOnce(nums);
      k--;
    }
}
public void rotateOnce(int[] arr){
    for(int i = arr.length - 1; i &gt; 0; i--){
      int temp = arr[i - 1];
      arr[i - 1] = arr[i];
      arr[i] = temp;
    }
}

//solution
//Time complexity: O(n)
//Space complexity: O(1)
public void rotate(int[] nums, int k) {
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
}
public void reverse(int[] nums, int start, int end) {
    while (start &lt; end) {
      int temp = nums[start];
      nums[start] = nums[end];
      nums[end] = temp;
      start++;
      end--;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-80 Remove Duplicates from Sorted Array II]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-80-remove-duplicates-from-sorted-array-ii/">
        </link>
        <updated>2020-05-28T13:16:18.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public int removeDuplicates(int[] nums) {
    if(nums.length &lt; 3){
      return nums.length;
    }
    int dif = 2;
    for(int i = 2; i &lt; nums.length; i++){
      if(nums[i] != nums[dif-2]){
        nums[dif++] = nums[i];
      }
    }
    return dif;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-26 Remove Duplicates from Sorted Array]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-26-remove-duplicates-from-sorted-array/">
        </link>
        <updated>2020-05-28T13:15:26.000Z</updated>
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//solution
public static int f(int[] nums){
  if(nums.length == 0){ return 0;}
  int i = 0;
  for(int j = 1; j &lt; nums.length; j++){
    if(nums[i] != nums[j]){
      i++;
      nums[i] = nums[j];
    }
  }
  return i + 1;
  
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-27 Remove Element]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-27-remove-element/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-27-remove-element/">
        </link>
        <updated>2020-05-28T13:14:54.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
</code></pre>
<pre><code class="language-java">//my submission
public int removeElement(int[] nums, int val) {
    if(nums.length == 0){
      return 0;
    }
    if(nums.length == 1){
      return nums[0] == val ? 0 : 1;
    }

    int zone = nums.length - 1;
    int index = 0;
    while(index &lt;= zone){
      if(nums[index] == val){
        swap(nums, index, zone--);
      }else{
        index++;
      }
    }
    return zone + 1;
}

public static void swap(int[] arr, int a, int b){
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-5 Longest Palindromic Substring]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/">
        </link>
        <updated>2020-05-28T09:18:58.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;cbbd&quot;
Output: &quot;bb&quot;
</code></pre>
<pre><code class="language-java">//my submission
public String longestPalindrome(String s) {
    if(s.length() &lt; 2){
      return s.length() == 1 ? s : &quot;&quot;;
    }

    //生成Manacher最长回文半径数组
    int[] manacher = manacher(s);
    char[] chars = getManacherString(s);
    int max = Integer.MIN_VALUE;
    int maxIndex = 0;
    for(int i = 0; i &lt; manacher.length; i++){
      if(manacher[i] &gt; max){
        max = manacher[i];
        maxIndex = i;
      }
    }

    String res = &quot;&quot;;
    max--;
    for(int j = maxIndex - max; j &lt;= maxIndex + max; j++){
      res += chars[j];
    }
  	//去除特殊符号
    res = restore(res, '#');
    return res;
}
    
public static int[] manacher(String s){
    char[] chars = getManacherString(s);
    int R = -1;
    int C = -1;
    int[] manacher = new int[chars.length];

    for(int i = 0; i != chars.length; i++){
      
      //先算出不需要重复扩充的半径区域
      manacher[i] = R &gt; i ? Math.min(manacher[2*C-i],R-i) : 1;
      
      //扩充过程
      while(i-manacher[i]&gt;-1 &amp;&amp; i+manacher[i] &lt; chars.length){
        if(chars[i + manacher[i]] == chars[i - manacher[i]]){
          manacher[i]++;
        }else {break;}
      }
      
      //更新最大回文区域的右边界
      if(i + manacher[i] &gt; R){
        R = i + manacher[i];
        C = i;
      }
    }
  
    return manacher;
}
    
public static char[] getManacherString(String s){
    char[] chars = s.toCharArray();
    char[] res = new char[s.length() * 2 + 1];
    int index = 0;
    for(int i = 0; i != res.length; i++){
      res[i] = (i &amp; 1) == 0 ? '#' : chars[index++];
    }
    return res;
}

public static String restore(String s, char r){
    String res = &quot;&quot;;
    for(int i = 0; i &lt; s.length(); i++){
      if(s.charAt(i) != r){
        res += s.charAt(i);
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-4 Median of Two Sorted Arrays]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/">
        </link>
        <updated>2020-05-28T06:19:36.000Z</updated>
        <content type="html"><![CDATA[<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre>
<pre><code class="language-java">//my submission
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
  int N1 = nums1.length;
  int N2 = nums2.length;
  if(N1 == 0){
    return N2 % 2 == 0 ? 
      (nums2[N2 / 2] + nums2[N2 / 2 - 1]) / 2.0 
      : nums2[N2 / 2];
  }else if(N2 == 0){
    return N1 % 2 == 0 ? 
  		(nums1[N1 / 2] + nums1[N1 / 2 - 1] ) / 2.0 
      : nums1[N1 / 2];
  }

  Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); 
  Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b-a );


  for(int i = 0; i &lt; nums1.length / 2; i++){
    maxHeap.add(nums1[i]);
  }

  for(int j = nums1.length - 1; j &gt;= nums1.length / 2; j--){
    minHeap.add(nums1[j]);
  }

  for(int k = 0; k &lt; nums2.length; k++){
    if(nums2[k] &gt; minHeap.element()){
      minHeap.add(nums2[k]);
    }else {
      maxHeap.add(nums2[k]);
    }

    if(maxHeap.size() - minHeap.size() &gt; 1){
      minHeap.add(maxHeap.poll());
    }else if(minHeap.size() - maxHeap.size() &gt; 1){
      maxHeap.add(minHeap.poll());
    }
  }

  if(minHeap.size() == maxHeap.size()){
    return (maxHeap.element() + minHeap.element()) / 2.0;
  }else{
    return maxHeap.size() &gt; minHeap.size() ? 
      maxHeap.element() : minHeap.element();
  }
}

//solution
//Time complexity: O(n + m)
//Space complexity: O(1)
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int index1 = 0;
    int index2 = 0;
    int med1 = 0;
    int med2 = 0;
    for (int i=0; i&lt;=(nums1.length+nums2.length)/2; i++) {
        med1 = med2;
        if (index1 == nums1.length) {
            med2 = nums2[index2];
            index2++;
        } else if (index2 == nums2.length) {
            med2 = nums1[index1];
            index1++;
        } else if (nums1[index1] &lt; nums2[index2] ) {
            med2 = nums1[index1];
            index1++;
        }  else {
            med2 = nums2[index2];
            index2++;
        }
    }
    if ((nums1.length+nums2.length)%2 == 0) {
        return (float)(med1+med2)/2;
    }
    return med2;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-3 Longest Substring Without Repeating Characters]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/">
        </link>
        <updated>2020-05-27T14:29:39.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;abcabcbb&quot;
Output: 3 
Explanation: The answer is &quot;abc&quot;, with the length of 3. 
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3. 
             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n)
public int lengthOfLongestSubstring(String s) {
    if(s == null || s.length() == 0){
      return 0;
    }

    char[] chars = s.toCharArray();
    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
    int max = Integer.MIN_VALUE;

    for(int i = 0; i &lt; chars.length; i++){
      while(!queue.isEmpty() &amp;&amp; set.contains(chars[i])){
        set.remove(chars[queue.pollFirst()]);
      }
      queue.addLast(i);
      set.add(chars[i]);
      max = Math.max(max, queue.size());
    }
    return max;
}

//solution
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();
    int ans = 0, i = 0, j = 0;
    while (i &lt; n &amp;&amp; j &lt; n) {
      // try to extend the range [i, j]
      if (!set.contains(s.charAt(j))){
        set.add(s.charAt(j++));
        ans = Math.max(ans, j - i);
      }
      else {
        set.remove(s.charAt(i++));
      }
    }
    return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-2 Add Two Numbers]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-2-add-two-numbers/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-2-add-two-numbers/">
        </link>
        <updated>2020-05-27T14:27:20.000Z</updated>
        <content type="html"><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
</code></pre>
<pre><code class="language-java">//solution
//Time complexity: O(Max(m, n))
//Space complexity: O(Max(m, n))
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1;
    ListNode q = l2;
    ListNode cur = dummyHead;
    int carry = 0; 
    while(p != null || q != null){
      //若两链表不等长，多出来的按0计算
      int x = p == null ? 0 : p.val;
      int y = q == null ? 0 : q.val;
      
      //carry表示进位
      //若sum小于10, carry = sum / 10 = 0
      //若sum大于10，carry = sum / 10 = 1
      int sum = carry + x + y;
      carry = sum / 10;
      
     	//若sum小于10, sum % 10 = sum
      //若sum大于10，sum % 10 = sum - 10
      cur.next = new ListNode(sum % 10);
      cur = cur.next;
      if(p != null){
        p = p.next;
      }
      if(q != null){
        q = q.next;
      }
    }
    if(carry &gt; 0){
      cur.next = new ListNode(carry);
    }
    return dummyHead.next;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-1 Two Sum]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-1-two-sum/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-1-two-sum/">
        </link>
        <updated>2020-05-27T14:24:42.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have *<strong>exactly*</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>
<pre><code class="language-java">//my submission 
//Time complexity: O(n^2)
//Space complexity: O(1)
public int[] twoSum(int[] nums, int target) {
    if(nums == null || nums.length == 0){
      return null;
    }
    int[] res = new int[2];        
    for(int i = 0; i &lt; nums.length; i++){
      for(int j = 0; j &lt; nums.length; j++){
        if(nums[i] + nums[j] == target &amp;&amp; i != j){
          res[0] = i;
          res[1] = j;
        }
      }
    }   
    return res;
}

//solution
//Time complexity: O(n)
//Space complexity: O(n)
public int[] twoSum(int[] nums, int target) {
    if(nums == null || nums.length == 0){
      return null;
    }
    int[] res = new int[2];
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for(int i = 0; i &lt; nums.length; i++){
      map.put(nums[i], i);
    }
    for(int j = 0; j &lt; nums.length; j++){
      int rest = target - nums[j];
      if(map.containsKey(rest) &amp;&amp; map.get(rest) != j){
        res[0] = j;
        res[1] = map.get(rest);
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
</feed>