<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Steven Xu</title>
    <updated>2020-05-28T09:19:42.455Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Steven Xu</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode-5 Longest Palindromic Substring]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-5-longest-palindromic-substring/">
        </link>
        <updated>2020-05-28T09:18:58.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;cbbd&quot;
Output: &quot;bb&quot;
</code></pre>
<pre><code class="language-java">//my submission
public String longestPalindrome(String s) {
    if(s.length() &lt; 2){
      return s.length() == 1 ? s : &quot;&quot;;
    }

    //生成Manacher最长回文半径数组
    int[] manacher = manacher(s);
    char[] chars = getManacherString(s);
    int max = Integer.MIN_VALUE;
    int maxIndex = 0;
    for(int i = 0; i &lt; manacher.length; i++){
      if(manacher[i] &gt; max){
        max = manacher[i];
        maxIndex = i;
      }
    }

    String res = &quot;&quot;;
    max--;
    for(int j = maxIndex - max; j &lt;= maxIndex + max; j++){
      res += chars[j];
    }
  	//去除特殊符号
    res = restore(res, '#');
    return res;
}
    
public static int[] manacher(String s){
    char[] chars = getManacherString(s);
    int R = -1;
    int C = -1;
    int[] manacher = new int[chars.length];

    for(int i = 0; i != chars.length; i++){
      
      //先算出不需要重复扩充的半径区域
      manacher[i] = R &gt; i ? Math.min(manacher[2*C-i],R-i) : 1;
      
      //扩充过程
      while(i-manacher[i]&gt;-1 &amp;&amp; i+manacher[i] &lt; chars.length){
        if(chars[i + manacher[i]] == chars[i - manacher[i]]){
          manacher[i]++;
        }else {break;}
      }
      
      //更新最大回文区域的右边界
      if(i + manacher[i] &gt; R){
        R = i + manacher[i];
        C = i;
      }
    }
  
    return manacher;
}
    
public static char[] getManacherString(String s){
    char[] chars = s.toCharArray();
    char[] res = new char[s.length() * 2 + 1];
    int index = 0;
    for(int i = 0; i != res.length; i++){
      res[i] = (i &amp; 1) == 0 ? '#' : chars[index++];
    }
    return res;
}

public static String restore(String s, char r){
    String res = &quot;&quot;;
    for(int i = 0; i &lt; s.length(); i++){
      if(s.charAt(i) != r){
        res += s.charAt(i);
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-4 Median of Two Sorted Arrays]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-4-median-of-two-sorted-arrays/">
        </link>
        <updated>2020-05-28T06:19:36.000Z</updated>
        <content type="html"><![CDATA[<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre>
<pre><code class="language-java">//my submission
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
  int N1 = nums1.length;
  int N2 = nums2.length;
  if(N1 == 0){
    return N2 % 2 == 0 ? 
      (nums2[N2 / 2] + nums2[N2 / 2 - 1]) / 2.0 
      : nums2[N2 / 2];
  }else if(N2 == 0){
    return N1 % 2 == 0 ? 
  		(nums1[N1 / 2] + nums1[N1 / 2 - 1] ) / 2.0 
      : nums1[N1 / 2];
  }

  Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); 
  Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b-a );


  for(int i = 0; i &lt; nums1.length / 2; i++){
    maxHeap.add(nums1[i]);
  }

  for(int j = nums1.length - 1; j &gt;= nums1.length / 2; j--){
    minHeap.add(nums1[j]);
  }

  for(int k = 0; k &lt; nums2.length; k++){
    if(nums2[k] &gt; minHeap.element()){
      minHeap.add(nums2[k]);
    }else {
      maxHeap.add(nums2[k]);
    }

    if(maxHeap.size() - minHeap.size() &gt; 1){
      minHeap.add(maxHeap.poll());
    }else if(minHeap.size() - maxHeap.size() &gt; 1){
      maxHeap.add(minHeap.poll());
    }
  }

  if(minHeap.size() == maxHeap.size()){
    return (maxHeap.element() + minHeap.element()) / 2.0;
  }else{
    return maxHeap.size() &gt; minHeap.size() ? 
      maxHeap.element() : minHeap.element();
  }
}

//solution
//Time complexity: O(n + m)
//Space complexity: O(1)
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int index1 = 0;
    int index2 = 0;
    int med1 = 0;
    int med2 = 0;
    for (int i=0; i&lt;=(nums1.length+nums2.length)/2; i++) {
        med1 = med2;
        if (index1 == nums1.length) {
            med2 = nums2[index2];
            index2++;
        } else if (index2 == nums2.length) {
            med2 = nums1[index1];
            index1++;
        } else if (nums1[index1] &lt; nums2[index2] ) {
            med2 = nums1[index1];
            index1++;
        }  else {
            med2 = nums2[index2];
            index2++;
        }
    }
    if ((nums1.length+nums2.length)%2 == 0) {
        return (float)(med1+med2)/2;
    }
    return med2;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-3 Longest Substring Without Repeating Characters]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-3-longest-substring-without-repeating-characters/">
        </link>
        <updated>2020-05-27T14:29:39.000Z</updated>
        <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;abcabcbb&quot;
Output: 3 
Explanation: The answer is &quot;abc&quot;, with the length of 3. 
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3. 
             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>
<pre><code class="language-java">//my submission
//Time complexity: O(n)
public int lengthOfLongestSubstring(String s) {
    if(s == null || s.length() == 0){
      return 0;
    }

    char[] chars = s.toCharArray();
    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
    int max = Integer.MIN_VALUE;

    for(int i = 0; i &lt; chars.length; i++){
      while(!queue.isEmpty() &amp;&amp; set.contains(chars[i])){
        set.remove(chars[queue.pollFirst()]);
      }
      queue.addLast(i);
      set.add(chars[i]);
      max = Math.max(max, queue.size());
    }
    return max;
}

//solution
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();
    int ans = 0, i = 0, j = 0;
    while (i &lt; n &amp;&amp; j &lt; n) {
      // try to extend the range [i, j]
      if (!set.contains(s.charAt(j))){
        set.add(s.charAt(j++));
        ans = Math.max(ans, j - i);
      }
      else {
        set.remove(s.charAt(i++));
      }
    }
    return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-2 Add Two Numbers]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-2-add-two-numbers/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-2-add-two-numbers/">
        </link>
        <updated>2020-05-27T14:27:20.000Z</updated>
        <content type="html"><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
</code></pre>
<pre><code class="language-java">//solution
//Time complexity: O(Max(m, n))
//Space complexity: O(Max(m, n))
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1;
    ListNode q = l2;
    ListNode cur = dummyHead;
    int carry = 0; 
    while(p != null || q != null){
      //若两链表不等长，多出来的按0计算
      int x = p == null ? 0 : p.val;
      int y = q == null ? 0 : q.val;
      
      //carry表示进位
      //若sum小于10, carry = sum / 10 = 0
      //若sum大于10，carry = sum / 10 = 1
      int sum = carry + x + y;
      carry = sum / 10;
      
     	//若sum小于10, sum % 10 = sum
      //若sum大于10，sum % 10 = sum - 10
      cur.next = new ListNode(sum % 10);
      cur = cur.next;
      if(p != null){
        p = p.next;
      }
      if(q != null){
        q = q.next;
      }
    }
    if(carry &gt; 0){
      cur.next = new ListNode(carry);
    }
    return dummyHead.next;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-1 Two Sum]]></title>
        <id>https://stevenXu1992.github.io/post/leetcode-1-two-sum/</id>
        <link href="https://stevenXu1992.github.io/post/leetcode-1-two-sum/">
        </link>
        <updated>2020-05-27T14:24:42.000Z</updated>
        <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have *<strong>exactly*</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>
<pre><code class="language-java">//my submission 
//Time complexity: O(n^2)
//Space complexity: O(1)
public int[] twoSum(int[] nums, int target) {
    if(nums == null || nums.length == 0){
      return null;
    }
    int[] res = new int[2];        
    for(int i = 0; i &lt; nums.length; i++){
      for(int j = 0; j &lt; nums.length; j++){
        if(nums[i] + nums[j] == target &amp;&amp; i != j){
          res[0] = i;
          res[1] = j;
        }
      }
    }   
    return res;
}

//solution
//Time complexity: O(n)
//Space complexity: O(n)
public int[] twoSum(int[] nums, int target) {
    if(nums == null || nums.length == 0){
      return null;
    }
    int[] res = new int[2];
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for(int i = 0; i &lt; nums.length; i++){
      map.put(nums[i], i);
    }
    for(int j = 0; j &lt; nums.length; j++){
      int rest = target - nums[j];
      if(map.containsKey(rest) &amp;&amp; map.get(rest) != j){
        res[0] = j;
        res[1] = map.get(rest);
      }
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划]]></title>
        <id>https://stevenXu1992.github.io/post/dong-tai-gui-hua/</id>
        <link href="https://stevenXu1992.github.io/post/dong-tai-gui-hua/">
        </link>
        <updated>2020-05-26T16:15:07.000Z</updated>
        <content type="html"><![CDATA[<p>暴力递归 --&gt; 动态规划步骤：</p>
<p>1)找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了</p>
<p>2)把可变参数的所有组合映射成一张表，有1个可变参数就是一维表，2个可变参数就 是二维</p>
<p>3)最终答案要的是表中的哪个位置，在表中标出</p>
<p>4)根据递归过程的 base case，把这张表的最简单不需要依赖其他位置的那些位置填好值</p>
<p>5)根据递归过程非base case的部分，也就是分析表中的普遍位置需要怎么计算得到，那 么这张表的填写顺序也就确定了</p>
<p>6)综上确定计算顺序，填好表，返回最终答案在表中位置的值</p>
<h2 id="1-机器人达到指定位置">1. 机器人达到指定位置</h2>
<p>假设有排成一行的 N 个位置，记为 1~N，N 一定大于或等于 2。开始时机器人在其中的 M 位 置上(M 一定是 1~N 中的一个)，机器人可以往左走或者往右走，如果机器人来到 1 位置， 那 么下一步只能往右来到 2 位置;如果机器人来到 N 位置，那么下一步只能往左来到 N-1 位置。 规定机器人必须走 K 步，最终能来到 P 位置(P 也一定是 1~N 中的一个)的方法有多少种。给 定四个参数 N、M、K、P，返回方法数。</p>
<pre><code class="language-java">public static int robot(int N, int S, int E, int K){
  // N:	共N个位置
  // S:	起点
  // E: 终点
  // K: 可以走的步数
  if(N &lt; 2 || K &lt; 1 || S &lt; 1 || S &gt; N || E &lt; 1 || E &gt; N){
    return 0;
  }
  
  //暴力递归
  int res = process1(N, S, E, K);
  
  //记忆化搜索
  int[][] dp = new int[K + 1][N + 1];
  for(int i = 0; i &lt; K; i++){
    for(int j = 0; j &lt; N; j++){
      dp[i][j] = -1;
    }
  }
  int res = process2(N, S, E, K, dp);
  
  //严格表结构动态规划
  int res = process(N, S, E, K);
  
}

//暴力递归
public static int process1(int N, int index, int E, int rest){
  // index: 当前位置
  // rest: 还剩rest步
  if(rest == 0){
    return index == E ? 1 : 0;
  }
  if(index == 1){
    return process(N, 2, E, rest - 1);
  }
  if(index == N){
    return process(N, N - 1, E, rest - 1);
  }
  return process(N, index + 1, E, rest - 1) 
        +  process(N, index - 1, E, rest - 1);
}

//记忆化搜索
public static int process2(int N, int index, int E, int rest, int[][] dp){
  if(dp[index][rest] != -1){
    return dp[index][rest];
  }
  
  if(rest == 0){
    dp[index][rest] = E ? 1 : 0;
  }else if(index == 1){
    dp[index][rest] = process(N, 2, E, rest - 1);
  }else if(index == N){
    dp[index][rest] = process(N, N - 1, E, rest - 1);
  }else{
    dp[index][rest] = process(N, index + 1, E, rest - 1) 
                         + process(N, index - 1, E, rest - 1);
  }
  return dp[index][rest];
}

//严格表结构动态规划
public static int process3(int N, int index, int E, int rest){
  int[][] dp = new int[index + 1][rest + 1];
  dp[E][0] = 1;
  for(int i = 1; i &lt; index; i++){
    for(int j = 1; j &lt; rest; j++){
      if(i == 1){
        dp[i][j] = dp[2][ j - 1];
      }
      if(i == N){
       dp[i][j] = dp[N - 1][j - 1]; 
      }
  		dp[i][j] = dp[i + 1][j - 1] + dp[i - 1][j - 1]
    }
  }
  return dp[index][rest];
}

</code></pre>
<h2 id="2-换钱的最少货币数">2. 换钱的最少货币数</h2>
<p>给定数组 arr，arr 中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim，代表要找的钱数，求组成 aim 的最少货币数。</p>
<pre><code class="language-java">public static int minCoin(int[] arr, int aim){
  if(arr.length == 0 || arr == null || aim &lt; 0){
    return -1;
  }
  
  //暴力递归
  int res = process1(arr, 0, aim);
  
  //记忆化搜索
  int[][] dp = new int[arr.length + 1][aim + 1];
  for(int i = 0; i &lt;= arr.length; i++){
    for(int j = 0; j &lt;= aim; j++){
      dp[i][j] = -2;
    }
  }
  int res = process2(arr, 0, aim, dp);
  
  
  //严格表结构动态规划
  int res = process3(arr, 0, aim);
}

//暴力递归
public static int process1(int[] arr, int index, int rest){
  if(rest &lt; 0){
    return -1;
  }
  if(rest == 0){
    return 0;
  }
  if(index == arr.length){
    return -1;
  }
  int p1 = process1(arr, index + 1, rest);
  int p2 = process1(arr, index + 1, rest - arr[index]);
  
  if(p1 == -1 &amp;&amp; p2 == -1){
    return -1;
  }
  if(p1 == -1){
    return p2 + 1;
  }
  if(p2 == -1){
    return p1;
  }
  return Math.min(p1, p2 + 1);
}


//记忆化搜索
public static int process2(int[] arr, int index, int rest, int[][] dp){
  if(rest &lt; 0){
    return -1;
  }
  if(dp[index][rest] != -2){
    return dp[index][rest];
  }
  
  if(rest == 0){
    dp[index][rest] = 0;
  }else if(index == arr.length){
    dp[index][rest] = -1;
  }else {
    int p1 = process1(arr, index + 1, rest);
  	int p2 = process1(arr, index + 1, rest - arr[index]);
    if(p1 == -1 &amp;&amp; p2 == -1){
    	dp[index][rest] = -1;
  	}else{
    	if(p1 == -1){
    		dp[index][rest] = p2 + 1;
  		}else if(p2 == -1){
    		dp[index][rest] = p1;
  		}else{
        dp[index][rest] = Math.min(p1, p2 + 1);  
      }
    }
  }
  return dp[index][rest];
}

//严格表结构动态规划
public static int process3(int[] arr, int index, int rest){
  int[][] dp = new int[arr.length + 1][rest + 1];
  for(int i = 0; i &lt;= arr.length; i++){
    dp[i][0] = 0;
  }
  for(int j = 1; j &lt;= rest; j++){
    dp[arr.length][j] = -1;
  }
  
  for(int i = arr.length - 1; i &gt;= 0; i--){
    for(int j = 1; j &lt;= rest; j++){
      int p1 = dp[i + 1][j];
      int p2 = -1;
      if(j - arr[i] &gt;= 0){
        p2 = dp[i + 1][j - arr[j]];
      }
      if(p1 == -1 &amp;&amp; p2 == -1){
        dp[i][j] = -1;
      }
      if(p1 == -1){
        dp[i][j] = p2 + 1;
      }
      if(p2 == -1){
        dp[i][j] = p1;
      }
      dp[i][j] = Math.min(p1, p2 + 1);
    }
  }
  return dp[index][rest];
}

</code></pre>
<h2 id="3-取纸牌问题">3. 取纸牌问题</h2>
<p>给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸 牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A 和玩家B都绝顶聪明。请返回最后获胜者的分数。</p>
<pre><code class="language-java">//暴力递归
public static int maxWinSorce1(int[] arr){
  if(arr == null){
    return 0;
  }
  return Math.max(
    firstHand(arr, 0, arr.length - 1),
    secondHand(arr, 0, arr.length - 1));
}

public static int firstHand(int[] arr, int left, int right){
  if(left == right){
    return arr[left];
  }
  Math.max(
    arr[left] + secondHand(arr, left + 1, right),
  	arr[right] + secondHand(arr, left, right -1)
  );
}

public static int secondHand(int[] arr, int left, int right){
  if(left == right){
    return 0;
  }
  Math.min(
    firstHand(arr, left + 1, right),
  	firstHand(arr, left, right -1)
  );
}

//动态规划
public static int maxWinScorce2(int[] arr){
  if(arr == null || arr.length = 0){
    return 0;
  }
  
  int N = arr.length;
  int[][] dpF = new int[N][N];
  int[][] dpS = new int[N][N];
  
  for(int left = 0; left &lt; N; left++){
    dpF[left][left] = arr[left];
    for(int right = left - 1; right &gt;= 0; right--){
      dpF[left][right] = Math.max(
        arr[left] + dpS[left + 1][right],
      	arr[right] + dpS[left][right - 1]);
       dpS[left][right] = Math.min(
        dpF[left + 1][right],
        dpF[left][right - 1]);
    }
  }
  return Math.max(dpF[0][N - 1], dpS[0][N - 1]);
}


</code></pre>
<h2 id="4象棋中马的跳法">4.象棋中马的跳法</h2>
<p>请同学们自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下 角是(0,0)位置。那么整个棋盘就是横坐标上9条线、纵坐标上10条线的一个区域。给你三个 参数，x，y，k，返回如果“马”从(0,0)位置出发，必须走k步，最后落在(x,y)上的方法数 有多少种?</p>
<pre><code class="language-java">//暴力递归
public static int process1(int x, int y, int k){
  if(x &lt; 0 || x &gt; 8 || y &lt; 0 || y &gt; 9){
    return 0;
  }
  //剩余步数为零时，所在位置(x,y)距终点的相对距离为(0,0)时找到一种跳法
  if(k == 0){
    return (x == 0 &amp;&amp; y == 0) ? 1 : 0;
  }
  int res = process1(x - 1, y + 2, k - 1)
				+ process1(x + 1, y + 2, k - 1)
				+ process1(x + 2, y + 1, k - 1)
				+ process1(x + 2, y - 1, k - 1)
				+ process1(x + 1, y - 2, k - 1)
				+ process1(x - 1, y - 2, k - 1)
				+ process1(x - 2, y - 1, k - 1)
				+ process1(x - 2, y + 1, k - 1);
  return res;
}

//动态规划
public static int process2(int x, int y, int k){
  if(x &lt; 0 || x &gt; 8 || y &lt; 0 || y &gt; 9){
    return 0;
  }
  
  //x,y,k为立方体的长宽高, k层的数据取决于k-1层，因此从下往上填
  int[][][] dp = new int[9][10][k + 1];
  dp[0][0][0] = 1;
  for(int height = 1; height &lt;= k; height++){
    for(int len = 0; len &lt; 9; len++){
      for(int wid = 0; wid &lt; 10; wid++){
        dp[len][wid][height] =
          getValue(dp, len - 1, wid + 2, height - 1)
				+ getValue(dp, len + 1, wid + 2, height - 1)
				+ getValue(dp, len + 2, wid + 1, height - 1)
				+ getValue(dp, len + 2, wid - 1, height - 1)
				+ getValue(dp, len + 1, wid - 2, height - 1)
				+ getValue(dp, len - 1, wid - 2, height - 1)
				+ getValue(dp, len - 2, wid - 1, height - 1)
				+ getValue(dp, len - 2, wid + 1, height - 1);
      }
    }
  }
  return dp[x][y][k];
}

public static int getValue(int[][][] dp, int height, int len, int wid){
  if(len &lt; 0 || len &gt; 8 || wid &lt; 0 || wid &gt; 9){
    return 0;
  }
  return dp[len][wid][height];
}

</code></pre>
<h2 id="5-bob的生存概率">5. Bob的生存概率</h2>
<p>给定五个参数n,m,i,j,k。表示在一个N*M的区域，Bob处在(i,j)点，每次Bob等概率的向上、 下、左、右四个方向移动一步，Bob必须走K步。如果走完之后，Bob还停留在这个区域上， 就算Bob存活，否则就算Bob死亡。请求解Bob的生存概率，返回字符串表示分数的方式。</p>
<pre><code class="language-java">//暴力递归
public static String bob(int n, int m, int i, int j, int k){
  long all = (long)Math.pow(4, k);
  long live = process1(n, m, i, j, k);
  long gc = gcd(all, live);
  return String.valueOf((live / gc) + &quot;/&quot; + (all / gc));
  
}

//返回可以存活的走法数
public static long process1(int N, int M, int i, int j, 
                           int rest){
  if(i &lt; 0 || i &gt; N || j &lt; 0 || j &gt; M){
    return 0;
  }
  if(rest == 0){
    return 1;
  }
  long live = process1(N, M, i + 1, j, rest - 1)
    				+ process1(N, M, i, j + 1, rest - 1)
    				+ process1(N, M, i - 1, j, rest - 1)
    				+ process1(N, M, i, j - 1, rest - 1);
}

//动态规划
public static long process2(int N, int M, int i, int j, 
                           int K){
  int[][][] dp = new int[N + 1][M + 1][K + 1];
  for(int len = 0; len &lt;= N; len++){
    for(int wid = 0; wid &lt;= M; wid++){
      dp[len][wid][0] = 1;
    }
  }
  for(int height = 1; height &lt;= K; height++){
    for(int len = 0; len &lt;= N; len++){
      for(int wid = 0; wid &lt;= M; wid++){
        dp[len][wid][height] = 
        			dp[len + 1][wid][height - 1]
    				+ dp[len - 1][wid][height - 1]
    				+ dp[len][wid + 1][height - 1]
    				+ dp[len][wid - 1][height - 1];
      }
    }
  }
  return dp[i][j][K];
}


public static long gcd(long m, long n){
  return n == 0 ? m : gcd(n, m % n);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Morris遍历]]></title>
        <id>https://stevenXu1992.github.io/post/morris-bian-li/</id>
        <link href="https://stevenXu1992.github.io/post/morris-bian-li/">
        </link>
        <updated>2020-05-25T08:14:24.000Z</updated>
        <content type="html"><![CDATA[<p>Morris遍历细节 假设来到当前节点cur，开始时cur来到头节点位置</p>
<p>1)如果cur没有左孩子，cur向右移动(cur = cur.right)</p>
<p>2)如果cur有左孩子，找到左子树上最右的节点mostRight:</p>
<p>​	a.如果mostRight的右指针指向空，让其指向cur， 然后cur向左移动(cur = cur.left)</p>
<p>​	b.如果mostRight的右指针指向cur，让其指向null， 然后cur向右移动(cur = cur.right)</p>
<p>3)cur为空时遍历停止</p>
<h2 id="1morris自然序遍历">1.Morris自然序遍历</h2>
<p>Morris序： 1 -&gt; 2 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 3 -&gt; 6 -&gt; 3 -&gt; 7</p>
<pre><code class="language-java">public static void morrisClassical(Node head){
  if(head == null){
    return;
  }
  
  Node cur = head;
  Node mostR = null;
  while(cur != null){
    mostR = cur.left;
    //cur有左树，找到左树上最右的节点
    if(mostR != null){
      while(mostR.right != null &amp;&amp; mostR.right != cur){
        mostR = mostR.right;
      }
      //此时mostR已到达cur左树上最右的节点处
      if(mostR.right == null){
        //若发现mostR右树为空，则是第一次到达该点
        mostR.right = cur;
        //先序操作
        //将mostR.right指向cur后，cur继续往下走执行外部while循环
        cur = cur.left;
        continue;
      }else{
        //若发现mostR.right指向cur，则是第二次到达该点，还原指针
        mostR.right = null;
        //edgeR(cur.left); 后序操作
      }
    }//else{先序操作}
    //cur无左树，cur向右移动（通过之前修改的mostR.right指针返回父节点）,继续执行外部的while循环
    //中序操作
    cur = cur.right;
  }
  //edgeR（head); 后序操作
}
</code></pre>
<h2 id="2先序遍历">2.先序遍历</h2>
<p>先序： 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p>
<p>首次到达时进行操作，见1自然序注释</p>
<h2 id="3中序遍历">3.中序遍历</h2>
<p>先序： 4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</p>
<p>叶节点直接操作，其他节点第二次达到时操作，见1自然序注释</p>
<h2 id="4后序遍历">4.后序遍历</h2>
<p>后序： 4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1</p>
<p>发现第二次到达时，逆序操作cur左树的右边界，遍历完成后逆序操作整棵树的右边界，见1自然序注释</p>
<pre><code class="language-java">public static void edgeR(Node head){
  Node tail = reverseEdge(head);
  Node cur = tail;
  while(cur != null){
    //遍历操作
    cur = cur.right;
  }
  reverseEdge(tail);
}

public static Node reverseEdge(Node from){
  Node pre = null;
  Node next = next;
  while(from != null){
    next = from.right;
    from.right = pre;
    pre = from;
    from = next;
  }
  return pre;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[特殊结构]]></title>
        <id>https://stevenXu1992.github.io/post/te-shu-jie-gou/</id>
        <link href="https://stevenXu1992.github.io/post/te-shu-jie-gou/">
        </link>
        <updated>2020-05-25T06:33:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1滑动窗口">1.滑动窗口</h2>
<pre><code class="language-java">//窗口结构（最大值）
public static class WindowMax{
  private int L;
  private int R;
  private int[] arr;
  //队列中存放数组的下标，peekfirst最大值
  private LinkedList&lt;Integer&gt; queue; 
  
  //初始化窗口
  public WindowMax(int[] arr){
    this.arr = arr;
    L = -1;
    R = 0;
    queue = new LinkedList&lt;&gt;(); 
  }
  
  //窗口右边界移动
  public void shiftRight(){
    if(R == arr.length){
      return;
    }
    while(!queue.isEmpty() &amp;&amp; arr[queue.peekLast()]&lt;=arr[R]){
      queue.pollLast();
    }
    queue.addLast(R);
    R++;
  }
  
  //窗口左边界移动
  public void shiftLeft(){
    if(L &gt; R - 1){
      return;
    }
    L++;
    if(queue.peekFirst() == L){
      queue.pollFirst();
    }
  }
  
  //获取窗口内最大值
  public int getMax(){
    if(!queue.isEmpty()){
      return arr[queue.peekFirst()];
    }
    return null;
  }
}

//请实现一个函数。 输入:整型数组arr，窗口大小为w。 输出:一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值
public static int[] getMaxInWindow(int[] arr, int w){
  if(arr == null || w &lt; 1 || arr.length &lt; w){
    return null;
  }
  LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
  int[] res = new int[arr.length - w + 1];
  int index = 0;
  for(int i = 0; i &lt; arr.length; i++){
    //窗口右边界向右滑动
    while(!queue.isEmpty() &amp;&amp; arr[queue.peekLast()] &lt;=arr[i]){
      queue.pollLast();
    }
  	queue.addLast(i);
    //窗口左边界向右滑动
    if(queue.peekFirst() == i - w){ 
      //i-w：过期的点，刚从窗口中出来的点，判断该点是否是队列的first
      queue.pollFirst();
    }
    //保存最大值信息
    if(i &gt;= w - 1){
      res[index++] = queue.peekFirst();
    }
  }
  return res;
}
</code></pre>
<h2 id="2单调栈">2.单调栈</h2>
<p>在数组中想找到一个数，左边和右边比这个数小、且离这个数最近的位置。如果对每一个数都想求这样的信息，能不能整体代价达到O(N)?</p>
<pre><code class="language-java">public static int[][] monotonousStack1(int[] arr){
  if(arr == null || arr.length &lt; 1){
    return null;
  }
  int[][] res = new int[arr.length][2];
  //单调栈顶为最大值,栈内存储数组的下标
  Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
  for(int i = 0; i &lt; arr.length; i++){
    //若新加元素小于栈顶，则弹出栈顶元素并记录结果
    while(!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]){
      int popIndex = stack.pop();
      int leftIndex = stack.isEmpty() ? -1 : stack.peek();
      res[popIndex][0] = leftIndex;
      res[popIndex][1] = i;
    }
    stack.push(i);
  }
  //加完全部元素并记录了结果后，弹出剩下的元素并记录
  while(!stack.isEmpty()){
    int popIndex = stack.pop();
    int leftIndex = stack.isEmpty() ? -1 : stack.peek();
    res[popIndex][0] = leftIndex;
    res[popIndex][1] = -1;
  }
  return res;
}

//数组中有重复的元素
public static int[][] monotonousStack2(int[] arr){
  Stack&lt;List&lt;Integer&gt;&gt; stack = new Stack&lt;&gt;();
  int[][] res = new int[arr.length][2];
  for(int i = 0; i &lt; arr.length; i++){
    //新加元素小于栈顶
    	while(!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]){
        int popIndex = stack.pop();
        int leftIndex = stack.isEmpty() ? 
          -1 : stack.peek().get(stack.peek().size() - 1);
        res[popIndex][0] = leftIndex;
        res[popIndex][1] = i;
      }
    //新加元素等于栈顶
    if(arr[i] == arr[stack.peek().get(0)]{
      stack.peek().add(Integer.valueOf(i));
    }else{
      //新加元素大于栈顶
      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
      list.add(i);
      stack.push(list);
    }
  }
  //加完全部元素并记录了结果后，弹出剩下的元素并记录
  while(!stack.isEmpty()){
    List&lt;Integer&gt; restList = stack.pop();
    int leftIndex = stack.isEmpty() ? 
      -1 : stack.peek().get(stack.peek().size() - 1);
    for(Integer i : restList){
      res[i][0] = leftIndex;
      res[i][1] = -1;
    }
  }
  return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串算法]]></title>
        <id>https://stevenXu1992.github.io/post/zi-fu-chuan-suan-fa/</id>
        <link href="https://stevenXu1992.github.io/post/zi-fu-chuan-suan-fa/">
        </link>
        <updated>2020-05-23T17:17:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-前缀树">1. 前缀树</h2>
<pre><code class="language-java">public static class TrieNode{
  public int pass;
  public int end;
  public TrieNode[] nexts;
  
  public TrieNode(){
    pass = 0;
    end = 0;
    nexts = new TrieNode[26];
  }
}

public static class Trie{
  private TrieNode root;
  public Trie(){
    root = new TrieNode();
  }
  
  //加入单词
  public static void insert(String word){
    if(word == null){
      return;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    node.pass++;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        node.nexts[index] = new TrieNode();
      }
      node = node.nexts[index];
      node.pass++;
    }
    node.end++;
  }
  
  //查询某单词加过几次
  public static int search(String word){
    if(word == null){
      return 0;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        return 0;
      }
      node = node.nexts[index];
    }
    return node.end;
  }
  
  //查询某前缀加过几次
  public static int searchPrefix(String word){
    if(word == null){
      return 0;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(node.nexts[index] == null){
        return 0;
      }
      node = node.nexts[index];
    }
    return node.pass;
  }
  
  //删除单词
  public static void delete(String word){
    if(search(word) == 0){
      return;
    }
    char[] chars = word.toCharArray();
    TrieNode node = root;
    node.pass--;
    int index = 0;
    for(int i = 0; i &lt; chars.length; i++){
      index = chars[i] - 'a';
      if(--node.nexts[index].pass == 0){
        node.nexts[index] == null;
        return;
      }
    }
    node.end--;
  }
  
}
</code></pre>
<h2 id="2-kmp">2. KMP</h2>
<pre><code class="language-java">public static int KMP(String str1, String str2){
  if(str1 == null || str2 == null || 
     str2.length &gt; str1.length || str2.length() &lt; 1){
    return -1;
  }
  char[] char1 = str1.toCharArray();
  char[] char2 = str2.toCharArray();
  int[] next = getNext(char2);
  int i1 = 0;
  int i2 = 0;
  
  while(i1 &lt; char1.length &amp;&amp; i2 &lt; char2.length){
    if(char1[i1] == char2[i2]){
      i1++;
      i2++;
    }else if(i2 == 0){
      i1++;
    }else{
      i2 = next[i2];
    }
  }
  return i2 == char2.length ? i1 - i2 : -1;
}

//获取每个字符之前的最大相同前缀后缀的长度
public static int[] getNext(char[] chars){
  if(chars.length == 1){
    return new int[]{-1};
  }
  
  int[] next = new int[chars.length];
  next[0] = -1;
  next[1] = 0;
  int index = 2;
  int cn = 0;
  
  while(index &lt; next.length){
    if(chars[index - 1] == chars[cn]){
      next[index++] = cn++;
    }else(cn &gt; 0){
      cn = next[cn];
    }else{
      next[index++] = 0;
    }
  }
  return next;
}
</code></pre>
<h2 id="3-manacher">3. Manacher</h2>
<pre><code class="language-java">public static int manacher(String str){
  if(str == null || str.length == 1){
    return 0;
  }
  char[] chars = getManacherString(str);
  int[] help = new int[chars.length];
  int R = -1;	//R为已找到的最大回文区域的右边界
  int C = -1;	//C为最大回文区域的中心点
  int max = Integer.MIN_VALUE;
  for(int i = 0; i != chars.length; i++){
    
    //情况1: i超出已知的最大回文区域右边界，正常向两边寻找回文区域
    //情况2: i在已知的最大回文区域右边界内部
    //	1）i'的回文区域不超过最大回文区域的左边界：与i相同
    //	2）i'的回文区域超过最大回文区域的左边界：与R-i相同
    //	3）i'的回文区域正好在最大回文区域的左边界上：在R-i的基础上正常向两边寻找回文区域
    //2 * C - i 为 i'
    help[i] = R &gt; i ? Math.min(help[2 * C - i], R - i) : 1;
    while(i + help[i] &lt; chars.length &amp;&amp; i - help[i] &gt; -1){
      if(chars[i + help[i]] == chars[i - help[i]]){
        help[i]++;
      }else{
        break;
      }
    }
    //更新R和C
     if(i + help[i] &gt; R){
        R = i + help[i];
        C = i;
      }
      max = Math.max(max, help[i]);
  }
  return max - 1;
}

public static char[] getManacherString(String str){
  char[] chars = str.toCharArray();
  char[] res = new char[str.length * 2 - 1];
  int index = 0;
  for(int i = 0; i &lt; chars.length; i++){
    res[i] = (i &amp; 1) == 0 ? '#' : chars[index++];
  }
  return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集]]></title>
        <id>https://stevenXu1992.github.io/post/bing-cha-ji/</id>
        <link href="https://stevenXu1992.github.io/post/bing-cha-ji/">
        </link>
        <updated>2020-05-23T06:56:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-并查集结构">1. 并查集结构</h2>
<pre><code class="language-java">public class UnionFind{
  
  //并查集元素
  public static class Element&lt;V&gt;{
    public V value;
    public Element(V value){
      this.value = value;
    }
  } 
  
  //并查集初始化
  public static class UnionSet{
    HashMap&lt;V, Element&lt;V&gt;&gt; elementMap;
    HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;
    HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap;
    
    public UnionSet&lt;V&gt;(List&lt;V&gt; list){
      elementMap = new HashMap&lt;&gt;();
      fatherMap = new HashMap&lt;&gt;();
      sizeMap = new HashMap&lt;&gt;();
      for(V v: list){
        Element&lt;V&gt; e = new Element&lt;&gt;(v);
        elementMap.put(v, e);
        fatherMap.put(e, e);
        sizeMap.put(e, 1);
      }
    }
  }
  
  //判断是否属于同一集合
  public static boolean same(V v1, V v2){
    if( elementMap.containsKey(v1)
     &amp;&amp; elementMap.containsKey(v2)){
      	return findHead(elementMap.get(v1)) 
          ==  findHead(elementMap.get(v2));	
    	}
    return false;
  }
  
  
  //集合合并
  public static void union(V v1, V v2){
    if(elementMap.containsKey(v1)
     &amp;&amp; elementMap.containsKey(v2)){
      Element&lt;V&gt; head1 = findHead(elementMap.get(v1));
      Element&lt;V&gt; head2 = findHead(elementMap.get(v2));
      if(head1 != head2){
        Element&lt;V&gt; big = 
          sizeMap.get(head1) &gt;= sizeMap.get(head2) ?
          head1 : head2;
        Element&lt;V&gt; small = big == head1 ? head2 : head1:
        fatherMap.put(small, big);
        sizeMap.put(big,sizeMap.get(big)+sizeMap.get(small));
        sizeMap.remove(small);
      }
    }
  }
  
  
  //查找头元素
  private static Element&lt;V&gt; findHead(Element&lt;V&gt; e){
    Stack&lt;Element&lt;V&gt;&gt; stack = new Stack&lt;&gt;();
    while(e != fatherMap.get(e)){
      stack.push(e);
      e = fatherMap.get(e);
    }
    while(!stack.isEmpty()){
      fatherMap.put(stack.pop(), e);
    }
    return e;
  }  
  
}
</code></pre>
<h2 id="2kruskal最小生成树">2.Kruskal最小生成树</h2>
<pre><code class="language-java">//优先级队列的比较器，权重小的边先出
public static class myComparator implements Comparator&lt;edge&gt;{
  public int compare(Edge o1, Edge o2){
    return o1.weight - o1.weight;
  }
}

public static Set&lt;Edge&gt; kruskal(Graph graph){
  List&lt;Node&gt; list = (List&lt;Node&gt;)graph.nodes.values();
  UnionSet&lt;Node&gt; unionSet = new unionSet&lt;&gt;(List);
  PriorityQueue&lt;Edge&gt; queue = 
    new PriorityQueue&lt;&gt;(new myComparator());
  for(Edge e : graph.edges){
    queue.add(e);
  }
  
  HashSet&lt;Edge&gt; res = new HashSet&lt;&gt;();
  while(!queue.isEmpty()){
    Edge e = queue.poll();
    if(!unionSet.same(e.from, e.to)){
      res.add(e);
      unionSet.union(e.from, e.to);
    }
  }
  return res;
  
}
</code></pre>
<h2 id="3-岛问题的并行算法设计">3. 岛问题的并行算法设计</h2>
<pre><code class="language-java">public static int island(int[][] matrix){
  if(matrix == null || matrix[0] == null){
    return 0;
  }
  
  int length = matrix.length;
  int width = matrix[0].length;
  int res = 0;
  
  for(int i = 0; i &lt; length; i++){
    for(int j = 0; j &lt; width; j++){
      if(matrix[i][j] == 1){
        res++;
        infect(matrix, i, j, length, width);
      }
    }
  }
}

public static void infect(int[] matrix, int i, int j, int length, int width){
  if(i &lt; 0 || i &gt;= length || j &lt; 0 || j &gt;= width 
     || matrix[i][j] != 1){
    return;
  }
  	matrix[i][j] = 2;
    infect(matrix, i + 1, j, length, width);
    infect(matrix, i - 1, j, length, width);
    infect(matrix, i, j + 1, length, width);
    infect(matrix, i, j - 1, length, width);
  
}
</code></pre>
]]></content>
    </entry>
</feed>