<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stevenXu1992.github.io</id>
    <title>Gridea</title>
    <updated>2020-04-24T09:15:13.438Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stevenXu1992.github.io"/>
    <link rel="self" href="https://stevenXu1992.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://stevenXu1992.github.io/images/avatar.png</logo>
    <icon>https://stevenXu1992.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[二叉树的递归框架]]></title>
        <id>https://stevenXu1992.github.io/post/er-cha-shu-de-di-gui-kuang-jia/</id>
        <link href="https://stevenXu1992.github.io/post/er-cha-shu-de-di-gui-kuang-jia/">
        </link>
        <updated>2020-04-24T09:04:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1判断一棵树是否为满二叉树">1.判断一棵树是否为满二叉树</h2>
<p>满二叉树条件：总节点个数 = 2 ^ 高度 - 1</p>
<ol>
<li>定义一个信息类，用于获取需要的信息（此处为节点数和高度）</li>
<li>递归函数中先使用黑盒，再补充黑盒中获取信息的操作（此处为假定通过黑盒已获取到了当前节点的左右子树的高度和节点个数，使用该信息得出当前节点处的高度和节点个数）</li>
<li>在主函数中判断是否满足条件</li>
</ol>
<pre><code class="language-java">//定义信息类
public static class Info{
  public int size;
  public int height;
  public Info(int s, int h){
    this.size = s;
    this.height = h;
  }
}
//递归函数
public static Info process(Node head){
  if(head == null){
    return new Info(0, 0);
  }
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  int size = leftInfo.size + rightInfo.size + 1;
  int height = Math.max(leftInfo.height, rightInfo.height)+1;
  return new Info(size, height);
} 
//主函数
public static boolean isFullTree(Node head){
  Info info = process(head);
  return info.size == (1 &lt;&lt; height) - 1; // 左移1位=2^height
}
</code></pre>
<h2 id="2判断一棵树是否为平衡二叉树">2.判断一棵树是否为平衡二叉树</h2>
<p>平衡二叉树条件：左右子树高度差不超过1且所有子树都平衡<br>
信息类：高度，子树是否平衡</p>
<pre><code class="language-java">public static class Info{
  public int height;
  public boolean balance;
  public Info(int h, boolean b){
    this.height = h;
    this.balance = b;
  }
}
public static Info process(Node head){
  if(head == null){
    return new Info(0, true);
  }
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  int height = Math.max(leftInfo.height, rightInfo.height) +1;
  boolean balance = 
    leftInfo.balance &amp;&amp; rightInfo.balance 
    &amp;&amp; Math.abs(leftInfo.height - rightInfo.height) &lt; 2;
  return new Info(height, balance);
}
</code></pre>
<h2 id="3求二叉树两节点间的最大距离">3.求二叉树两节点间的最大距离</h2>
<p>信息类：高度，最大距离<br>
最大距离出现的三种情况：左树上，右树上，横跨头节点</p>
<pre><code class="language-java">public static class Info{
  public int height;
  public int distance;
  public Info(int h, int d){
    this.height = h;
    this.distance = d;
  }
}
public static Info process(Node head){
  if(head = null){
    return new Info(0, 0);
  }
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  int height = Math.max(leftInfo.height, rightInfo.height) +1;
  int distance = Math.max(leftInfo.height+rightInfo.height+1,
             Math.max(leftInfo.distance, rightInfo.distance));
  return new Info(height, distance);
}
</code></pre>
<h2 id="4判断一棵树是否为搜索二叉树">4.判断一棵树是否为搜索二叉树</h2>
<p>搜索二叉树的条件：1）左树是搜索二叉树， 2）右树是搜索二叉树，3）左树的最大值小于头节点， 4）右树的最小值大于头节点<br>
信息类：是否为搜索二叉树，最大值，最小值</p>
<pre><code class="language-java">public static class Info{
  public boolean searchTree;
  public int max;
  public int min;
  public Info(boolean s, int max, int min){
    this.searchTree = s;
    this.max = max;
    this.min = min;
  }
}
public static Info process(Node head){
  if(head == null){
    return null;
  }
  
  Info leftInfo = process(head.left);
  Info rightInfo = process(head.right);
  
  int max = head.data;
  int min = head.data;
  
  if(leftInfo != null){
    max = Math.max(max, leftInfo.max);
    min = Math.min(min, leftInfo.min);
  }
  if(rightInfo != null){
    max = Math.max(max, rightInfo.max);
    min = Math.min(min, rightInfo.min);
  }
  
  boolean searchTree = false;
  //三目的意义：若左树不为空，按1）左树是搜索树 2）左树最大值小于节点值 进行判断；若左树为空，则直接为true不用判断。右树同理。
  if(
    (leftInfo != null ? 
    (leftInfo.searchTree &amp;&amp; leftInfo.max &lt; head.data) : true)
    &amp;&amp;
    (rightInfo != null ?
    (rightInfo.searchTree &amp;&amp; rightInfo.min &gt; head.data): true)
  ){
    searchTree = true;
  }
  return new Info(searchTree, max, min);
}
</code></pre>
<h3 id="中序遍历方法">中序遍历方法</h3>
<pre><code class="language-java">public static boolean searchTree(Node head){
  if(head == null){
    return true;
  }
  Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
  Node cur = head;
  int pre = Integer.MIN_VALUE;
  while(!stack.isEmpty() || cur != null){
    if(cur != null){
      stack.push(cur);
      cur = cur.left;
    }else{
      cur = stack.pop();
      if(cur.data &lt;= pre){
        return false;
      }
      pre = cur.data;
      cur = cur.right;
    }
  }
  return true;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的遍历]]></title>
        <id>https://stevenXu1992.github.io/post/er-cha-shu-de-bian-li/</id>
        <link href="https://stevenXu1992.github.io/post/er-cha-shu-de-bian-li/">
        </link>
        <updated>2020-04-19T13:04:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-递归遍历">1. 递归遍历</h2>
<pre><code class="language-java">public static class Node{
  public int value;
  public Node left;
  public Node right;
  
  public Node(int data){
    this.value = data;
  }
}

public static void f(Node head){
  if(head == null){
    return;
  }
  //先序遍历操作
  f(head.left);
  //中序遍历操作
  f(head.right);
  //后序遍历操作
}
</code></pre>
<p>二叉树递归遍历的本质：通过树的完整递归序加工而成<br>
完整递归序：1 -&gt; 2 -&gt; 2 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 1<br>
先序：第一次来到节点时进行操作 1 -&gt; 2 -&gt; 3<br>
中序：第二次来到节点时进行操作 2 -&gt; 1 -&gt; 3<br>
后序：第三次来到节点时进行操作 2 -&gt; 3 -&gt; 1</p>
<h2 id="2-非递归遍历">2. 非递归遍历</h2>
<h3 id="21-先序遍历">2.1 先序遍历</h3>
<p>遍历顺序：中 --&gt; 左 --&gt; 右，1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p>
<ol>
<li>建立栈结构，压入头节点</li>
<li>从栈中弹出当前节点，并执行遍历操作</li>
<li>先压入弹出节点的右子节点，再压左子节点，重复步骤2直到栈为空</li>
</ol>
<pre><code class="language-java">public static void preUnRecur(Node head){
  if(head != null){
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    stack.add(head);
    while(!stack.isEmpty()){
      head = stack.pop();
      //该处执行遍历操作
      if(head.right != null){
        stack.push(head.right);
      }
      if(head.left != null){
        stack.push(head.left);
      }
    }
  }
}
</code></pre>
<h3 id="22-中序遍历">2.2 中序遍历</h3>
<p>遍历顺序：左 --&gt; 中 --&gt; 右，4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 -&gt; 7</p>
<ol>
<li>建立栈结构，压入头节点</li>
<li>不断将当前节点的左子节点压栈，直到某节点的左子节点为空，此时从栈中弹出该节点并执行遍历操作</li>
<li>若弹出节点的右子节点不为空，重复步骤2；若为空，则继续从栈中弹出下一节点直到栈为空</li>
</ol>
<pre><code class="language-java">public void inUnRecur(Node head){
  if(head != null){
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    Node cur = head;
    while(!stack.isEmpty() || cur != null){
      if(cur != null){
        stack.push(cur);
        cur = cur.left;
      }else{
        cur = stack.pop();
        //此处执行遍历操作
        cur = cur.right;
      }
    }
  }
}
</code></pre>
<h3 id="23-后序遍历">2.3 后序遍历</h3>
<p>遍历顺序：左 --&gt; 右 --&gt; 中，4 -&gt; 5 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 3 -&gt; 1<br>
类似于先序遍历，按照先左后右的顺序压栈。额外准备一个栈，将弹出节点压入，直到1号栈为空时，将节点依次从2号栈弹出并执行遍历操作。</p>
<pre><code class="language-java">public static void postUnRecur(Node head){
  if(head != null){
    Stack&lt;Node&gt; s1 = new Stack&lt;&gt;();
    Stack&lt;Node&gt; s2 = new Stack&lt;&gt;();
    s1.push(head);
    while(!s1.isEmpty()){
      head = s1.pop();
      s2.push(head);
      if(head.left != null){
        s1.push(head.left);
      }
      if(head.right != null){
        s1.push(head.right);
      }
    }
    while(!s2.isEmpty()){
      head = s2.pop();
      //此处执行遍历操作
    }
  }
}
</code></pre>
<h2 id="3宽度优先遍历">3.宽度优先遍历</h2>
<ol>
<li>使用哈希表记录每个节点所在层数，使用队列进行宽度优先遍历</li>
<li>每个节点都进入队列，其左右子节点层数+1进入哈希表</li>
<li>从队列弹出时，比较该节点所在层数是否大于当前层数，若大于（说明已到了下一层），则将当前层宽度清零并更新当前层数；若不大于（说明还在同一层），则当前层宽度+1。每次对一个节点操作完成后都比较并更新最大宽度与当前层宽度的最大值。</li>
</ol>
<pre><code class="language-java">public static int getMaxWidth(Node head){
  if(head ==null){
    return 0;
  }
  int maxWidth = 0;
  int curWidth = 0;
  int curLevel = 0;
  HashMap&lt;Node, Integer&gt; levelMap = new HashMap&lt;&gt;();
  LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();
  levelMap.put(head, 1);
  queue.add(head);
  Node cur = null;
  Node left = null;
  Node right = null;
  while(!queue.isEmpty()){
    cur = queue.poll();
    left = cur.left;
    right = cur.right;
    if(left != null){
      levelMap.put(left, levelMap.get(cur) + 1);
      queue.add(left);
    }
    if(right != null){
      levelMap.put(right, levelMap.get(cur) + 1);
      queue.add(right);
    }
    if(levelMap.get(cur) &gt; curLevel){
      curWidth = 0;
      curLevel = levelMap.get(cur);
    }else{
      curWidth++;
    }
    maxWidth = Math.max(curWidth, maxWidth);
  }
  return maxWidth;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://stevenXu1992.github.io/post/hello-gridea/</id>
        <link href="https://stevenXu1992.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>